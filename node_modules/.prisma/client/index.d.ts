
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VendorCategory
 * 
 */
export type VendorCategory = $Result.DefaultSelection<Prisma.$VendorCategoryPayload>
/**
 * Model VendorDocument
 * 
 */
export type VendorDocument = $Result.DefaultSelection<Prisma.$VendorDocumentPayload>
/**
 * Model CSI_Material
 * 
 */
export type CSI_Material = $Result.DefaultSelection<Prisma.$CSI_MaterialPayload>
/**
 * Model PriceEntry
 * 
 */
export type PriceEntry = $Result.DefaultSelection<Prisma.$PriceEntryPayload>
/**
 * Model RFQ
 * 
 */
export type RFQ = $Result.DefaultSelection<Prisma.$RFQPayload>
/**
 * Model RFQSubmission
 * 
 */
export type RFQSubmission = $Result.DefaultSelection<Prisma.$RFQSubmissionPayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model VariationOrder
 * 
 */
export type VariationOrder = $Result.DefaultSelection<Prisma.$VariationOrderPayload>
/**
 * Model IPC
 * 
 */
export type IPC = $Result.DefaultSelection<Prisma.$IPCPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Approval
 * 
 */
export type Approval = $Result.DefaultSelection<Prisma.$ApprovalPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const RoleName: {
  ADMIN: 'ADMIN',
  PROCUREMENT_MANAGER: 'PROCUREMENT_MANAGER',
  PROCUREMENT_ENGINEER: 'PROCUREMENT_ENGINEER',
  COST_MANAGER: 'COST_MANAGER',
  PROJECT_MANAGER: 'PROJECT_MANAGER',
  TECHNICAL_OFFICE: 'TECHNICAL_OFFICE',
  DATA_CONTROLLER: 'DATA_CONTROLLER',
  VENDOR_USER: 'VENDOR_USER'
};

export type RoleName = (typeof RoleName)[keyof typeof RoleName]


export const VendorStatus: {
  NEW: 'NEW',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  BLACKLISTED: 'BLACKLISTED'
};

export type VendorStatus = (typeof VendorStatus)[keyof typeof VendorStatus]


export const RFQStatus: {
  DRAFT: 'DRAFT',
  ISSUED: 'ISSUED',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  AWARDED: 'AWARDED',
  CANCELED: 'CANCELED'
};

export type RFQStatus = (typeof RFQStatus)[keyof typeof RFQStatus]


export const IPCStatus: {
  SUBMITTED: 'SUBMITTED',
  PROCUREMENT_REVIEW: 'PROCUREMENT_REVIEW',
  TECHNICAL_APPROVED: 'TECHNICAL_APPROVED',
  FINANCE_REVIEW: 'FINANCE_REVIEW',
  APPROVED: 'APPROVED',
  PAID: 'PAID',
  REJECTED: 'REJECTED'
};

export type IPCStatus = (typeof IPCStatus)[keyof typeof IPCStatus]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ESCALATED: 'ESCALATED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]

}

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type VendorStatus = $Enums.VendorStatus

export const VendorStatus: typeof $Enums.VendorStatus

export type RFQStatus = $Enums.RFQStatus

export const RFQStatus: typeof $Enums.RFQStatus

export type IPCStatus = $Enums.IPCStatus

export const IPCStatus: typeof $Enums.IPCStatus

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorCategory`: Exposes CRUD operations for the **VendorCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorCategories
    * const vendorCategories = await prisma.vendorCategory.findMany()
    * ```
    */
  get vendorCategory(): Prisma.VendorCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorDocument`: Exposes CRUD operations for the **VendorDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorDocuments
    * const vendorDocuments = await prisma.vendorDocument.findMany()
    * ```
    */
  get vendorDocument(): Prisma.VendorDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cSI_Material`: Exposes CRUD operations for the **CSI_Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CSI_Materials
    * const cSI_Materials = await prisma.cSI_Material.findMany()
    * ```
    */
  get cSI_Material(): Prisma.CSI_MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceEntry`: Exposes CRUD operations for the **PriceEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceEntries
    * const priceEntries = await prisma.priceEntry.findMany()
    * ```
    */
  get priceEntry(): Prisma.PriceEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rFQ`: Exposes CRUD operations for the **RFQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RFQS
    * const rFQS = await prisma.rFQ.findMany()
    * ```
    */
  get rFQ(): Prisma.RFQDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rFQSubmission`: Exposes CRUD operations for the **RFQSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RFQSubmissions
    * const rFQSubmissions = await prisma.rFQSubmission.findMany()
    * ```
    */
  get rFQSubmission(): Prisma.RFQSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variationOrder`: Exposes CRUD operations for the **VariationOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariationOrders
    * const variationOrders = await prisma.variationOrder.findMany()
    * ```
    */
  get variationOrder(): Prisma.VariationOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.iPC`: Exposes CRUD operations for the **IPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IPCS
    * const iPCS = await prisma.iPC.findMany()
    * ```
    */
  get iPC(): Prisma.IPCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approval`: Exposes CRUD operations for the **Approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Approvals
    * const approvals = await prisma.approval.findMany()
    * ```
    */
  get approval(): Prisma.ApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.0
   * Query Engine version: c0aafc03b8ef6cdced8654b9a817999e02457d6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Vendor: 'Vendor',
    VendorCategory: 'VendorCategory',
    VendorDocument: 'VendorDocument',
    CSI_Material: 'CSI_Material',
    PriceEntry: 'PriceEntry',
    RFQ: 'RFQ',
    RFQSubmission: 'RFQSubmission',
    Evaluation: 'Evaluation',
    Contract: 'Contract',
    VariationOrder: 'VariationOrder',
    IPC: 'IPC',
    Document: 'Document',
    Approval: 'Approval',
    AuditLog: 'AuditLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "vendor" | "vendorCategory" | "vendorDocument" | "cSI_Material" | "priceEntry" | "rFQ" | "rFQSubmission" | "evaluation" | "contract" | "variationOrder" | "iPC" | "document" | "approval" | "auditLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VendorCategory: {
        payload: Prisma.$VendorCategoryPayload<ExtArgs>
        fields: Prisma.VendorCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>
          }
          findFirst: {
            args: Prisma.VendorCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>
          }
          findMany: {
            args: Prisma.VendorCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>[]
          }
          create: {
            args: Prisma.VendorCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>
          }
          createMany: {
            args: Prisma.VendorCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>[]
          }
          delete: {
            args: Prisma.VendorCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>
          }
          update: {
            args: Prisma.VendorCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>
          }
          deleteMany: {
            args: Prisma.VendorCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>[]
          }
          upsert: {
            args: Prisma.VendorCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorCategoryPayload>
          }
          aggregate: {
            args: Prisma.VendorCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorCategory>
          }
          groupBy: {
            args: Prisma.VendorCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCategoryCountAggregateOutputType> | number
          }
        }
      }
      VendorDocument: {
        payload: Prisma.$VendorDocumentPayload<ExtArgs>
        fields: Prisma.VendorDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>
          }
          findFirst: {
            args: Prisma.VendorDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>
          }
          findMany: {
            args: Prisma.VendorDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>[]
          }
          create: {
            args: Prisma.VendorDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>
          }
          createMany: {
            args: Prisma.VendorDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>[]
          }
          delete: {
            args: Prisma.VendorDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>
          }
          update: {
            args: Prisma.VendorDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>
          }
          deleteMany: {
            args: Prisma.VendorDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>[]
          }
          upsert: {
            args: Prisma.VendorDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorDocumentPayload>
          }
          aggregate: {
            args: Prisma.VendorDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorDocument>
          }
          groupBy: {
            args: Prisma.VendorDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<VendorDocumentCountAggregateOutputType> | number
          }
        }
      }
      CSI_Material: {
        payload: Prisma.$CSI_MaterialPayload<ExtArgs>
        fields: Prisma.CSI_MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CSI_MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CSI_MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>
          }
          findFirst: {
            args: Prisma.CSI_MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CSI_MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>
          }
          findMany: {
            args: Prisma.CSI_MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>[]
          }
          create: {
            args: Prisma.CSI_MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>
          }
          createMany: {
            args: Prisma.CSI_MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CSI_MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>[]
          }
          delete: {
            args: Prisma.CSI_MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>
          }
          update: {
            args: Prisma.CSI_MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>
          }
          deleteMany: {
            args: Prisma.CSI_MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CSI_MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CSI_MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>[]
          }
          upsert: {
            args: Prisma.CSI_MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSI_MaterialPayload>
          }
          aggregate: {
            args: Prisma.CSI_MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCSI_Material>
          }
          groupBy: {
            args: Prisma.CSI_MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CSI_MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CSI_MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<CSI_MaterialCountAggregateOutputType> | number
          }
        }
      }
      PriceEntry: {
        payload: Prisma.$PriceEntryPayload<ExtArgs>
        fields: Prisma.PriceEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>
          }
          findFirst: {
            args: Prisma.PriceEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>
          }
          findMany: {
            args: Prisma.PriceEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>[]
          }
          create: {
            args: Prisma.PriceEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>
          }
          createMany: {
            args: Prisma.PriceEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>[]
          }
          delete: {
            args: Prisma.PriceEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>
          }
          update: {
            args: Prisma.PriceEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>
          }
          deleteMany: {
            args: Prisma.PriceEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>[]
          }
          upsert: {
            args: Prisma.PriceEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceEntryPayload>
          }
          aggregate: {
            args: Prisma.PriceEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceEntry>
          }
          groupBy: {
            args: Prisma.PriceEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PriceEntryCountAggregateOutputType> | number
          }
        }
      }
      RFQ: {
        payload: Prisma.$RFQPayload<ExtArgs>
        fields: Prisma.RFQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RFQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RFQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          findFirst: {
            args: Prisma.RFQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RFQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          findMany: {
            args: Prisma.RFQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>[]
          }
          create: {
            args: Prisma.RFQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          createMany: {
            args: Prisma.RFQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RFQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>[]
          }
          delete: {
            args: Prisma.RFQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          update: {
            args: Prisma.RFQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          deleteMany: {
            args: Prisma.RFQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RFQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RFQUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>[]
          }
          upsert: {
            args: Prisma.RFQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQPayload>
          }
          aggregate: {
            args: Prisma.RFQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRFQ>
          }
          groupBy: {
            args: Prisma.RFQGroupByArgs<ExtArgs>
            result: $Utils.Optional<RFQGroupByOutputType>[]
          }
          count: {
            args: Prisma.RFQCountArgs<ExtArgs>
            result: $Utils.Optional<RFQCountAggregateOutputType> | number
          }
        }
      }
      RFQSubmission: {
        payload: Prisma.$RFQSubmissionPayload<ExtArgs>
        fields: Prisma.RFQSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RFQSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RFQSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>
          }
          findFirst: {
            args: Prisma.RFQSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RFQSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>
          }
          findMany: {
            args: Prisma.RFQSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>[]
          }
          create: {
            args: Prisma.RFQSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>
          }
          createMany: {
            args: Prisma.RFQSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RFQSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>[]
          }
          delete: {
            args: Prisma.RFQSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>
          }
          update: {
            args: Prisma.RFQSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.RFQSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RFQSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RFQSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.RFQSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RFQSubmissionPayload>
          }
          aggregate: {
            args: Prisma.RFQSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRFQSubmission>
          }
          groupBy: {
            args: Prisma.RFQSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RFQSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RFQSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<RFQSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvaluationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      VariationOrder: {
        payload: Prisma.$VariationOrderPayload<ExtArgs>
        fields: Prisma.VariationOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariationOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariationOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>
          }
          findFirst: {
            args: Prisma.VariationOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariationOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>
          }
          findMany: {
            args: Prisma.VariationOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>[]
          }
          create: {
            args: Prisma.VariationOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>
          }
          createMany: {
            args: Prisma.VariationOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariationOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>[]
          }
          delete: {
            args: Prisma.VariationOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>
          }
          update: {
            args: Prisma.VariationOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>
          }
          deleteMany: {
            args: Prisma.VariationOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariationOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariationOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>[]
          }
          upsert: {
            args: Prisma.VariationOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationOrderPayload>
          }
          aggregate: {
            args: Prisma.VariationOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariationOrder>
          }
          groupBy: {
            args: Prisma.VariationOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariationOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariationOrderCountArgs<ExtArgs>
            result: $Utils.Optional<VariationOrderCountAggregateOutputType> | number
          }
        }
      }
      IPC: {
        payload: Prisma.$IPCPayload<ExtArgs>
        fields: Prisma.IPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IPCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IPCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>
          }
          findFirst: {
            args: Prisma.IPCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IPCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>
          }
          findMany: {
            args: Prisma.IPCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>[]
          }
          create: {
            args: Prisma.IPCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>
          }
          createMany: {
            args: Prisma.IPCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IPCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>[]
          }
          delete: {
            args: Prisma.IPCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>
          }
          update: {
            args: Prisma.IPCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>
          }
          deleteMany: {
            args: Prisma.IPCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IPCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IPCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>[]
          }
          upsert: {
            args: Prisma.IPCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IPCPayload>
          }
          aggregate: {
            args: Prisma.IPCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIPC>
          }
          groupBy: {
            args: Prisma.IPCGroupByArgs<ExtArgs>
            result: $Utils.Optional<IPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.IPCCountArgs<ExtArgs>
            result: $Utils.Optional<IPCCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Approval: {
        payload: Prisma.$ApprovalPayload<ExtArgs>
        fields: Prisma.ApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findFirst: {
            args: Prisma.ApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findMany: {
            args: Prisma.ApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          create: {
            args: Prisma.ApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          createMany: {
            args: Prisma.ApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          delete: {
            args: Prisma.ApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          update: {
            args: Prisma.ApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApprovalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          upsert: {
            args: Prisma.ApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          aggregate: {
            args: Prisma.ApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApproval>
          }
          groupBy: {
            args: Prisma.ApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    vendor?: VendorOmit
    vendorCategory?: VendorCategoryOmit
    vendorDocument?: VendorDocumentOmit
    cSI_Material?: CSI_MaterialOmit
    priceEntry?: PriceEntryOmit
    rFQ?: RFQOmit
    rFQSubmission?: RFQSubmissionOmit
    evaluation?: EvaluationOmit
    contract?: ContractOmit
    variationOrder?: VariationOrderOmit
    iPC?: IPCOmit
    document?: DocumentOmit
    approval?: ApprovalOmit
    auditLog?: AuditLogOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    approvals: number
    auditLogs: number
    documents: number
    evaluations: number
    ipcs: number
    notifications: number
    rfqs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvals?: boolean | UserCountOutputTypeCountApprovalsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    evaluations?: boolean | UserCountOutputTypeCountEvaluationsArgs
    ipcs?: boolean | UserCountOutputTypeCountIpcsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    rfqs?: boolean | UserCountOutputTypeCountRfqsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IPCWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRfqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    materials: number
    contracts: number
    priceEntries: number
    submissions: number
    users: number
    documents: number
    categories: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | VendorCountOutputTypeCountMaterialsArgs
    contracts?: boolean | VendorCountOutputTypeCountContractsArgs
    priceEntries?: boolean | VendorCountOutputTypeCountPriceEntriesArgs
    submissions?: boolean | VendorCountOutputTypeCountSubmissionsArgs
    users?: boolean | VendorCountOutputTypeCountUsersArgs
    documents?: boolean | VendorCountOutputTypeCountDocumentsArgs
    categories?: boolean | VendorCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CSI_MaterialWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPriceEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceEntryWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQSubmissionWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorDocumentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorCategoryWhereInput
  }


  /**
   * Count Type VendorCategoryCountOutputType
   */

  export type VendorCategoryCountOutputType = {
    vendors: number
  }

  export type VendorCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendors?: boolean | VendorCategoryCountOutputTypeCountVendorsArgs
  }

  // Custom InputTypes
  /**
   * VendorCategoryCountOutputType without action
   */
  export type VendorCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategoryCountOutputType
     */
    select?: VendorCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCategoryCountOutputType without action
   */
  export type VendorCategoryCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }


  /**
   * Count Type CSI_MaterialCountOutputType
   */

  export type CSI_MaterialCountOutputType = {
    priceEntries: number
  }

  export type CSI_MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceEntries?: boolean | CSI_MaterialCountOutputTypeCountPriceEntriesArgs
  }

  // Custom InputTypes
  /**
   * CSI_MaterialCountOutputType without action
   */
  export type CSI_MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_MaterialCountOutputType
     */
    select?: CSI_MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CSI_MaterialCountOutputType without action
   */
  export type CSI_MaterialCountOutputTypeCountPriceEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceEntryWhereInput
  }


  /**
   * Count Type RFQCountOutputType
   */

  export type RFQCountOutputType = {
    contracts: number
    submissions: number
    attachments: number
  }

  export type RFQCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | RFQCountOutputTypeCountContractsArgs
    submissions?: boolean | RFQCountOutputTypeCountSubmissionsArgs
    attachments?: boolean | RFQCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * RFQCountOutputType without action
   */
  export type RFQCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQCountOutputType
     */
    select?: RFQCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RFQCountOutputType without action
   */
  export type RFQCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * RFQCountOutputType without action
   */
  export type RFQCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQSubmissionWhereInput
  }

  /**
   * RFQCountOutputType without action
   */
  export type RFQCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type RFQSubmissionCountOutputType
   */

  export type RFQSubmissionCountOutputType = {
    evaluations: number
  }

  export type RFQSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | RFQSubmissionCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * RFQSubmissionCountOutputType without action
   */
  export type RFQSubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmissionCountOutputType
     */
    select?: RFQSubmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RFQSubmissionCountOutputType without action
   */
  export type RFQSubmissionCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    documents: number
    ipcs: number
    variationOrders: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | ContractCountOutputTypeCountDocumentsArgs
    ipcs?: boolean | ContractCountOutputTypeCountIpcsArgs
    variationOrders?: boolean | ContractCountOutputTypeCountVariationOrdersArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountIpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IPCWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountVariationOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationOrderWhereInput
  }


  /**
   * Count Type IPCCountOutputType
   */

  export type IPCCountOutputType = {
    attachments: number
  }

  export type IPCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | IPCCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * IPCCountOutputType without action
   */
  export type IPCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPCCountOutputType
     */
    select?: IPCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IPCCountOutputType without action
   */
  export type IPCCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    rfqAttachments: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfqAttachments?: boolean | DocumentCountOutputTypeCountRfqAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountRfqAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    vendorId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    vendorId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    email: string | null
    password: string | null
    roleId: number | null
    vendorId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    accessCode: string | null
    status: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    email: string | null
    password: string | null
    roleId: number | null
    vendorId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    accessCode: string | null
    status: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    email: number
    password: number
    roleId: number
    vendorId: number
    isActive: number
    createdAt: number
    updatedAt: number
    accessCode: number
    status: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
    vendorId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
    vendorId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    email?: true
    password?: true
    roleId?: true
    vendorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    accessCode?: true
    status?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    email?: true
    password?: true
    roleId?: true
    vendorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    accessCode?: true
    status?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    email?: true
    password?: true
    roleId?: true
    vendorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    accessCode?: true
    status?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    uuid: string
    name: string | null
    email: string
    password: string
    roleId: number
    vendorId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    accessCode: string | null
    status: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roleId?: boolean
    vendorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessCode?: boolean
    status?: boolean
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    evaluations?: boolean | User$evaluationsArgs<ExtArgs>
    ipcs?: boolean | User$ipcsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    rfqs?: boolean | User$rfqsArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roleId?: boolean
    vendorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessCode?: boolean
    status?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roleId?: boolean
    vendorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessCode?: boolean
    status?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    roleId?: boolean
    vendorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessCode?: boolean
    status?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "name" | "email" | "password" | "roleId" | "vendorId" | "isActive" | "createdAt" | "updatedAt" | "accessCode" | "status", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    evaluations?: boolean | User$evaluationsArgs<ExtArgs>
    ipcs?: boolean | User$ipcsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    rfqs?: boolean | User$rfqsArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      ipcs: Prisma.$IPCPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      rfqs: Prisma.$RFQPayload<ExtArgs>[]
      role: Prisma.$RolePayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      name: string | null
      email: string
      password: string
      roleId: number
      vendorId: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      accessCode: string | null
      status: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approvals<T extends User$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluations<T extends User$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, User$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ipcs<T extends User$ipcsArgs<ExtArgs> = {}>(args?: Subset<T, User$ipcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rfqs<T extends User$rfqsArgs<ExtArgs> = {}>(args?: Subset<T, User$rfqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends User$vendorArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly uuid: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly vendorId: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly accessCode: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.approvals
   */
  export type User$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.evaluations
   */
  export type User$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * User.ipcs
   */
  export type User$ipcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    where?: IPCWhereInput
    orderBy?: IPCOrderByWithRelationInput | IPCOrderByWithRelationInput[]
    cursor?: IPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IPCScalarFieldEnum | IPCScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.rfqs
   */
  export type User$rfqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    where?: RFQWhereInput
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    cursor?: RFQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * User.vendor
   */
  export type User$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    desc: string | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    desc: string | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    desc: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    desc?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    desc?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    desc?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    desc: string | null
    name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc?: boolean
    name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    desc?: boolean
    name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "desc" | "name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      desc: string | null
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly desc: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    status: $Enums.VendorStatus | null
    address: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    status: $Enums.VendorStatus | null
    address: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    code: number
    name: number
    contactName: number
    contactEmail: number
    contactPhone: number
    status: number
    address: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    status?: true
    address?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    status?: true
    address?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contactName?: true
    contactEmail?: true
    contactPhone?: true
    status?: true
    address?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: number
    code: string | null
    name: string
    contactName: string | null
    contactEmail: string | null
    contactPhone: string | null
    status: $Enums.VendorStatus
    address: string | null
    country: string | null
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    status?: boolean
    address?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materials?: boolean | Vendor$materialsArgs<ExtArgs>
    contracts?: boolean | Vendor$contractsArgs<ExtArgs>
    priceEntries?: boolean | Vendor$priceEntriesArgs<ExtArgs>
    submissions?: boolean | Vendor$submissionsArgs<ExtArgs>
    users?: boolean | Vendor$usersArgs<ExtArgs>
    documents?: boolean | Vendor$documentsArgs<ExtArgs>
    categories?: boolean | Vendor$categoriesArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    status?: boolean
    address?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    status?: boolean
    address?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    contactName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    status?: boolean
    address?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "contactName" | "contactEmail" | "contactPhone" | "status" | "address" | "country" | "createdAt" | "updatedAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | Vendor$materialsArgs<ExtArgs>
    contracts?: boolean | Vendor$contractsArgs<ExtArgs>
    priceEntries?: boolean | Vendor$priceEntriesArgs<ExtArgs>
    submissions?: boolean | Vendor$submissionsArgs<ExtArgs>
    users?: boolean | Vendor$usersArgs<ExtArgs>
    documents?: boolean | Vendor$documentsArgs<ExtArgs>
    categories?: boolean | Vendor$categoriesArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      materials: Prisma.$CSI_MaterialPayload<ExtArgs>[]
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      priceEntries: Prisma.$PriceEntryPayload<ExtArgs>[]
      submissions: Prisma.$RFQSubmissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      documents: Prisma.$VendorDocumentPayload<ExtArgs>[]
      categories: Prisma.$VendorCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string | null
      name: string
      contactName: string | null
      contactEmail: string | null
      contactPhone: string | null
      status: $Enums.VendorStatus
      address: string | null
      country: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materials<T extends Vendor$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contracts<T extends Vendor$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceEntries<T extends Vendor$priceEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$priceEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends Vendor$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Vendor$usersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Vendor$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Vendor$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'Int'>
    readonly code: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly contactName: FieldRef<"Vendor", 'String'>
    readonly contactEmail: FieldRef<"Vendor", 'String'>
    readonly contactPhone: FieldRef<"Vendor", 'String'>
    readonly status: FieldRef<"Vendor", 'VendorStatus'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly country: FieldRef<"Vendor", 'String'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.materials
   */
  export type Vendor$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    where?: CSI_MaterialWhereInput
    orderBy?: CSI_MaterialOrderByWithRelationInput | CSI_MaterialOrderByWithRelationInput[]
    cursor?: CSI_MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CSI_MaterialScalarFieldEnum | CSI_MaterialScalarFieldEnum[]
  }

  /**
   * Vendor.contracts
   */
  export type Vendor$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Vendor.priceEntries
   */
  export type Vendor$priceEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    where?: PriceEntryWhereInput
    orderBy?: PriceEntryOrderByWithRelationInput | PriceEntryOrderByWithRelationInput[]
    cursor?: PriceEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceEntryScalarFieldEnum | PriceEntryScalarFieldEnum[]
  }

  /**
   * Vendor.submissions
   */
  export type Vendor$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    where?: RFQSubmissionWhereInput
    orderBy?: RFQSubmissionOrderByWithRelationInput | RFQSubmissionOrderByWithRelationInput[]
    cursor?: RFQSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFQSubmissionScalarFieldEnum | RFQSubmissionScalarFieldEnum[]
  }

  /**
   * Vendor.users
   */
  export type Vendor$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Vendor.documents
   */
  export type Vendor$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    where?: VendorDocumentWhereInput
    orderBy?: VendorDocumentOrderByWithRelationInput | VendorDocumentOrderByWithRelationInput[]
    cursor?: VendorDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorDocumentScalarFieldEnum | VendorDocumentScalarFieldEnum[]
  }

  /**
   * Vendor.categories
   */
  export type Vendor$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    where?: VendorCategoryWhereInput
    orderBy?: VendorCategoryOrderByWithRelationInput | VendorCategoryOrderByWithRelationInput[]
    cursor?: VendorCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorCategoryScalarFieldEnum | VendorCategoryScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VendorCategory
   */

  export type AggregateVendorCategory = {
    _count: VendorCategoryCountAggregateOutputType | null
    _avg: VendorCategoryAvgAggregateOutputType | null
    _sum: VendorCategorySumAggregateOutputType | null
    _min: VendorCategoryMinAggregateOutputType | null
    _max: VendorCategoryMaxAggregateOutputType | null
  }

  export type VendorCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorCategorySumAggregateOutputType = {
    id: number | null
  }

  export type VendorCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorCategoryAvgAggregateInputType = {
    id?: true
  }

  export type VendorCategorySumAggregateInputType = {
    id?: true
  }

  export type VendorCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorCategory to aggregate.
     */
    where?: VendorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorCategories to fetch.
     */
    orderBy?: VendorCategoryOrderByWithRelationInput | VendorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorCategories
    **/
    _count?: true | VendorCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorCategoryMaxAggregateInputType
  }

  export type GetVendorCategoryAggregateType<T extends VendorCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorCategory[P]>
      : GetScalarType<T[P], AggregateVendorCategory[P]>
  }




  export type VendorCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorCategoryWhereInput
    orderBy?: VendorCategoryOrderByWithAggregationInput | VendorCategoryOrderByWithAggregationInput[]
    by: VendorCategoryScalarFieldEnum[] | VendorCategoryScalarFieldEnum
    having?: VendorCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCategoryCountAggregateInputType | true
    _avg?: VendorCategoryAvgAggregateInputType
    _sum?: VendorCategorySumAggregateInputType
    _min?: VendorCategoryMinAggregateInputType
    _max?: VendorCategoryMaxAggregateInputType
  }

  export type VendorCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: VendorCategoryCountAggregateOutputType | null
    _avg: VendorCategoryAvgAggregateOutputType | null
    _sum: VendorCategorySumAggregateOutputType | null
    _min: VendorCategoryMinAggregateOutputType | null
    _max: VendorCategoryMaxAggregateOutputType | null
  }

  type GetVendorCategoryGroupByPayload<T extends VendorCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], VendorCategoryGroupByOutputType[P]>
        }
      >
    >


  export type VendorCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendors?: boolean | VendorCategory$vendorsArgs<ExtArgs>
    _count?: boolean | VendorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorCategory"]>

  export type VendorCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendorCategory"]>

  export type VendorCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendorCategory"]>

  export type VendorCategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["vendorCategory"]>
  export type VendorCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendors?: boolean | VendorCategory$vendorsArgs<ExtArgs>
    _count?: boolean | VendorCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VendorCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorCategory"
    objects: {
      vendors: Prisma.$VendorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorCategory"]>
    composites: {}
  }

  type VendorCategoryGetPayload<S extends boolean | null | undefined | VendorCategoryDefaultArgs> = $Result.GetResult<Prisma.$VendorCategoryPayload, S>

  type VendorCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCategoryCountAggregateInputType | true
    }

  export interface VendorCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorCategory'], meta: { name: 'VendorCategory' } }
    /**
     * Find zero or one VendorCategory that matches the filter.
     * @param {VendorCategoryFindUniqueArgs} args - Arguments to find a VendorCategory
     * @example
     * // Get one VendorCategory
     * const vendorCategory = await prisma.vendorCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorCategoryFindUniqueArgs>(args: SelectSubset<T, VendorCategoryFindUniqueArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorCategoryFindUniqueOrThrowArgs} args - Arguments to find a VendorCategory
     * @example
     * // Get one VendorCategory
     * const vendorCategory = await prisma.vendorCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCategoryFindFirstArgs} args - Arguments to find a VendorCategory
     * @example
     * // Get one VendorCategory
     * const vendorCategory = await prisma.vendorCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorCategoryFindFirstArgs>(args?: SelectSubset<T, VendorCategoryFindFirstArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCategoryFindFirstOrThrowArgs} args - Arguments to find a VendorCategory
     * @example
     * // Get one VendorCategory
     * const vendorCategory = await prisma.vendorCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorCategories
     * const vendorCategories = await prisma.vendorCategory.findMany()
     * 
     * // Get first 10 VendorCategories
     * const vendorCategories = await prisma.vendorCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorCategoryWithIdOnly = await prisma.vendorCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorCategoryFindManyArgs>(args?: SelectSubset<T, VendorCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorCategory.
     * @param {VendorCategoryCreateArgs} args - Arguments to create a VendorCategory.
     * @example
     * // Create one VendorCategory
     * const VendorCategory = await prisma.vendorCategory.create({
     *   data: {
     *     // ... data to create a VendorCategory
     *   }
     * })
     * 
     */
    create<T extends VendorCategoryCreateArgs>(args: SelectSubset<T, VendorCategoryCreateArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorCategories.
     * @param {VendorCategoryCreateManyArgs} args - Arguments to create many VendorCategories.
     * @example
     * // Create many VendorCategories
     * const vendorCategory = await prisma.vendorCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCategoryCreateManyArgs>(args?: SelectSubset<T, VendorCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorCategories and returns the data saved in the database.
     * @param {VendorCategoryCreateManyAndReturnArgs} args - Arguments to create many VendorCategories.
     * @example
     * // Create many VendorCategories
     * const vendorCategory = await prisma.vendorCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorCategories and only return the `id`
     * const vendorCategoryWithIdOnly = await prisma.vendorCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorCategory.
     * @param {VendorCategoryDeleteArgs} args - Arguments to delete one VendorCategory.
     * @example
     * // Delete one VendorCategory
     * const VendorCategory = await prisma.vendorCategory.delete({
     *   where: {
     *     // ... filter to delete one VendorCategory
     *   }
     * })
     * 
     */
    delete<T extends VendorCategoryDeleteArgs>(args: SelectSubset<T, VendorCategoryDeleteArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorCategory.
     * @param {VendorCategoryUpdateArgs} args - Arguments to update one VendorCategory.
     * @example
     * // Update one VendorCategory
     * const vendorCategory = await prisma.vendorCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorCategoryUpdateArgs>(args: SelectSubset<T, VendorCategoryUpdateArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorCategories.
     * @param {VendorCategoryDeleteManyArgs} args - Arguments to filter VendorCategories to delete.
     * @example
     * // Delete a few VendorCategories
     * const { count } = await prisma.vendorCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorCategoryDeleteManyArgs>(args?: SelectSubset<T, VendorCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorCategories
     * const vendorCategory = await prisma.vendorCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorCategoryUpdateManyArgs>(args: SelectSubset<T, VendorCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorCategories and returns the data updated in the database.
     * @param {VendorCategoryUpdateManyAndReturnArgs} args - Arguments to update many VendorCategories.
     * @example
     * // Update many VendorCategories
     * const vendorCategory = await prisma.vendorCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorCategories and only return the `id`
     * const vendorCategoryWithIdOnly = await prisma.vendorCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorCategory.
     * @param {VendorCategoryUpsertArgs} args - Arguments to update or create a VendorCategory.
     * @example
     * // Update or create a VendorCategory
     * const vendorCategory = await prisma.vendorCategory.upsert({
     *   create: {
     *     // ... data to create a VendorCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorCategory we want to update
     *   }
     * })
     */
    upsert<T extends VendorCategoryUpsertArgs>(args: SelectSubset<T, VendorCategoryUpsertArgs<ExtArgs>>): Prisma__VendorCategoryClient<$Result.GetResult<Prisma.$VendorCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCategoryCountArgs} args - Arguments to filter VendorCategories to count.
     * @example
     * // Count the number of VendorCategories
     * const count = await prisma.vendorCategory.count({
     *   where: {
     *     // ... the filter for the VendorCategories we want to count
     *   }
     * })
    **/
    count<T extends VendorCategoryCountArgs>(
      args?: Subset<T, VendorCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorCategoryAggregateArgs>(args: Subset<T, VendorCategoryAggregateArgs>): Prisma.PrismaPromise<GetVendorCategoryAggregateType<T>>

    /**
     * Group by VendorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorCategoryGroupByArgs['orderBy'] }
        : { orderBy?: VendorCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorCategory model
   */
  readonly fields: VendorCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendors<T extends VendorCategory$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, VendorCategory$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorCategory model
   */
  interface VendorCategoryFieldRefs {
    readonly id: FieldRef<"VendorCategory", 'Int'>
    readonly name: FieldRef<"VendorCategory", 'String'>
    readonly createdAt: FieldRef<"VendorCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorCategory findUnique
   */
  export type VendorCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VendorCategory to fetch.
     */
    where: VendorCategoryWhereUniqueInput
  }

  /**
   * VendorCategory findUniqueOrThrow
   */
  export type VendorCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VendorCategory to fetch.
     */
    where: VendorCategoryWhereUniqueInput
  }

  /**
   * VendorCategory findFirst
   */
  export type VendorCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VendorCategory to fetch.
     */
    where?: VendorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorCategories to fetch.
     */
    orderBy?: VendorCategoryOrderByWithRelationInput | VendorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorCategories.
     */
    cursor?: VendorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorCategories.
     */
    distinct?: VendorCategoryScalarFieldEnum | VendorCategoryScalarFieldEnum[]
  }

  /**
   * VendorCategory findFirstOrThrow
   */
  export type VendorCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VendorCategory to fetch.
     */
    where?: VendorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorCategories to fetch.
     */
    orderBy?: VendorCategoryOrderByWithRelationInput | VendorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorCategories.
     */
    cursor?: VendorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorCategories.
     */
    distinct?: VendorCategoryScalarFieldEnum | VendorCategoryScalarFieldEnum[]
  }

  /**
   * VendorCategory findMany
   */
  export type VendorCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VendorCategories to fetch.
     */
    where?: VendorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorCategories to fetch.
     */
    orderBy?: VendorCategoryOrderByWithRelationInput | VendorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorCategories.
     */
    cursor?: VendorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorCategories.
     */
    skip?: number
    distinct?: VendorCategoryScalarFieldEnum | VendorCategoryScalarFieldEnum[]
  }

  /**
   * VendorCategory create
   */
  export type VendorCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorCategory.
     */
    data: XOR<VendorCategoryCreateInput, VendorCategoryUncheckedCreateInput>
  }

  /**
   * VendorCategory createMany
   */
  export type VendorCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorCategories.
     */
    data: VendorCategoryCreateManyInput | VendorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorCategory createManyAndReturn
   */
  export type VendorCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many VendorCategories.
     */
    data: VendorCategoryCreateManyInput | VendorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorCategory update
   */
  export type VendorCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorCategory.
     */
    data: XOR<VendorCategoryUpdateInput, VendorCategoryUncheckedUpdateInput>
    /**
     * Choose, which VendorCategory to update.
     */
    where: VendorCategoryWhereUniqueInput
  }

  /**
   * VendorCategory updateMany
   */
  export type VendorCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorCategories.
     */
    data: XOR<VendorCategoryUpdateManyMutationInput, VendorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which VendorCategories to update
     */
    where?: VendorCategoryWhereInput
    /**
     * Limit how many VendorCategories to update.
     */
    limit?: number
  }

  /**
   * VendorCategory updateManyAndReturn
   */
  export type VendorCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * The data used to update VendorCategories.
     */
    data: XOR<VendorCategoryUpdateManyMutationInput, VendorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which VendorCategories to update
     */
    where?: VendorCategoryWhereInput
    /**
     * Limit how many VendorCategories to update.
     */
    limit?: number
  }

  /**
   * VendorCategory upsert
   */
  export type VendorCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorCategory to update in case it exists.
     */
    where: VendorCategoryWhereUniqueInput
    /**
     * In case the VendorCategory found by the `where` argument doesn't exist, create a new VendorCategory with this data.
     */
    create: XOR<VendorCategoryCreateInput, VendorCategoryUncheckedCreateInput>
    /**
     * In case the VendorCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorCategoryUpdateInput, VendorCategoryUncheckedUpdateInput>
  }

  /**
   * VendorCategory delete
   */
  export type VendorCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
    /**
     * Filter which VendorCategory to delete.
     */
    where: VendorCategoryWhereUniqueInput
  }

  /**
   * VendorCategory deleteMany
   */
  export type VendorCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorCategories to delete
     */
    where?: VendorCategoryWhereInput
    /**
     * Limit how many VendorCategories to delete.
     */
    limit?: number
  }

  /**
   * VendorCategory.vendors
   */
  export type VendorCategory$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * VendorCategory without action
   */
  export type VendorCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCategory
     */
    select?: VendorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorCategory
     */
    omit?: VendorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorCategoryInclude<ExtArgs> | null
  }


  /**
   * Model VendorDocument
   */

  export type AggregateVendorDocument = {
    _count: VendorDocumentCountAggregateOutputType | null
    _avg: VendorDocumentAvgAggregateOutputType | null
    _sum: VendorDocumentSumAggregateOutputType | null
    _min: VendorDocumentMinAggregateOutputType | null
    _max: VendorDocumentMaxAggregateOutputType | null
  }

  export type VendorDocumentAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorDocumentSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorDocumentMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    docType: string | null
    url: string | null
    fileName: string | null
    expiryDate: Date | null
    uploadedAt: Date | null
  }

  export type VendorDocumentMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    docType: string | null
    url: string | null
    fileName: string | null
    expiryDate: Date | null
    uploadedAt: Date | null
  }

  export type VendorDocumentCountAggregateOutputType = {
    id: number
    vendorId: number
    docType: number
    url: number
    fileName: number
    expiryDate: number
    uploadedAt: number
    _all: number
  }


  export type VendorDocumentAvgAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorDocumentSumAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorDocumentMinAggregateInputType = {
    id?: true
    vendorId?: true
    docType?: true
    url?: true
    fileName?: true
    expiryDate?: true
    uploadedAt?: true
  }

  export type VendorDocumentMaxAggregateInputType = {
    id?: true
    vendorId?: true
    docType?: true
    url?: true
    fileName?: true
    expiryDate?: true
    uploadedAt?: true
  }

  export type VendorDocumentCountAggregateInputType = {
    id?: true
    vendorId?: true
    docType?: true
    url?: true
    fileName?: true
    expiryDate?: true
    uploadedAt?: true
    _all?: true
  }

  export type VendorDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorDocument to aggregate.
     */
    where?: VendorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDocuments to fetch.
     */
    orderBy?: VendorDocumentOrderByWithRelationInput | VendorDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorDocuments
    **/
    _count?: true | VendorDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorDocumentMaxAggregateInputType
  }

  export type GetVendorDocumentAggregateType<T extends VendorDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorDocument[P]>
      : GetScalarType<T[P], AggregateVendorDocument[P]>
  }




  export type VendorDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorDocumentWhereInput
    orderBy?: VendorDocumentOrderByWithAggregationInput | VendorDocumentOrderByWithAggregationInput[]
    by: VendorDocumentScalarFieldEnum[] | VendorDocumentScalarFieldEnum
    having?: VendorDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorDocumentCountAggregateInputType | true
    _avg?: VendorDocumentAvgAggregateInputType
    _sum?: VendorDocumentSumAggregateInputType
    _min?: VendorDocumentMinAggregateInputType
    _max?: VendorDocumentMaxAggregateInputType
  }

  export type VendorDocumentGroupByOutputType = {
    id: number
    vendorId: number
    docType: string
    url: string
    fileName: string
    expiryDate: Date | null
    uploadedAt: Date
    _count: VendorDocumentCountAggregateOutputType | null
    _avg: VendorDocumentAvgAggregateOutputType | null
    _sum: VendorDocumentSumAggregateOutputType | null
    _min: VendorDocumentMinAggregateOutputType | null
    _max: VendorDocumentMaxAggregateOutputType | null
  }

  type GetVendorDocumentGroupByPayload<T extends VendorDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], VendorDocumentGroupByOutputType[P]>
        }
      >
    >


  export type VendorDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    docType?: boolean
    url?: boolean
    fileName?: boolean
    expiryDate?: boolean
    uploadedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorDocument"]>

  export type VendorDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    docType?: boolean
    url?: boolean
    fileName?: boolean
    expiryDate?: boolean
    uploadedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorDocument"]>

  export type VendorDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    docType?: boolean
    url?: boolean
    fileName?: boolean
    expiryDate?: boolean
    uploadedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorDocument"]>

  export type VendorDocumentSelectScalar = {
    id?: boolean
    vendorId?: boolean
    docType?: boolean
    url?: boolean
    fileName?: boolean
    expiryDate?: boolean
    uploadedAt?: boolean
  }

  export type VendorDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "docType" | "url" | "fileName" | "expiryDate" | "uploadedAt", ExtArgs["result"]["vendorDocument"]>
  export type VendorDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorDocument"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorId: number
      docType: string
      url: string
      fileName: string
      expiryDate: Date | null
      uploadedAt: Date
    }, ExtArgs["result"]["vendorDocument"]>
    composites: {}
  }

  type VendorDocumentGetPayload<S extends boolean | null | undefined | VendorDocumentDefaultArgs> = $Result.GetResult<Prisma.$VendorDocumentPayload, S>

  type VendorDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorDocumentCountAggregateInputType | true
    }

  export interface VendorDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorDocument'], meta: { name: 'VendorDocument' } }
    /**
     * Find zero or one VendorDocument that matches the filter.
     * @param {VendorDocumentFindUniqueArgs} args - Arguments to find a VendorDocument
     * @example
     * // Get one VendorDocument
     * const vendorDocument = await prisma.vendorDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorDocumentFindUniqueArgs>(args: SelectSubset<T, VendorDocumentFindUniqueArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorDocumentFindUniqueOrThrowArgs} args - Arguments to find a VendorDocument
     * @example
     * // Get one VendorDocument
     * const vendorDocument = await prisma.vendorDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDocumentFindFirstArgs} args - Arguments to find a VendorDocument
     * @example
     * // Get one VendorDocument
     * const vendorDocument = await prisma.vendorDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorDocumentFindFirstArgs>(args?: SelectSubset<T, VendorDocumentFindFirstArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDocumentFindFirstOrThrowArgs} args - Arguments to find a VendorDocument
     * @example
     * // Get one VendorDocument
     * const vendorDocument = await prisma.vendorDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorDocuments
     * const vendorDocuments = await prisma.vendorDocument.findMany()
     * 
     * // Get first 10 VendorDocuments
     * const vendorDocuments = await prisma.vendorDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorDocumentWithIdOnly = await prisma.vendorDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorDocumentFindManyArgs>(args?: SelectSubset<T, VendorDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorDocument.
     * @param {VendorDocumentCreateArgs} args - Arguments to create a VendorDocument.
     * @example
     * // Create one VendorDocument
     * const VendorDocument = await prisma.vendorDocument.create({
     *   data: {
     *     // ... data to create a VendorDocument
     *   }
     * })
     * 
     */
    create<T extends VendorDocumentCreateArgs>(args: SelectSubset<T, VendorDocumentCreateArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorDocuments.
     * @param {VendorDocumentCreateManyArgs} args - Arguments to create many VendorDocuments.
     * @example
     * // Create many VendorDocuments
     * const vendorDocument = await prisma.vendorDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorDocumentCreateManyArgs>(args?: SelectSubset<T, VendorDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorDocuments and returns the data saved in the database.
     * @param {VendorDocumentCreateManyAndReturnArgs} args - Arguments to create many VendorDocuments.
     * @example
     * // Create many VendorDocuments
     * const vendorDocument = await prisma.vendorDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorDocuments and only return the `id`
     * const vendorDocumentWithIdOnly = await prisma.vendorDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorDocument.
     * @param {VendorDocumentDeleteArgs} args - Arguments to delete one VendorDocument.
     * @example
     * // Delete one VendorDocument
     * const VendorDocument = await prisma.vendorDocument.delete({
     *   where: {
     *     // ... filter to delete one VendorDocument
     *   }
     * })
     * 
     */
    delete<T extends VendorDocumentDeleteArgs>(args: SelectSubset<T, VendorDocumentDeleteArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorDocument.
     * @param {VendorDocumentUpdateArgs} args - Arguments to update one VendorDocument.
     * @example
     * // Update one VendorDocument
     * const vendorDocument = await prisma.vendorDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorDocumentUpdateArgs>(args: SelectSubset<T, VendorDocumentUpdateArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorDocuments.
     * @param {VendorDocumentDeleteManyArgs} args - Arguments to filter VendorDocuments to delete.
     * @example
     * // Delete a few VendorDocuments
     * const { count } = await prisma.vendorDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDocumentDeleteManyArgs>(args?: SelectSubset<T, VendorDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorDocuments
     * const vendorDocument = await prisma.vendorDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorDocumentUpdateManyArgs>(args: SelectSubset<T, VendorDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorDocuments and returns the data updated in the database.
     * @param {VendorDocumentUpdateManyAndReturnArgs} args - Arguments to update many VendorDocuments.
     * @example
     * // Update many VendorDocuments
     * const vendorDocument = await prisma.vendorDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorDocuments and only return the `id`
     * const vendorDocumentWithIdOnly = await prisma.vendorDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorDocument.
     * @param {VendorDocumentUpsertArgs} args - Arguments to update or create a VendorDocument.
     * @example
     * // Update or create a VendorDocument
     * const vendorDocument = await prisma.vendorDocument.upsert({
     *   create: {
     *     // ... data to create a VendorDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorDocument we want to update
     *   }
     * })
     */
    upsert<T extends VendorDocumentUpsertArgs>(args: SelectSubset<T, VendorDocumentUpsertArgs<ExtArgs>>): Prisma__VendorDocumentClient<$Result.GetResult<Prisma.$VendorDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDocumentCountArgs} args - Arguments to filter VendorDocuments to count.
     * @example
     * // Count the number of VendorDocuments
     * const count = await prisma.vendorDocument.count({
     *   where: {
     *     // ... the filter for the VendorDocuments we want to count
     *   }
     * })
    **/
    count<T extends VendorDocumentCountArgs>(
      args?: Subset<T, VendorDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorDocumentAggregateArgs>(args: Subset<T, VendorDocumentAggregateArgs>): Prisma.PrismaPromise<GetVendorDocumentAggregateType<T>>

    /**
     * Group by VendorDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorDocumentGroupByArgs['orderBy'] }
        : { orderBy?: VendorDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorDocument model
   */
  readonly fields: VendorDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorDocument model
   */
  interface VendorDocumentFieldRefs {
    readonly id: FieldRef<"VendorDocument", 'Int'>
    readonly vendorId: FieldRef<"VendorDocument", 'Int'>
    readonly docType: FieldRef<"VendorDocument", 'String'>
    readonly url: FieldRef<"VendorDocument", 'String'>
    readonly fileName: FieldRef<"VendorDocument", 'String'>
    readonly expiryDate: FieldRef<"VendorDocument", 'DateTime'>
    readonly uploadedAt: FieldRef<"VendorDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorDocument findUnique
   */
  export type VendorDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorDocument to fetch.
     */
    where: VendorDocumentWhereUniqueInput
  }

  /**
   * VendorDocument findUniqueOrThrow
   */
  export type VendorDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorDocument to fetch.
     */
    where: VendorDocumentWhereUniqueInput
  }

  /**
   * VendorDocument findFirst
   */
  export type VendorDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorDocument to fetch.
     */
    where?: VendorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDocuments to fetch.
     */
    orderBy?: VendorDocumentOrderByWithRelationInput | VendorDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorDocuments.
     */
    cursor?: VendorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorDocuments.
     */
    distinct?: VendorDocumentScalarFieldEnum | VendorDocumentScalarFieldEnum[]
  }

  /**
   * VendorDocument findFirstOrThrow
   */
  export type VendorDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorDocument to fetch.
     */
    where?: VendorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDocuments to fetch.
     */
    orderBy?: VendorDocumentOrderByWithRelationInput | VendorDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorDocuments.
     */
    cursor?: VendorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorDocuments.
     */
    distinct?: VendorDocumentScalarFieldEnum | VendorDocumentScalarFieldEnum[]
  }

  /**
   * VendorDocument findMany
   */
  export type VendorDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which VendorDocuments to fetch.
     */
    where?: VendorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorDocuments to fetch.
     */
    orderBy?: VendorDocumentOrderByWithRelationInput | VendorDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorDocuments.
     */
    cursor?: VendorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorDocuments.
     */
    skip?: number
    distinct?: VendorDocumentScalarFieldEnum | VendorDocumentScalarFieldEnum[]
  }

  /**
   * VendorDocument create
   */
  export type VendorDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorDocument.
     */
    data: XOR<VendorDocumentCreateInput, VendorDocumentUncheckedCreateInput>
  }

  /**
   * VendorDocument createMany
   */
  export type VendorDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorDocuments.
     */
    data: VendorDocumentCreateManyInput | VendorDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorDocument createManyAndReturn
   */
  export type VendorDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many VendorDocuments.
     */
    data: VendorDocumentCreateManyInput | VendorDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorDocument update
   */
  export type VendorDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorDocument.
     */
    data: XOR<VendorDocumentUpdateInput, VendorDocumentUncheckedUpdateInput>
    /**
     * Choose, which VendorDocument to update.
     */
    where: VendorDocumentWhereUniqueInput
  }

  /**
   * VendorDocument updateMany
   */
  export type VendorDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorDocuments.
     */
    data: XOR<VendorDocumentUpdateManyMutationInput, VendorDocumentUncheckedUpdateManyInput>
    /**
     * Filter which VendorDocuments to update
     */
    where?: VendorDocumentWhereInput
    /**
     * Limit how many VendorDocuments to update.
     */
    limit?: number
  }

  /**
   * VendorDocument updateManyAndReturn
   */
  export type VendorDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * The data used to update VendorDocuments.
     */
    data: XOR<VendorDocumentUpdateManyMutationInput, VendorDocumentUncheckedUpdateManyInput>
    /**
     * Filter which VendorDocuments to update
     */
    where?: VendorDocumentWhereInput
    /**
     * Limit how many VendorDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorDocument upsert
   */
  export type VendorDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorDocument to update in case it exists.
     */
    where: VendorDocumentWhereUniqueInput
    /**
     * In case the VendorDocument found by the `where` argument doesn't exist, create a new VendorDocument with this data.
     */
    create: XOR<VendorDocumentCreateInput, VendorDocumentUncheckedCreateInput>
    /**
     * In case the VendorDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorDocumentUpdateInput, VendorDocumentUncheckedUpdateInput>
  }

  /**
   * VendorDocument delete
   */
  export type VendorDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
    /**
     * Filter which VendorDocument to delete.
     */
    where: VendorDocumentWhereUniqueInput
  }

  /**
   * VendorDocument deleteMany
   */
  export type VendorDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorDocuments to delete
     */
    where?: VendorDocumentWhereInput
    /**
     * Limit how many VendorDocuments to delete.
     */
    limit?: number
  }

  /**
   * VendorDocument without action
   */
  export type VendorDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorDocument
     */
    select?: VendorDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorDocument
     */
    omit?: VendorDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorDocumentInclude<ExtArgs> | null
  }


  /**
   * Model CSI_Material
   */

  export type AggregateCSI_Material = {
    _count: CSI_MaterialCountAggregateOutputType | null
    _avg: CSI_MaterialAvgAggregateOutputType | null
    _sum: CSI_MaterialSumAggregateOutputType | null
    _min: CSI_MaterialMinAggregateOutputType | null
    _max: CSI_MaterialMaxAggregateOutputType | null
  }

  export type CSI_MaterialAvgAggregateOutputType = {
    id: number | null
    defaultVendorId: number | null
  }

  export type CSI_MaterialSumAggregateOutputType = {
    id: number | null
    defaultVendorId: number | null
  }

  export type CSI_MaterialMinAggregateOutputType = {
    id: number | null
    csiCode: string | null
    name: string | null
    unit: string | null
    defaultVendorId: number | null
  }

  export type CSI_MaterialMaxAggregateOutputType = {
    id: number | null
    csiCode: string | null
    name: string | null
    unit: string | null
    defaultVendorId: number | null
  }

  export type CSI_MaterialCountAggregateOutputType = {
    id: number
    csiCode: number
    name: number
    unit: number
    defaultVendorId: number
    _all: number
  }


  export type CSI_MaterialAvgAggregateInputType = {
    id?: true
    defaultVendorId?: true
  }

  export type CSI_MaterialSumAggregateInputType = {
    id?: true
    defaultVendorId?: true
  }

  export type CSI_MaterialMinAggregateInputType = {
    id?: true
    csiCode?: true
    name?: true
    unit?: true
    defaultVendorId?: true
  }

  export type CSI_MaterialMaxAggregateInputType = {
    id?: true
    csiCode?: true
    name?: true
    unit?: true
    defaultVendorId?: true
  }

  export type CSI_MaterialCountAggregateInputType = {
    id?: true
    csiCode?: true
    name?: true
    unit?: true
    defaultVendorId?: true
    _all?: true
  }

  export type CSI_MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CSI_Material to aggregate.
     */
    where?: CSI_MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSI_Materials to fetch.
     */
    orderBy?: CSI_MaterialOrderByWithRelationInput | CSI_MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CSI_MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSI_Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSI_Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CSI_Materials
    **/
    _count?: true | CSI_MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CSI_MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CSI_MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CSI_MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CSI_MaterialMaxAggregateInputType
  }

  export type GetCSI_MaterialAggregateType<T extends CSI_MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateCSI_Material]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCSI_Material[P]>
      : GetScalarType<T[P], AggregateCSI_Material[P]>
  }




  export type CSI_MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CSI_MaterialWhereInput
    orderBy?: CSI_MaterialOrderByWithAggregationInput | CSI_MaterialOrderByWithAggregationInput[]
    by: CSI_MaterialScalarFieldEnum[] | CSI_MaterialScalarFieldEnum
    having?: CSI_MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CSI_MaterialCountAggregateInputType | true
    _avg?: CSI_MaterialAvgAggregateInputType
    _sum?: CSI_MaterialSumAggregateInputType
    _min?: CSI_MaterialMinAggregateInputType
    _max?: CSI_MaterialMaxAggregateInputType
  }

  export type CSI_MaterialGroupByOutputType = {
    id: number
    csiCode: string | null
    name: string
    unit: string | null
    defaultVendorId: number | null
    _count: CSI_MaterialCountAggregateOutputType | null
    _avg: CSI_MaterialAvgAggregateOutputType | null
    _sum: CSI_MaterialSumAggregateOutputType | null
    _min: CSI_MaterialMinAggregateOutputType | null
    _max: CSI_MaterialMaxAggregateOutputType | null
  }

  type GetCSI_MaterialGroupByPayload<T extends CSI_MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CSI_MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CSI_MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CSI_MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], CSI_MaterialGroupByOutputType[P]>
        }
      >
    >


  export type CSI_MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    csiCode?: boolean
    name?: boolean
    unit?: boolean
    defaultVendorId?: boolean
    defaultVendor?: boolean | CSI_Material$defaultVendorArgs<ExtArgs>
    priceEntries?: boolean | CSI_Material$priceEntriesArgs<ExtArgs>
    _count?: boolean | CSI_MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cSI_Material"]>

  export type CSI_MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    csiCode?: boolean
    name?: boolean
    unit?: boolean
    defaultVendorId?: boolean
    defaultVendor?: boolean | CSI_Material$defaultVendorArgs<ExtArgs>
  }, ExtArgs["result"]["cSI_Material"]>

  export type CSI_MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    csiCode?: boolean
    name?: boolean
    unit?: boolean
    defaultVendorId?: boolean
    defaultVendor?: boolean | CSI_Material$defaultVendorArgs<ExtArgs>
  }, ExtArgs["result"]["cSI_Material"]>

  export type CSI_MaterialSelectScalar = {
    id?: boolean
    csiCode?: boolean
    name?: boolean
    unit?: boolean
    defaultVendorId?: boolean
  }

  export type CSI_MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "csiCode" | "name" | "unit" | "defaultVendorId", ExtArgs["result"]["cSI_Material"]>
  export type CSI_MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultVendor?: boolean | CSI_Material$defaultVendorArgs<ExtArgs>
    priceEntries?: boolean | CSI_Material$priceEntriesArgs<ExtArgs>
    _count?: boolean | CSI_MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CSI_MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultVendor?: boolean | CSI_Material$defaultVendorArgs<ExtArgs>
  }
  export type CSI_MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultVendor?: boolean | CSI_Material$defaultVendorArgs<ExtArgs>
  }

  export type $CSI_MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CSI_Material"
    objects: {
      defaultVendor: Prisma.$VendorPayload<ExtArgs> | null
      priceEntries: Prisma.$PriceEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      csiCode: string | null
      name: string
      unit: string | null
      defaultVendorId: number | null
    }, ExtArgs["result"]["cSI_Material"]>
    composites: {}
  }

  type CSI_MaterialGetPayload<S extends boolean | null | undefined | CSI_MaterialDefaultArgs> = $Result.GetResult<Prisma.$CSI_MaterialPayload, S>

  type CSI_MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CSI_MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CSI_MaterialCountAggregateInputType | true
    }

  export interface CSI_MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CSI_Material'], meta: { name: 'CSI_Material' } }
    /**
     * Find zero or one CSI_Material that matches the filter.
     * @param {CSI_MaterialFindUniqueArgs} args - Arguments to find a CSI_Material
     * @example
     * // Get one CSI_Material
     * const cSI_Material = await prisma.cSI_Material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CSI_MaterialFindUniqueArgs>(args: SelectSubset<T, CSI_MaterialFindUniqueArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CSI_Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CSI_MaterialFindUniqueOrThrowArgs} args - Arguments to find a CSI_Material
     * @example
     * // Get one CSI_Material
     * const cSI_Material = await prisma.cSI_Material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CSI_MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, CSI_MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CSI_Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSI_MaterialFindFirstArgs} args - Arguments to find a CSI_Material
     * @example
     * // Get one CSI_Material
     * const cSI_Material = await prisma.cSI_Material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CSI_MaterialFindFirstArgs>(args?: SelectSubset<T, CSI_MaterialFindFirstArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CSI_Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSI_MaterialFindFirstOrThrowArgs} args - Arguments to find a CSI_Material
     * @example
     * // Get one CSI_Material
     * const cSI_Material = await prisma.cSI_Material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CSI_MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, CSI_MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CSI_Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSI_MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CSI_Materials
     * const cSI_Materials = await prisma.cSI_Material.findMany()
     * 
     * // Get first 10 CSI_Materials
     * const cSI_Materials = await prisma.cSI_Material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cSI_MaterialWithIdOnly = await prisma.cSI_Material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CSI_MaterialFindManyArgs>(args?: SelectSubset<T, CSI_MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CSI_Material.
     * @param {CSI_MaterialCreateArgs} args - Arguments to create a CSI_Material.
     * @example
     * // Create one CSI_Material
     * const CSI_Material = await prisma.cSI_Material.create({
     *   data: {
     *     // ... data to create a CSI_Material
     *   }
     * })
     * 
     */
    create<T extends CSI_MaterialCreateArgs>(args: SelectSubset<T, CSI_MaterialCreateArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CSI_Materials.
     * @param {CSI_MaterialCreateManyArgs} args - Arguments to create many CSI_Materials.
     * @example
     * // Create many CSI_Materials
     * const cSI_Material = await prisma.cSI_Material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CSI_MaterialCreateManyArgs>(args?: SelectSubset<T, CSI_MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CSI_Materials and returns the data saved in the database.
     * @param {CSI_MaterialCreateManyAndReturnArgs} args - Arguments to create many CSI_Materials.
     * @example
     * // Create many CSI_Materials
     * const cSI_Material = await prisma.cSI_Material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CSI_Materials and only return the `id`
     * const cSI_MaterialWithIdOnly = await prisma.cSI_Material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CSI_MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, CSI_MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CSI_Material.
     * @param {CSI_MaterialDeleteArgs} args - Arguments to delete one CSI_Material.
     * @example
     * // Delete one CSI_Material
     * const CSI_Material = await prisma.cSI_Material.delete({
     *   where: {
     *     // ... filter to delete one CSI_Material
     *   }
     * })
     * 
     */
    delete<T extends CSI_MaterialDeleteArgs>(args: SelectSubset<T, CSI_MaterialDeleteArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CSI_Material.
     * @param {CSI_MaterialUpdateArgs} args - Arguments to update one CSI_Material.
     * @example
     * // Update one CSI_Material
     * const cSI_Material = await prisma.cSI_Material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CSI_MaterialUpdateArgs>(args: SelectSubset<T, CSI_MaterialUpdateArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CSI_Materials.
     * @param {CSI_MaterialDeleteManyArgs} args - Arguments to filter CSI_Materials to delete.
     * @example
     * // Delete a few CSI_Materials
     * const { count } = await prisma.cSI_Material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CSI_MaterialDeleteManyArgs>(args?: SelectSubset<T, CSI_MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CSI_Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSI_MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CSI_Materials
     * const cSI_Material = await prisma.cSI_Material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CSI_MaterialUpdateManyArgs>(args: SelectSubset<T, CSI_MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CSI_Materials and returns the data updated in the database.
     * @param {CSI_MaterialUpdateManyAndReturnArgs} args - Arguments to update many CSI_Materials.
     * @example
     * // Update many CSI_Materials
     * const cSI_Material = await prisma.cSI_Material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CSI_Materials and only return the `id`
     * const cSI_MaterialWithIdOnly = await prisma.cSI_Material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CSI_MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, CSI_MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CSI_Material.
     * @param {CSI_MaterialUpsertArgs} args - Arguments to update or create a CSI_Material.
     * @example
     * // Update or create a CSI_Material
     * const cSI_Material = await prisma.cSI_Material.upsert({
     *   create: {
     *     // ... data to create a CSI_Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CSI_Material we want to update
     *   }
     * })
     */
    upsert<T extends CSI_MaterialUpsertArgs>(args: SelectSubset<T, CSI_MaterialUpsertArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CSI_Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSI_MaterialCountArgs} args - Arguments to filter CSI_Materials to count.
     * @example
     * // Count the number of CSI_Materials
     * const count = await prisma.cSI_Material.count({
     *   where: {
     *     // ... the filter for the CSI_Materials we want to count
     *   }
     * })
    **/
    count<T extends CSI_MaterialCountArgs>(
      args?: Subset<T, CSI_MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CSI_MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CSI_Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSI_MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CSI_MaterialAggregateArgs>(args: Subset<T, CSI_MaterialAggregateArgs>): Prisma.PrismaPromise<GetCSI_MaterialAggregateType<T>>

    /**
     * Group by CSI_Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSI_MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CSI_MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CSI_MaterialGroupByArgs['orderBy'] }
        : { orderBy?: CSI_MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CSI_MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCSI_MaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CSI_Material model
   */
  readonly fields: CSI_MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CSI_Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CSI_MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaultVendor<T extends CSI_Material$defaultVendorArgs<ExtArgs> = {}>(args?: Subset<T, CSI_Material$defaultVendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    priceEntries<T extends CSI_Material$priceEntriesArgs<ExtArgs> = {}>(args?: Subset<T, CSI_Material$priceEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CSI_Material model
   */
  interface CSI_MaterialFieldRefs {
    readonly id: FieldRef<"CSI_Material", 'Int'>
    readonly csiCode: FieldRef<"CSI_Material", 'String'>
    readonly name: FieldRef<"CSI_Material", 'String'>
    readonly unit: FieldRef<"CSI_Material", 'String'>
    readonly defaultVendorId: FieldRef<"CSI_Material", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CSI_Material findUnique
   */
  export type CSI_MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * Filter, which CSI_Material to fetch.
     */
    where: CSI_MaterialWhereUniqueInput
  }

  /**
   * CSI_Material findUniqueOrThrow
   */
  export type CSI_MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * Filter, which CSI_Material to fetch.
     */
    where: CSI_MaterialWhereUniqueInput
  }

  /**
   * CSI_Material findFirst
   */
  export type CSI_MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * Filter, which CSI_Material to fetch.
     */
    where?: CSI_MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSI_Materials to fetch.
     */
    orderBy?: CSI_MaterialOrderByWithRelationInput | CSI_MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CSI_Materials.
     */
    cursor?: CSI_MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSI_Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSI_Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CSI_Materials.
     */
    distinct?: CSI_MaterialScalarFieldEnum | CSI_MaterialScalarFieldEnum[]
  }

  /**
   * CSI_Material findFirstOrThrow
   */
  export type CSI_MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * Filter, which CSI_Material to fetch.
     */
    where?: CSI_MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSI_Materials to fetch.
     */
    orderBy?: CSI_MaterialOrderByWithRelationInput | CSI_MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CSI_Materials.
     */
    cursor?: CSI_MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSI_Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSI_Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CSI_Materials.
     */
    distinct?: CSI_MaterialScalarFieldEnum | CSI_MaterialScalarFieldEnum[]
  }

  /**
   * CSI_Material findMany
   */
  export type CSI_MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * Filter, which CSI_Materials to fetch.
     */
    where?: CSI_MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSI_Materials to fetch.
     */
    orderBy?: CSI_MaterialOrderByWithRelationInput | CSI_MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CSI_Materials.
     */
    cursor?: CSI_MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSI_Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSI_Materials.
     */
    skip?: number
    distinct?: CSI_MaterialScalarFieldEnum | CSI_MaterialScalarFieldEnum[]
  }

  /**
   * CSI_Material create
   */
  export type CSI_MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a CSI_Material.
     */
    data: XOR<CSI_MaterialCreateInput, CSI_MaterialUncheckedCreateInput>
  }

  /**
   * CSI_Material createMany
   */
  export type CSI_MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CSI_Materials.
     */
    data: CSI_MaterialCreateManyInput | CSI_MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CSI_Material createManyAndReturn
   */
  export type CSI_MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many CSI_Materials.
     */
    data: CSI_MaterialCreateManyInput | CSI_MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CSI_Material update
   */
  export type CSI_MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a CSI_Material.
     */
    data: XOR<CSI_MaterialUpdateInput, CSI_MaterialUncheckedUpdateInput>
    /**
     * Choose, which CSI_Material to update.
     */
    where: CSI_MaterialWhereUniqueInput
  }

  /**
   * CSI_Material updateMany
   */
  export type CSI_MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CSI_Materials.
     */
    data: XOR<CSI_MaterialUpdateManyMutationInput, CSI_MaterialUncheckedUpdateManyInput>
    /**
     * Filter which CSI_Materials to update
     */
    where?: CSI_MaterialWhereInput
    /**
     * Limit how many CSI_Materials to update.
     */
    limit?: number
  }

  /**
   * CSI_Material updateManyAndReturn
   */
  export type CSI_MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * The data used to update CSI_Materials.
     */
    data: XOR<CSI_MaterialUpdateManyMutationInput, CSI_MaterialUncheckedUpdateManyInput>
    /**
     * Filter which CSI_Materials to update
     */
    where?: CSI_MaterialWhereInput
    /**
     * Limit how many CSI_Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CSI_Material upsert
   */
  export type CSI_MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the CSI_Material to update in case it exists.
     */
    where: CSI_MaterialWhereUniqueInput
    /**
     * In case the CSI_Material found by the `where` argument doesn't exist, create a new CSI_Material with this data.
     */
    create: XOR<CSI_MaterialCreateInput, CSI_MaterialUncheckedCreateInput>
    /**
     * In case the CSI_Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CSI_MaterialUpdateInput, CSI_MaterialUncheckedUpdateInput>
  }

  /**
   * CSI_Material delete
   */
  export type CSI_MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
    /**
     * Filter which CSI_Material to delete.
     */
    where: CSI_MaterialWhereUniqueInput
  }

  /**
   * CSI_Material deleteMany
   */
  export type CSI_MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CSI_Materials to delete
     */
    where?: CSI_MaterialWhereInput
    /**
     * Limit how many CSI_Materials to delete.
     */
    limit?: number
  }

  /**
   * CSI_Material.defaultVendor
   */
  export type CSI_Material$defaultVendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * CSI_Material.priceEntries
   */
  export type CSI_Material$priceEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    where?: PriceEntryWhereInput
    orderBy?: PriceEntryOrderByWithRelationInput | PriceEntryOrderByWithRelationInput[]
    cursor?: PriceEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceEntryScalarFieldEnum | PriceEntryScalarFieldEnum[]
  }

  /**
   * CSI_Material without action
   */
  export type CSI_MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI_Material
     */
    select?: CSI_MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI_Material
     */
    omit?: CSI_MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSI_MaterialInclude<ExtArgs> | null
  }


  /**
   * Model PriceEntry
   */

  export type AggregatePriceEntry = {
    _count: PriceEntryCountAggregateOutputType | null
    _avg: PriceEntryAvgAggregateOutputType | null
    _sum: PriceEntrySumAggregateOutputType | null
    _min: PriceEntryMinAggregateOutputType | null
    _max: PriceEntryMaxAggregateOutputType | null
  }

  export type PriceEntryAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    vendorId: number | null
    unitPrice: number | null
  }

  export type PriceEntrySumAggregateOutputType = {
    id: number | null
    materialId: number | null
    vendorId: number | null
    unitPrice: number | null
  }

  export type PriceEntryMinAggregateOutputType = {
    id: number | null
    materialId: number | null
    vendorId: number | null
    unitPrice: number | null
    currency: string | null
    createdAt: Date | null
    effectiveDate: Date | null
    expiryDate: Date | null
    updatedAt: Date | null
  }

  export type PriceEntryMaxAggregateOutputType = {
    id: number | null
    materialId: number | null
    vendorId: number | null
    unitPrice: number | null
    currency: string | null
    createdAt: Date | null
    effectiveDate: Date | null
    expiryDate: Date | null
    updatedAt: Date | null
  }

  export type PriceEntryCountAggregateOutputType = {
    id: number
    materialId: number
    vendorId: number
    unitPrice: number
    currency: number
    createdAt: number
    effectiveDate: number
    expiryDate: number
    updatedAt: number
    _all: number
  }


  export type PriceEntryAvgAggregateInputType = {
    id?: true
    materialId?: true
    vendorId?: true
    unitPrice?: true
  }

  export type PriceEntrySumAggregateInputType = {
    id?: true
    materialId?: true
    vendorId?: true
    unitPrice?: true
  }

  export type PriceEntryMinAggregateInputType = {
    id?: true
    materialId?: true
    vendorId?: true
    unitPrice?: true
    currency?: true
    createdAt?: true
    effectiveDate?: true
    expiryDate?: true
    updatedAt?: true
  }

  export type PriceEntryMaxAggregateInputType = {
    id?: true
    materialId?: true
    vendorId?: true
    unitPrice?: true
    currency?: true
    createdAt?: true
    effectiveDate?: true
    expiryDate?: true
    updatedAt?: true
  }

  export type PriceEntryCountAggregateInputType = {
    id?: true
    materialId?: true
    vendorId?: true
    unitPrice?: true
    currency?: true
    createdAt?: true
    effectiveDate?: true
    expiryDate?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceEntry to aggregate.
     */
    where?: PriceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceEntries to fetch.
     */
    orderBy?: PriceEntryOrderByWithRelationInput | PriceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceEntries
    **/
    _count?: true | PriceEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceEntryMaxAggregateInputType
  }

  export type GetPriceEntryAggregateType<T extends PriceEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceEntry[P]>
      : GetScalarType<T[P], AggregatePriceEntry[P]>
  }




  export type PriceEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceEntryWhereInput
    orderBy?: PriceEntryOrderByWithAggregationInput | PriceEntryOrderByWithAggregationInput[]
    by: PriceEntryScalarFieldEnum[] | PriceEntryScalarFieldEnum
    having?: PriceEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceEntryCountAggregateInputType | true
    _avg?: PriceEntryAvgAggregateInputType
    _sum?: PriceEntrySumAggregateInputType
    _min?: PriceEntryMinAggregateInputType
    _max?: PriceEntryMaxAggregateInputType
  }

  export type PriceEntryGroupByOutputType = {
    id: number
    materialId: number
    vendorId: number
    unitPrice: number
    currency: string
    createdAt: Date
    effectiveDate: Date
    expiryDate: Date | null
    updatedAt: Date
    _count: PriceEntryCountAggregateOutputType | null
    _avg: PriceEntryAvgAggregateOutputType | null
    _sum: PriceEntrySumAggregateOutputType | null
    _min: PriceEntryMinAggregateOutputType | null
    _max: PriceEntryMaxAggregateOutputType | null
  }

  type GetPriceEntryGroupByPayload<T extends PriceEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceEntryGroupByOutputType[P]>
        }
      >
    >


  export type PriceEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    vendorId?: boolean
    unitPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    effectiveDate?: boolean
    expiryDate?: boolean
    updatedAt?: boolean
    material?: boolean | CSI_MaterialDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceEntry"]>

  export type PriceEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    vendorId?: boolean
    unitPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    effectiveDate?: boolean
    expiryDate?: boolean
    updatedAt?: boolean
    material?: boolean | CSI_MaterialDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceEntry"]>

  export type PriceEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    vendorId?: boolean
    unitPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    effectiveDate?: boolean
    expiryDate?: boolean
    updatedAt?: boolean
    material?: boolean | CSI_MaterialDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceEntry"]>

  export type PriceEntrySelectScalar = {
    id?: boolean
    materialId?: boolean
    vendorId?: boolean
    unitPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    effectiveDate?: boolean
    expiryDate?: boolean
    updatedAt?: boolean
  }

  export type PriceEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "vendorId" | "unitPrice" | "currency" | "createdAt" | "effectiveDate" | "expiryDate" | "updatedAt", ExtArgs["result"]["priceEntry"]>
  export type PriceEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | CSI_MaterialDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type PriceEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | CSI_MaterialDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type PriceEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | CSI_MaterialDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $PriceEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceEntry"
    objects: {
      material: Prisma.$CSI_MaterialPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialId: number
      vendorId: number
      unitPrice: number
      currency: string
      createdAt: Date
      effectiveDate: Date
      expiryDate: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["priceEntry"]>
    composites: {}
  }

  type PriceEntryGetPayload<S extends boolean | null | undefined | PriceEntryDefaultArgs> = $Result.GetResult<Prisma.$PriceEntryPayload, S>

  type PriceEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceEntryCountAggregateInputType | true
    }

  export interface PriceEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceEntry'], meta: { name: 'PriceEntry' } }
    /**
     * Find zero or one PriceEntry that matches the filter.
     * @param {PriceEntryFindUniqueArgs} args - Arguments to find a PriceEntry
     * @example
     * // Get one PriceEntry
     * const priceEntry = await prisma.priceEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceEntryFindUniqueArgs>(args: SelectSubset<T, PriceEntryFindUniqueArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceEntryFindUniqueOrThrowArgs} args - Arguments to find a PriceEntry
     * @example
     * // Get one PriceEntry
     * const priceEntry = await prisma.priceEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceEntryFindFirstArgs} args - Arguments to find a PriceEntry
     * @example
     * // Get one PriceEntry
     * const priceEntry = await prisma.priceEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceEntryFindFirstArgs>(args?: SelectSubset<T, PriceEntryFindFirstArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceEntryFindFirstOrThrowArgs} args - Arguments to find a PriceEntry
     * @example
     * // Get one PriceEntry
     * const priceEntry = await prisma.priceEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceEntries
     * const priceEntries = await prisma.priceEntry.findMany()
     * 
     * // Get first 10 PriceEntries
     * const priceEntries = await prisma.priceEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceEntryWithIdOnly = await prisma.priceEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceEntryFindManyArgs>(args?: SelectSubset<T, PriceEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceEntry.
     * @param {PriceEntryCreateArgs} args - Arguments to create a PriceEntry.
     * @example
     * // Create one PriceEntry
     * const PriceEntry = await prisma.priceEntry.create({
     *   data: {
     *     // ... data to create a PriceEntry
     *   }
     * })
     * 
     */
    create<T extends PriceEntryCreateArgs>(args: SelectSubset<T, PriceEntryCreateArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceEntries.
     * @param {PriceEntryCreateManyArgs} args - Arguments to create many PriceEntries.
     * @example
     * // Create many PriceEntries
     * const priceEntry = await prisma.priceEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceEntryCreateManyArgs>(args?: SelectSubset<T, PriceEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceEntries and returns the data saved in the database.
     * @param {PriceEntryCreateManyAndReturnArgs} args - Arguments to create many PriceEntries.
     * @example
     * // Create many PriceEntries
     * const priceEntry = await prisma.priceEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceEntries and only return the `id`
     * const priceEntryWithIdOnly = await prisma.priceEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceEntry.
     * @param {PriceEntryDeleteArgs} args - Arguments to delete one PriceEntry.
     * @example
     * // Delete one PriceEntry
     * const PriceEntry = await prisma.priceEntry.delete({
     *   where: {
     *     // ... filter to delete one PriceEntry
     *   }
     * })
     * 
     */
    delete<T extends PriceEntryDeleteArgs>(args: SelectSubset<T, PriceEntryDeleteArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceEntry.
     * @param {PriceEntryUpdateArgs} args - Arguments to update one PriceEntry.
     * @example
     * // Update one PriceEntry
     * const priceEntry = await prisma.priceEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceEntryUpdateArgs>(args: SelectSubset<T, PriceEntryUpdateArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceEntries.
     * @param {PriceEntryDeleteManyArgs} args - Arguments to filter PriceEntries to delete.
     * @example
     * // Delete a few PriceEntries
     * const { count } = await prisma.priceEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceEntryDeleteManyArgs>(args?: SelectSubset<T, PriceEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceEntries
     * const priceEntry = await prisma.priceEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceEntryUpdateManyArgs>(args: SelectSubset<T, PriceEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceEntries and returns the data updated in the database.
     * @param {PriceEntryUpdateManyAndReturnArgs} args - Arguments to update many PriceEntries.
     * @example
     * // Update many PriceEntries
     * const priceEntry = await prisma.priceEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceEntries and only return the `id`
     * const priceEntryWithIdOnly = await prisma.priceEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceEntry.
     * @param {PriceEntryUpsertArgs} args - Arguments to update or create a PriceEntry.
     * @example
     * // Update or create a PriceEntry
     * const priceEntry = await prisma.priceEntry.upsert({
     *   create: {
     *     // ... data to create a PriceEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceEntry we want to update
     *   }
     * })
     */
    upsert<T extends PriceEntryUpsertArgs>(args: SelectSubset<T, PriceEntryUpsertArgs<ExtArgs>>): Prisma__PriceEntryClient<$Result.GetResult<Prisma.$PriceEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceEntryCountArgs} args - Arguments to filter PriceEntries to count.
     * @example
     * // Count the number of PriceEntries
     * const count = await prisma.priceEntry.count({
     *   where: {
     *     // ... the filter for the PriceEntries we want to count
     *   }
     * })
    **/
    count<T extends PriceEntryCountArgs>(
      args?: Subset<T, PriceEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceEntryAggregateArgs>(args: Subset<T, PriceEntryAggregateArgs>): Prisma.PrismaPromise<GetPriceEntryAggregateType<T>>

    /**
     * Group by PriceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceEntryGroupByArgs['orderBy'] }
        : { orderBy?: PriceEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceEntry model
   */
  readonly fields: PriceEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends CSI_MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CSI_MaterialDefaultArgs<ExtArgs>>): Prisma__CSI_MaterialClient<$Result.GetResult<Prisma.$CSI_MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceEntry model
   */
  interface PriceEntryFieldRefs {
    readonly id: FieldRef<"PriceEntry", 'Int'>
    readonly materialId: FieldRef<"PriceEntry", 'Int'>
    readonly vendorId: FieldRef<"PriceEntry", 'Int'>
    readonly unitPrice: FieldRef<"PriceEntry", 'Float'>
    readonly currency: FieldRef<"PriceEntry", 'String'>
    readonly createdAt: FieldRef<"PriceEntry", 'DateTime'>
    readonly effectiveDate: FieldRef<"PriceEntry", 'DateTime'>
    readonly expiryDate: FieldRef<"PriceEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"PriceEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceEntry findUnique
   */
  export type PriceEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * Filter, which PriceEntry to fetch.
     */
    where: PriceEntryWhereUniqueInput
  }

  /**
   * PriceEntry findUniqueOrThrow
   */
  export type PriceEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * Filter, which PriceEntry to fetch.
     */
    where: PriceEntryWhereUniqueInput
  }

  /**
   * PriceEntry findFirst
   */
  export type PriceEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * Filter, which PriceEntry to fetch.
     */
    where?: PriceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceEntries to fetch.
     */
    orderBy?: PriceEntryOrderByWithRelationInput | PriceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceEntries.
     */
    cursor?: PriceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceEntries.
     */
    distinct?: PriceEntryScalarFieldEnum | PriceEntryScalarFieldEnum[]
  }

  /**
   * PriceEntry findFirstOrThrow
   */
  export type PriceEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * Filter, which PriceEntry to fetch.
     */
    where?: PriceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceEntries to fetch.
     */
    orderBy?: PriceEntryOrderByWithRelationInput | PriceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceEntries.
     */
    cursor?: PriceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceEntries.
     */
    distinct?: PriceEntryScalarFieldEnum | PriceEntryScalarFieldEnum[]
  }

  /**
   * PriceEntry findMany
   */
  export type PriceEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * Filter, which PriceEntries to fetch.
     */
    where?: PriceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceEntries to fetch.
     */
    orderBy?: PriceEntryOrderByWithRelationInput | PriceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceEntries.
     */
    cursor?: PriceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceEntries.
     */
    skip?: number
    distinct?: PriceEntryScalarFieldEnum | PriceEntryScalarFieldEnum[]
  }

  /**
   * PriceEntry create
   */
  export type PriceEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceEntry.
     */
    data: XOR<PriceEntryCreateInput, PriceEntryUncheckedCreateInput>
  }

  /**
   * PriceEntry createMany
   */
  export type PriceEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceEntries.
     */
    data: PriceEntryCreateManyInput | PriceEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceEntry createManyAndReturn
   */
  export type PriceEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * The data used to create many PriceEntries.
     */
    data: PriceEntryCreateManyInput | PriceEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceEntry update
   */
  export type PriceEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceEntry.
     */
    data: XOR<PriceEntryUpdateInput, PriceEntryUncheckedUpdateInput>
    /**
     * Choose, which PriceEntry to update.
     */
    where: PriceEntryWhereUniqueInput
  }

  /**
   * PriceEntry updateMany
   */
  export type PriceEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceEntries.
     */
    data: XOR<PriceEntryUpdateManyMutationInput, PriceEntryUncheckedUpdateManyInput>
    /**
     * Filter which PriceEntries to update
     */
    where?: PriceEntryWhereInput
    /**
     * Limit how many PriceEntries to update.
     */
    limit?: number
  }

  /**
   * PriceEntry updateManyAndReturn
   */
  export type PriceEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * The data used to update PriceEntries.
     */
    data: XOR<PriceEntryUpdateManyMutationInput, PriceEntryUncheckedUpdateManyInput>
    /**
     * Filter which PriceEntries to update
     */
    where?: PriceEntryWhereInput
    /**
     * Limit how many PriceEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceEntry upsert
   */
  export type PriceEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceEntry to update in case it exists.
     */
    where: PriceEntryWhereUniqueInput
    /**
     * In case the PriceEntry found by the `where` argument doesn't exist, create a new PriceEntry with this data.
     */
    create: XOR<PriceEntryCreateInput, PriceEntryUncheckedCreateInput>
    /**
     * In case the PriceEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceEntryUpdateInput, PriceEntryUncheckedUpdateInput>
  }

  /**
   * PriceEntry delete
   */
  export type PriceEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
    /**
     * Filter which PriceEntry to delete.
     */
    where: PriceEntryWhereUniqueInput
  }

  /**
   * PriceEntry deleteMany
   */
  export type PriceEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceEntries to delete
     */
    where?: PriceEntryWhereInput
    /**
     * Limit how many PriceEntries to delete.
     */
    limit?: number
  }

  /**
   * PriceEntry without action
   */
  export type PriceEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceEntry
     */
    select?: PriceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceEntry
     */
    omit?: PriceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceEntryInclude<ExtArgs> | null
  }


  /**
   * Model RFQ
   */

  export type AggregateRFQ = {
    _count: RFQCountAggregateOutputType | null
    _avg: RFQAvgAggregateOutputType | null
    _sum: RFQSumAggregateOutputType | null
    _min: RFQMinAggregateOutputType | null
    _max: RFQMaxAggregateOutputType | null
  }

  export type RFQAvgAggregateOutputType = {
    id: number | null
    estimatedUnitPrice: number | null
    createdById: number | null
  }

  export type RFQSumAggregateOutputType = {
    id: number | null
    estimatedUnitPrice: number | null
    createdById: number | null
  }

  export type RFQMinAggregateOutputType = {
    id: number | null
    rfqNumber: string | null
    projectName: string | null
    packageScope: string | null
    itemDesc: string | null
    csiCode: string | null
    estimatedUnitPrice: number | null
    requiredDate: Date | null
    targetSubmissionDate: Date | null
    currency: string | null
    createdById: number | null
    status: $Enums.RFQStatus | null
    createdAt: Date | null
    description: string | null
    dueDate: Date | null
    title: string | null
    updatedAt: Date | null
  }

  export type RFQMaxAggregateOutputType = {
    id: number | null
    rfqNumber: string | null
    projectName: string | null
    packageScope: string | null
    itemDesc: string | null
    csiCode: string | null
    estimatedUnitPrice: number | null
    requiredDate: Date | null
    targetSubmissionDate: Date | null
    currency: string | null
    createdById: number | null
    status: $Enums.RFQStatus | null
    createdAt: Date | null
    description: string | null
    dueDate: Date | null
    title: string | null
    updatedAt: Date | null
  }

  export type RFQCountAggregateOutputType = {
    id: number
    rfqNumber: number
    projectName: number
    packageScope: number
    itemDesc: number
    csiCode: number
    estimatedUnitPrice: number
    requiredDate: number
    targetSubmissionDate: number
    currency: number
    createdById: number
    status: number
    createdAt: number
    description: number
    dueDate: number
    title: number
    updatedAt: number
    _all: number
  }


  export type RFQAvgAggregateInputType = {
    id?: true
    estimatedUnitPrice?: true
    createdById?: true
  }

  export type RFQSumAggregateInputType = {
    id?: true
    estimatedUnitPrice?: true
    createdById?: true
  }

  export type RFQMinAggregateInputType = {
    id?: true
    rfqNumber?: true
    projectName?: true
    packageScope?: true
    itemDesc?: true
    csiCode?: true
    estimatedUnitPrice?: true
    requiredDate?: true
    targetSubmissionDate?: true
    currency?: true
    createdById?: true
    status?: true
    createdAt?: true
    description?: true
    dueDate?: true
    title?: true
    updatedAt?: true
  }

  export type RFQMaxAggregateInputType = {
    id?: true
    rfqNumber?: true
    projectName?: true
    packageScope?: true
    itemDesc?: true
    csiCode?: true
    estimatedUnitPrice?: true
    requiredDate?: true
    targetSubmissionDate?: true
    currency?: true
    createdById?: true
    status?: true
    createdAt?: true
    description?: true
    dueDate?: true
    title?: true
    updatedAt?: true
  }

  export type RFQCountAggregateInputType = {
    id?: true
    rfqNumber?: true
    projectName?: true
    packageScope?: true
    itemDesc?: true
    csiCode?: true
    estimatedUnitPrice?: true
    requiredDate?: true
    targetSubmissionDate?: true
    currency?: true
    createdById?: true
    status?: true
    createdAt?: true
    description?: true
    dueDate?: true
    title?: true
    updatedAt?: true
    _all?: true
  }

  export type RFQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQ to aggregate.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RFQS
    **/
    _count?: true | RFQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RFQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RFQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RFQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RFQMaxAggregateInputType
  }

  export type GetRFQAggregateType<T extends RFQAggregateArgs> = {
        [P in keyof T & keyof AggregateRFQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRFQ[P]>
      : GetScalarType<T[P], AggregateRFQ[P]>
  }




  export type RFQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQWhereInput
    orderBy?: RFQOrderByWithAggregationInput | RFQOrderByWithAggregationInput[]
    by: RFQScalarFieldEnum[] | RFQScalarFieldEnum
    having?: RFQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RFQCountAggregateInputType | true
    _avg?: RFQAvgAggregateInputType
    _sum?: RFQSumAggregateInputType
    _min?: RFQMinAggregateInputType
    _max?: RFQMaxAggregateInputType
  }

  export type RFQGroupByOutputType = {
    id: number
    rfqNumber: string
    projectName: string
    packageScope: string | null
    itemDesc: string | null
    csiCode: string | null
    estimatedUnitPrice: number | null
    requiredDate: Date | null
    targetSubmissionDate: Date | null
    currency: string
    createdById: number
    status: $Enums.RFQStatus
    createdAt: Date
    description: string | null
    dueDate: Date | null
    title: string
    updatedAt: Date
    _count: RFQCountAggregateOutputType | null
    _avg: RFQAvgAggregateOutputType | null
    _sum: RFQSumAggregateOutputType | null
    _min: RFQMinAggregateOutputType | null
    _max: RFQMaxAggregateOutputType | null
  }

  type GetRFQGroupByPayload<T extends RFQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RFQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RFQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RFQGroupByOutputType[P]>
            : GetScalarType<T[P], RFQGroupByOutputType[P]>
        }
      >
    >


  export type RFQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqNumber?: boolean
    projectName?: boolean
    packageScope?: boolean
    itemDesc?: boolean
    csiCode?: boolean
    estimatedUnitPrice?: boolean
    requiredDate?: boolean
    targetSubmissionDate?: boolean
    currency?: boolean
    createdById?: boolean
    status?: boolean
    createdAt?: boolean
    description?: boolean
    dueDate?: boolean
    title?: boolean
    updatedAt?: boolean
    contracts?: boolean | RFQ$contractsArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    submissions?: boolean | RFQ$submissionsArgs<ExtArgs>
    attachments?: boolean | RFQ$attachmentsArgs<ExtArgs>
    _count?: boolean | RFQCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQ"]>

  export type RFQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqNumber?: boolean
    projectName?: boolean
    packageScope?: boolean
    itemDesc?: boolean
    csiCode?: boolean
    estimatedUnitPrice?: boolean
    requiredDate?: boolean
    targetSubmissionDate?: boolean
    currency?: boolean
    createdById?: boolean
    status?: boolean
    createdAt?: boolean
    description?: boolean
    dueDate?: boolean
    title?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQ"]>

  export type RFQSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqNumber?: boolean
    projectName?: boolean
    packageScope?: boolean
    itemDesc?: boolean
    csiCode?: boolean
    estimatedUnitPrice?: boolean
    requiredDate?: boolean
    targetSubmissionDate?: boolean
    currency?: boolean
    createdById?: boolean
    status?: boolean
    createdAt?: boolean
    description?: boolean
    dueDate?: boolean
    title?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQ"]>

  export type RFQSelectScalar = {
    id?: boolean
    rfqNumber?: boolean
    projectName?: boolean
    packageScope?: boolean
    itemDesc?: boolean
    csiCode?: boolean
    estimatedUnitPrice?: boolean
    requiredDate?: boolean
    targetSubmissionDate?: boolean
    currency?: boolean
    createdById?: boolean
    status?: boolean
    createdAt?: boolean
    description?: boolean
    dueDate?: boolean
    title?: boolean
    updatedAt?: boolean
  }

  export type RFQOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfqNumber" | "projectName" | "packageScope" | "itemDesc" | "csiCode" | "estimatedUnitPrice" | "requiredDate" | "targetSubmissionDate" | "currency" | "createdById" | "status" | "createdAt" | "description" | "dueDate" | "title" | "updatedAt", ExtArgs["result"]["rFQ"]>
  export type RFQInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | RFQ$contractsArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    submissions?: boolean | RFQ$submissionsArgs<ExtArgs>
    attachments?: boolean | RFQ$attachmentsArgs<ExtArgs>
    _count?: boolean | RFQCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RFQIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RFQIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RFQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RFQ"
    objects: {
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      submissions: Prisma.$RFQSubmissionPayload<ExtArgs>[]
      attachments: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfqNumber: string
      projectName: string
      packageScope: string | null
      itemDesc: string | null
      csiCode: string | null
      estimatedUnitPrice: number | null
      requiredDate: Date | null
      targetSubmissionDate: Date | null
      currency: string
      createdById: number
      status: $Enums.RFQStatus
      createdAt: Date
      description: string | null
      dueDate: Date | null
      title: string
      updatedAt: Date
    }, ExtArgs["result"]["rFQ"]>
    composites: {}
  }

  type RFQGetPayload<S extends boolean | null | undefined | RFQDefaultArgs> = $Result.GetResult<Prisma.$RFQPayload, S>

  type RFQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RFQFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RFQCountAggregateInputType | true
    }

  export interface RFQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RFQ'], meta: { name: 'RFQ' } }
    /**
     * Find zero or one RFQ that matches the filter.
     * @param {RFQFindUniqueArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RFQFindUniqueArgs>(args: SelectSubset<T, RFQFindUniqueArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RFQ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RFQFindUniqueOrThrowArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RFQFindUniqueOrThrowArgs>(args: SelectSubset<T, RFQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RFQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQFindFirstArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RFQFindFirstArgs>(args?: SelectSubset<T, RFQFindFirstArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RFQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQFindFirstOrThrowArgs} args - Arguments to find a RFQ
     * @example
     * // Get one RFQ
     * const rFQ = await prisma.rFQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RFQFindFirstOrThrowArgs>(args?: SelectSubset<T, RFQFindFirstOrThrowArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RFQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RFQS
     * const rFQS = await prisma.rFQ.findMany()
     * 
     * // Get first 10 RFQS
     * const rFQS = await prisma.rFQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rFQWithIdOnly = await prisma.rFQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RFQFindManyArgs>(args?: SelectSubset<T, RFQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RFQ.
     * @param {RFQCreateArgs} args - Arguments to create a RFQ.
     * @example
     * // Create one RFQ
     * const RFQ = await prisma.rFQ.create({
     *   data: {
     *     // ... data to create a RFQ
     *   }
     * })
     * 
     */
    create<T extends RFQCreateArgs>(args: SelectSubset<T, RFQCreateArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RFQS.
     * @param {RFQCreateManyArgs} args - Arguments to create many RFQS.
     * @example
     * // Create many RFQS
     * const rFQ = await prisma.rFQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RFQCreateManyArgs>(args?: SelectSubset<T, RFQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RFQS and returns the data saved in the database.
     * @param {RFQCreateManyAndReturnArgs} args - Arguments to create many RFQS.
     * @example
     * // Create many RFQS
     * const rFQ = await prisma.rFQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RFQS and only return the `id`
     * const rFQWithIdOnly = await prisma.rFQ.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RFQCreateManyAndReturnArgs>(args?: SelectSubset<T, RFQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RFQ.
     * @param {RFQDeleteArgs} args - Arguments to delete one RFQ.
     * @example
     * // Delete one RFQ
     * const RFQ = await prisma.rFQ.delete({
     *   where: {
     *     // ... filter to delete one RFQ
     *   }
     * })
     * 
     */
    delete<T extends RFQDeleteArgs>(args: SelectSubset<T, RFQDeleteArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RFQ.
     * @param {RFQUpdateArgs} args - Arguments to update one RFQ.
     * @example
     * // Update one RFQ
     * const rFQ = await prisma.rFQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RFQUpdateArgs>(args: SelectSubset<T, RFQUpdateArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RFQS.
     * @param {RFQDeleteManyArgs} args - Arguments to filter RFQS to delete.
     * @example
     * // Delete a few RFQS
     * const { count } = await prisma.rFQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RFQDeleteManyArgs>(args?: SelectSubset<T, RFQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RFQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RFQS
     * const rFQ = await prisma.rFQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RFQUpdateManyArgs>(args: SelectSubset<T, RFQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RFQS and returns the data updated in the database.
     * @param {RFQUpdateManyAndReturnArgs} args - Arguments to update many RFQS.
     * @example
     * // Update many RFQS
     * const rFQ = await prisma.rFQ.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RFQS and only return the `id`
     * const rFQWithIdOnly = await prisma.rFQ.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RFQUpdateManyAndReturnArgs>(args: SelectSubset<T, RFQUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RFQ.
     * @param {RFQUpsertArgs} args - Arguments to update or create a RFQ.
     * @example
     * // Update or create a RFQ
     * const rFQ = await prisma.rFQ.upsert({
     *   create: {
     *     // ... data to create a RFQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RFQ we want to update
     *   }
     * })
     */
    upsert<T extends RFQUpsertArgs>(args: SelectSubset<T, RFQUpsertArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RFQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQCountArgs} args - Arguments to filter RFQS to count.
     * @example
     * // Count the number of RFQS
     * const count = await prisma.rFQ.count({
     *   where: {
     *     // ... the filter for the RFQS we want to count
     *   }
     * })
    **/
    count<T extends RFQCountArgs>(
      args?: Subset<T, RFQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RFQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RFQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RFQAggregateArgs>(args: Subset<T, RFQAggregateArgs>): Prisma.PrismaPromise<GetRFQAggregateType<T>>

    /**
     * Group by RFQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RFQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RFQGroupByArgs['orderBy'] }
        : { orderBy?: RFQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RFQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRFQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RFQ model
   */
  readonly fields: RFQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RFQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RFQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contracts<T extends RFQ$contractsArgs<ExtArgs> = {}>(args?: Subset<T, RFQ$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submissions<T extends RFQ$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, RFQ$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends RFQ$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, RFQ$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RFQ model
   */
  interface RFQFieldRefs {
    readonly id: FieldRef<"RFQ", 'Int'>
    readonly rfqNumber: FieldRef<"RFQ", 'String'>
    readonly projectName: FieldRef<"RFQ", 'String'>
    readonly packageScope: FieldRef<"RFQ", 'String'>
    readonly itemDesc: FieldRef<"RFQ", 'String'>
    readonly csiCode: FieldRef<"RFQ", 'String'>
    readonly estimatedUnitPrice: FieldRef<"RFQ", 'Float'>
    readonly requiredDate: FieldRef<"RFQ", 'DateTime'>
    readonly targetSubmissionDate: FieldRef<"RFQ", 'DateTime'>
    readonly currency: FieldRef<"RFQ", 'String'>
    readonly createdById: FieldRef<"RFQ", 'Int'>
    readonly status: FieldRef<"RFQ", 'RFQStatus'>
    readonly createdAt: FieldRef<"RFQ", 'DateTime'>
    readonly description: FieldRef<"RFQ", 'String'>
    readonly dueDate: FieldRef<"RFQ", 'DateTime'>
    readonly title: FieldRef<"RFQ", 'String'>
    readonly updatedAt: FieldRef<"RFQ", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RFQ findUnique
   */
  export type RFQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ findUniqueOrThrow
   */
  export type RFQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ findFirst
   */
  export type RFQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQS.
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQS.
     */
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * RFQ findFirstOrThrow
   */
  export type RFQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQ to fetch.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQS.
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQS.
     */
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * RFQ findMany
   */
  export type RFQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter, which RFQS to fetch.
     */
    where?: RFQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQS to fetch.
     */
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RFQS.
     */
    cursor?: RFQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQS.
     */
    skip?: number
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * RFQ create
   */
  export type RFQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * The data needed to create a RFQ.
     */
    data: XOR<RFQCreateInput, RFQUncheckedCreateInput>
  }

  /**
   * RFQ createMany
   */
  export type RFQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RFQS.
     */
    data: RFQCreateManyInput | RFQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RFQ createManyAndReturn
   */
  export type RFQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * The data used to create many RFQS.
     */
    data: RFQCreateManyInput | RFQCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RFQ update
   */
  export type RFQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * The data needed to update a RFQ.
     */
    data: XOR<RFQUpdateInput, RFQUncheckedUpdateInput>
    /**
     * Choose, which RFQ to update.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ updateMany
   */
  export type RFQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RFQS.
     */
    data: XOR<RFQUpdateManyMutationInput, RFQUncheckedUpdateManyInput>
    /**
     * Filter which RFQS to update
     */
    where?: RFQWhereInput
    /**
     * Limit how many RFQS to update.
     */
    limit?: number
  }

  /**
   * RFQ updateManyAndReturn
   */
  export type RFQUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * The data used to update RFQS.
     */
    data: XOR<RFQUpdateManyMutationInput, RFQUncheckedUpdateManyInput>
    /**
     * Filter which RFQS to update
     */
    where?: RFQWhereInput
    /**
     * Limit how many RFQS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RFQ upsert
   */
  export type RFQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * The filter to search for the RFQ to update in case it exists.
     */
    where: RFQWhereUniqueInput
    /**
     * In case the RFQ found by the `where` argument doesn't exist, create a new RFQ with this data.
     */
    create: XOR<RFQCreateInput, RFQUncheckedCreateInput>
    /**
     * In case the RFQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RFQUpdateInput, RFQUncheckedUpdateInput>
  }

  /**
   * RFQ delete
   */
  export type RFQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    /**
     * Filter which RFQ to delete.
     */
    where: RFQWhereUniqueInput
  }

  /**
   * RFQ deleteMany
   */
  export type RFQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQS to delete
     */
    where?: RFQWhereInput
    /**
     * Limit how many RFQS to delete.
     */
    limit?: number
  }

  /**
   * RFQ.contracts
   */
  export type RFQ$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * RFQ.submissions
   */
  export type RFQ$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    where?: RFQSubmissionWhereInput
    orderBy?: RFQSubmissionOrderByWithRelationInput | RFQSubmissionOrderByWithRelationInput[]
    cursor?: RFQSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFQSubmissionScalarFieldEnum | RFQSubmissionScalarFieldEnum[]
  }

  /**
   * RFQ.attachments
   */
  export type RFQ$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * RFQ without action
   */
  export type RFQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
  }


  /**
   * Model RFQSubmission
   */

  export type AggregateRFQSubmission = {
    _count: RFQSubmissionCountAggregateOutputType | null
    _avg: RFQSubmissionAvgAggregateOutputType | null
    _sum: RFQSubmissionSumAggregateOutputType | null
    _min: RFQSubmissionMinAggregateOutputType | null
    _max: RFQSubmissionMaxAggregateOutputType | null
  }

  export type RFQSubmissionAvgAggregateOutputType = {
    id: number | null
    rfqId: number | null
    vendorId: number | null
    totalValue: number | null
    totalAmount: number | null
  }

  export type RFQSubmissionSumAggregateOutputType = {
    id: number | null
    rfqId: number | null
    vendorId: number | null
    totalValue: number | null
    totalAmount: number | null
  }

  export type RFQSubmissionMinAggregateOutputType = {
    id: number | null
    rfqId: number | null
    vendorId: number | null
    submittedAt: Date | null
    totalValue: number | null
    currency: string | null
    docUrl: string | null
    status: string | null
    totalAmount: number | null
  }

  export type RFQSubmissionMaxAggregateOutputType = {
    id: number | null
    rfqId: number | null
    vendorId: number | null
    submittedAt: Date | null
    totalValue: number | null
    currency: string | null
    docUrl: string | null
    status: string | null
    totalAmount: number | null
  }

  export type RFQSubmissionCountAggregateOutputType = {
    id: number
    rfqId: number
    vendorId: number
    submittedAt: number
    totalValue: number
    currency: number
    docUrl: number
    items: number
    status: number
    totalAmount: number
    _all: number
  }


  export type RFQSubmissionAvgAggregateInputType = {
    id?: true
    rfqId?: true
    vendorId?: true
    totalValue?: true
    totalAmount?: true
  }

  export type RFQSubmissionSumAggregateInputType = {
    id?: true
    rfqId?: true
    vendorId?: true
    totalValue?: true
    totalAmount?: true
  }

  export type RFQSubmissionMinAggregateInputType = {
    id?: true
    rfqId?: true
    vendorId?: true
    submittedAt?: true
    totalValue?: true
    currency?: true
    docUrl?: true
    status?: true
    totalAmount?: true
  }

  export type RFQSubmissionMaxAggregateInputType = {
    id?: true
    rfqId?: true
    vendorId?: true
    submittedAt?: true
    totalValue?: true
    currency?: true
    docUrl?: true
    status?: true
    totalAmount?: true
  }

  export type RFQSubmissionCountAggregateInputType = {
    id?: true
    rfqId?: true
    vendorId?: true
    submittedAt?: true
    totalValue?: true
    currency?: true
    docUrl?: true
    items?: true
    status?: true
    totalAmount?: true
    _all?: true
  }

  export type RFQSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQSubmission to aggregate.
     */
    where?: RFQSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQSubmissions to fetch.
     */
    orderBy?: RFQSubmissionOrderByWithRelationInput | RFQSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RFQSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RFQSubmissions
    **/
    _count?: true | RFQSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RFQSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RFQSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RFQSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RFQSubmissionMaxAggregateInputType
  }

  export type GetRFQSubmissionAggregateType<T extends RFQSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRFQSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRFQSubmission[P]>
      : GetScalarType<T[P], AggregateRFQSubmission[P]>
  }




  export type RFQSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RFQSubmissionWhereInput
    orderBy?: RFQSubmissionOrderByWithAggregationInput | RFQSubmissionOrderByWithAggregationInput[]
    by: RFQSubmissionScalarFieldEnum[] | RFQSubmissionScalarFieldEnum
    having?: RFQSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RFQSubmissionCountAggregateInputType | true
    _avg?: RFQSubmissionAvgAggregateInputType
    _sum?: RFQSubmissionSumAggregateInputType
    _min?: RFQSubmissionMinAggregateInputType
    _max?: RFQSubmissionMaxAggregateInputType
  }

  export type RFQSubmissionGroupByOutputType = {
    id: number
    rfqId: number
    vendorId: number
    submittedAt: Date | null
    totalValue: number | null
    currency: string
    docUrl: string | null
    items: JsonValue | null
    status: string | null
    totalAmount: number | null
    _count: RFQSubmissionCountAggregateOutputType | null
    _avg: RFQSubmissionAvgAggregateOutputType | null
    _sum: RFQSubmissionSumAggregateOutputType | null
    _min: RFQSubmissionMinAggregateOutputType | null
    _max: RFQSubmissionMaxAggregateOutputType | null
  }

  type GetRFQSubmissionGroupByPayload<T extends RFQSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RFQSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RFQSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RFQSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], RFQSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type RFQSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqId?: boolean
    vendorId?: boolean
    submittedAt?: boolean
    totalValue?: boolean
    currency?: boolean
    docUrl?: boolean
    items?: boolean
    status?: boolean
    totalAmount?: boolean
    evaluations?: boolean | RFQSubmission$evaluationsArgs<ExtArgs>
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    _count?: boolean | RFQSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQSubmission"]>

  export type RFQSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqId?: boolean
    vendorId?: boolean
    submittedAt?: boolean
    totalValue?: boolean
    currency?: boolean
    docUrl?: boolean
    items?: boolean
    status?: boolean
    totalAmount?: boolean
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQSubmission"]>

  export type RFQSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfqId?: boolean
    vendorId?: boolean
    submittedAt?: boolean
    totalValue?: boolean
    currency?: boolean
    docUrl?: boolean
    items?: boolean
    status?: boolean
    totalAmount?: boolean
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rFQSubmission"]>

  export type RFQSubmissionSelectScalar = {
    id?: boolean
    rfqId?: boolean
    vendorId?: boolean
    submittedAt?: boolean
    totalValue?: boolean
    currency?: boolean
    docUrl?: boolean
    items?: boolean
    status?: boolean
    totalAmount?: boolean
  }

  export type RFQSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfqId" | "vendorId" | "submittedAt" | "totalValue" | "currency" | "docUrl" | "items" | "status" | "totalAmount", ExtArgs["result"]["rFQSubmission"]>
  export type RFQSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | RFQSubmission$evaluationsArgs<ExtArgs>
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    _count?: boolean | RFQSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RFQSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type RFQSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfq?: boolean | RFQDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $RFQSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RFQSubmission"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      rfq: Prisma.$RFQPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfqId: number
      vendorId: number
      submittedAt: Date | null
      totalValue: number | null
      currency: string
      docUrl: string | null
      items: Prisma.JsonValue | null
      status: string | null
      totalAmount: number | null
    }, ExtArgs["result"]["rFQSubmission"]>
    composites: {}
  }

  type RFQSubmissionGetPayload<S extends boolean | null | undefined | RFQSubmissionDefaultArgs> = $Result.GetResult<Prisma.$RFQSubmissionPayload, S>

  type RFQSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RFQSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RFQSubmissionCountAggregateInputType | true
    }

  export interface RFQSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RFQSubmission'], meta: { name: 'RFQSubmission' } }
    /**
     * Find zero or one RFQSubmission that matches the filter.
     * @param {RFQSubmissionFindUniqueArgs} args - Arguments to find a RFQSubmission
     * @example
     * // Get one RFQSubmission
     * const rFQSubmission = await prisma.rFQSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RFQSubmissionFindUniqueArgs>(args: SelectSubset<T, RFQSubmissionFindUniqueArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RFQSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RFQSubmissionFindUniqueOrThrowArgs} args - Arguments to find a RFQSubmission
     * @example
     * // Get one RFQSubmission
     * const rFQSubmission = await prisma.rFQSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RFQSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RFQSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RFQSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQSubmissionFindFirstArgs} args - Arguments to find a RFQSubmission
     * @example
     * // Get one RFQSubmission
     * const rFQSubmission = await prisma.rFQSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RFQSubmissionFindFirstArgs>(args?: SelectSubset<T, RFQSubmissionFindFirstArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RFQSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQSubmissionFindFirstOrThrowArgs} args - Arguments to find a RFQSubmission
     * @example
     * // Get one RFQSubmission
     * const rFQSubmission = await prisma.rFQSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RFQSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RFQSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RFQSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RFQSubmissions
     * const rFQSubmissions = await prisma.rFQSubmission.findMany()
     * 
     * // Get first 10 RFQSubmissions
     * const rFQSubmissions = await prisma.rFQSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rFQSubmissionWithIdOnly = await prisma.rFQSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RFQSubmissionFindManyArgs>(args?: SelectSubset<T, RFQSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RFQSubmission.
     * @param {RFQSubmissionCreateArgs} args - Arguments to create a RFQSubmission.
     * @example
     * // Create one RFQSubmission
     * const RFQSubmission = await prisma.rFQSubmission.create({
     *   data: {
     *     // ... data to create a RFQSubmission
     *   }
     * })
     * 
     */
    create<T extends RFQSubmissionCreateArgs>(args: SelectSubset<T, RFQSubmissionCreateArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RFQSubmissions.
     * @param {RFQSubmissionCreateManyArgs} args - Arguments to create many RFQSubmissions.
     * @example
     * // Create many RFQSubmissions
     * const rFQSubmission = await prisma.rFQSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RFQSubmissionCreateManyArgs>(args?: SelectSubset<T, RFQSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RFQSubmissions and returns the data saved in the database.
     * @param {RFQSubmissionCreateManyAndReturnArgs} args - Arguments to create many RFQSubmissions.
     * @example
     * // Create many RFQSubmissions
     * const rFQSubmission = await prisma.rFQSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RFQSubmissions and only return the `id`
     * const rFQSubmissionWithIdOnly = await prisma.rFQSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RFQSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RFQSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RFQSubmission.
     * @param {RFQSubmissionDeleteArgs} args - Arguments to delete one RFQSubmission.
     * @example
     * // Delete one RFQSubmission
     * const RFQSubmission = await prisma.rFQSubmission.delete({
     *   where: {
     *     // ... filter to delete one RFQSubmission
     *   }
     * })
     * 
     */
    delete<T extends RFQSubmissionDeleteArgs>(args: SelectSubset<T, RFQSubmissionDeleteArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RFQSubmission.
     * @param {RFQSubmissionUpdateArgs} args - Arguments to update one RFQSubmission.
     * @example
     * // Update one RFQSubmission
     * const rFQSubmission = await prisma.rFQSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RFQSubmissionUpdateArgs>(args: SelectSubset<T, RFQSubmissionUpdateArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RFQSubmissions.
     * @param {RFQSubmissionDeleteManyArgs} args - Arguments to filter RFQSubmissions to delete.
     * @example
     * // Delete a few RFQSubmissions
     * const { count } = await prisma.rFQSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RFQSubmissionDeleteManyArgs>(args?: SelectSubset<T, RFQSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RFQSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RFQSubmissions
     * const rFQSubmission = await prisma.rFQSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RFQSubmissionUpdateManyArgs>(args: SelectSubset<T, RFQSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RFQSubmissions and returns the data updated in the database.
     * @param {RFQSubmissionUpdateManyAndReturnArgs} args - Arguments to update many RFQSubmissions.
     * @example
     * // Update many RFQSubmissions
     * const rFQSubmission = await prisma.rFQSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RFQSubmissions and only return the `id`
     * const rFQSubmissionWithIdOnly = await prisma.rFQSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RFQSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RFQSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RFQSubmission.
     * @param {RFQSubmissionUpsertArgs} args - Arguments to update or create a RFQSubmission.
     * @example
     * // Update or create a RFQSubmission
     * const rFQSubmission = await prisma.rFQSubmission.upsert({
     *   create: {
     *     // ... data to create a RFQSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RFQSubmission we want to update
     *   }
     * })
     */
    upsert<T extends RFQSubmissionUpsertArgs>(args: SelectSubset<T, RFQSubmissionUpsertArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RFQSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQSubmissionCountArgs} args - Arguments to filter RFQSubmissions to count.
     * @example
     * // Count the number of RFQSubmissions
     * const count = await prisma.rFQSubmission.count({
     *   where: {
     *     // ... the filter for the RFQSubmissions we want to count
     *   }
     * })
    **/
    count<T extends RFQSubmissionCountArgs>(
      args?: Subset<T, RFQSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RFQSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RFQSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RFQSubmissionAggregateArgs>(args: Subset<T, RFQSubmissionAggregateArgs>): Prisma.PrismaPromise<GetRFQSubmissionAggregateType<T>>

    /**
     * Group by RFQSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RFQSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RFQSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RFQSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: RFQSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RFQSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRFQSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RFQSubmission model
   */
  readonly fields: RFQSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RFQSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RFQSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluations<T extends RFQSubmission$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, RFQSubmission$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rfq<T extends RFQDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RFQDefaultArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RFQSubmission model
   */
  interface RFQSubmissionFieldRefs {
    readonly id: FieldRef<"RFQSubmission", 'Int'>
    readonly rfqId: FieldRef<"RFQSubmission", 'Int'>
    readonly vendorId: FieldRef<"RFQSubmission", 'Int'>
    readonly submittedAt: FieldRef<"RFQSubmission", 'DateTime'>
    readonly totalValue: FieldRef<"RFQSubmission", 'Float'>
    readonly currency: FieldRef<"RFQSubmission", 'String'>
    readonly docUrl: FieldRef<"RFQSubmission", 'String'>
    readonly items: FieldRef<"RFQSubmission", 'Json'>
    readonly status: FieldRef<"RFQSubmission", 'String'>
    readonly totalAmount: FieldRef<"RFQSubmission", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RFQSubmission findUnique
   */
  export type RFQSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which RFQSubmission to fetch.
     */
    where: RFQSubmissionWhereUniqueInput
  }

  /**
   * RFQSubmission findUniqueOrThrow
   */
  export type RFQSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which RFQSubmission to fetch.
     */
    where: RFQSubmissionWhereUniqueInput
  }

  /**
   * RFQSubmission findFirst
   */
  export type RFQSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which RFQSubmission to fetch.
     */
    where?: RFQSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQSubmissions to fetch.
     */
    orderBy?: RFQSubmissionOrderByWithRelationInput | RFQSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQSubmissions.
     */
    cursor?: RFQSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQSubmissions.
     */
    distinct?: RFQSubmissionScalarFieldEnum | RFQSubmissionScalarFieldEnum[]
  }

  /**
   * RFQSubmission findFirstOrThrow
   */
  export type RFQSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which RFQSubmission to fetch.
     */
    where?: RFQSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQSubmissions to fetch.
     */
    orderBy?: RFQSubmissionOrderByWithRelationInput | RFQSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RFQSubmissions.
     */
    cursor?: RFQSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RFQSubmissions.
     */
    distinct?: RFQSubmissionScalarFieldEnum | RFQSubmissionScalarFieldEnum[]
  }

  /**
   * RFQSubmission findMany
   */
  export type RFQSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which RFQSubmissions to fetch.
     */
    where?: RFQSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RFQSubmissions to fetch.
     */
    orderBy?: RFQSubmissionOrderByWithRelationInput | RFQSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RFQSubmissions.
     */
    cursor?: RFQSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RFQSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RFQSubmissions.
     */
    skip?: number
    distinct?: RFQSubmissionScalarFieldEnum | RFQSubmissionScalarFieldEnum[]
  }

  /**
   * RFQSubmission create
   */
  export type RFQSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RFQSubmission.
     */
    data: XOR<RFQSubmissionCreateInput, RFQSubmissionUncheckedCreateInput>
  }

  /**
   * RFQSubmission createMany
   */
  export type RFQSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RFQSubmissions.
     */
    data: RFQSubmissionCreateManyInput | RFQSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RFQSubmission createManyAndReturn
   */
  export type RFQSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many RFQSubmissions.
     */
    data: RFQSubmissionCreateManyInput | RFQSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RFQSubmission update
   */
  export type RFQSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RFQSubmission.
     */
    data: XOR<RFQSubmissionUpdateInput, RFQSubmissionUncheckedUpdateInput>
    /**
     * Choose, which RFQSubmission to update.
     */
    where: RFQSubmissionWhereUniqueInput
  }

  /**
   * RFQSubmission updateMany
   */
  export type RFQSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RFQSubmissions.
     */
    data: XOR<RFQSubmissionUpdateManyMutationInput, RFQSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which RFQSubmissions to update
     */
    where?: RFQSubmissionWhereInput
    /**
     * Limit how many RFQSubmissions to update.
     */
    limit?: number
  }

  /**
   * RFQSubmission updateManyAndReturn
   */
  export type RFQSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update RFQSubmissions.
     */
    data: XOR<RFQSubmissionUpdateManyMutationInput, RFQSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which RFQSubmissions to update
     */
    where?: RFQSubmissionWhereInput
    /**
     * Limit how many RFQSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RFQSubmission upsert
   */
  export type RFQSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RFQSubmission to update in case it exists.
     */
    where: RFQSubmissionWhereUniqueInput
    /**
     * In case the RFQSubmission found by the `where` argument doesn't exist, create a new RFQSubmission with this data.
     */
    create: XOR<RFQSubmissionCreateInput, RFQSubmissionUncheckedCreateInput>
    /**
     * In case the RFQSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RFQSubmissionUpdateInput, RFQSubmissionUncheckedUpdateInput>
  }

  /**
   * RFQSubmission delete
   */
  export type RFQSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
    /**
     * Filter which RFQSubmission to delete.
     */
    where: RFQSubmissionWhereUniqueInput
  }

  /**
   * RFQSubmission deleteMany
   */
  export type RFQSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RFQSubmissions to delete
     */
    where?: RFQSubmissionWhereInput
    /**
     * Limit how many RFQSubmissions to delete.
     */
    limit?: number
  }

  /**
   * RFQSubmission.evaluations
   */
  export type RFQSubmission$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * RFQSubmission without action
   */
  export type RFQSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQSubmission
     */
    select?: RFQSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQSubmission
     */
    omit?: RFQSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationAvgAggregateOutputType = {
    id: number | null
    submissionId: number | null
    evaluatorId: number | null
    technicalScore: number | null
    financialScore: number | null
    experienceScore: number | null
    responsiveness: number | null
    otherScore: number | null
    totalScore: number | null
  }

  export type EvaluationSumAggregateOutputType = {
    id: number | null
    submissionId: number | null
    evaluatorId: number | null
    technicalScore: number | null
    financialScore: number | null
    experienceScore: number | null
    responsiveness: number | null
    otherScore: number | null
    totalScore: number | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: number | null
    submissionId: number | null
    evaluatorId: number | null
    technicalScore: number | null
    financialScore: number | null
    experienceScore: number | null
    responsiveness: number | null
    otherScore: number | null
    totalScore: number | null
    comments: string | null
    createdAt: Date | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: number | null
    submissionId: number | null
    evaluatorId: number | null
    technicalScore: number | null
    financialScore: number | null
    experienceScore: number | null
    responsiveness: number | null
    otherScore: number | null
    totalScore: number | null
    comments: string | null
    createdAt: Date | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    submissionId: number
    evaluatorId: number
    technicalScore: number
    financialScore: number
    experienceScore: number
    responsiveness: number
    otherScore: number
    totalScore: number
    comments: number
    createdAt: number
    _all: number
  }


  export type EvaluationAvgAggregateInputType = {
    id?: true
    submissionId?: true
    evaluatorId?: true
    technicalScore?: true
    financialScore?: true
    experienceScore?: true
    responsiveness?: true
    otherScore?: true
    totalScore?: true
  }

  export type EvaluationSumAggregateInputType = {
    id?: true
    submissionId?: true
    evaluatorId?: true
    technicalScore?: true
    financialScore?: true
    experienceScore?: true
    responsiveness?: true
    otherScore?: true
    totalScore?: true
  }

  export type EvaluationMinAggregateInputType = {
    id?: true
    submissionId?: true
    evaluatorId?: true
    technicalScore?: true
    financialScore?: true
    experienceScore?: true
    responsiveness?: true
    otherScore?: true
    totalScore?: true
    comments?: true
    createdAt?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    submissionId?: true
    evaluatorId?: true
    technicalScore?: true
    financialScore?: true
    experienceScore?: true
    responsiveness?: true
    otherScore?: true
    totalScore?: true
    comments?: true
    createdAt?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    submissionId?: true
    evaluatorId?: true
    technicalScore?: true
    financialScore?: true
    experienceScore?: true
    responsiveness?: true
    otherScore?: true
    totalScore?: true
    comments?: true
    createdAt?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _avg?: EvaluationAvgAggregateInputType
    _sum?: EvaluationSumAggregateInputType
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    id: number
    submissionId: number
    evaluatorId: number
    technicalScore: number | null
    financialScore: number | null
    experienceScore: number | null
    responsiveness: number | null
    otherScore: number | null
    totalScore: number | null
    comments: string | null
    createdAt: Date
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submissionId?: boolean
    evaluatorId?: boolean
    technicalScore?: boolean
    financialScore?: boolean
    experienceScore?: boolean
    responsiveness?: boolean
    otherScore?: boolean
    totalScore?: boolean
    comments?: boolean
    createdAt?: boolean
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    submission?: boolean | RFQSubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submissionId?: boolean
    evaluatorId?: boolean
    technicalScore?: boolean
    financialScore?: boolean
    experienceScore?: boolean
    responsiveness?: boolean
    otherScore?: boolean
    totalScore?: boolean
    comments?: boolean
    createdAt?: boolean
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    submission?: boolean | RFQSubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submissionId?: boolean
    evaluatorId?: boolean
    technicalScore?: boolean
    financialScore?: boolean
    experienceScore?: boolean
    responsiveness?: boolean
    otherScore?: boolean
    totalScore?: boolean
    comments?: boolean
    createdAt?: boolean
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    submission?: boolean | RFQSubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    submissionId?: boolean
    evaluatorId?: boolean
    technicalScore?: boolean
    financialScore?: boolean
    experienceScore?: boolean
    responsiveness?: boolean
    otherScore?: boolean
    totalScore?: boolean
    comments?: boolean
    createdAt?: boolean
  }

  export type EvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "submissionId" | "evaluatorId" | "technicalScore" | "financialScore" | "experienceScore" | "responsiveness" | "otherScore" | "totalScore" | "comments" | "createdAt", ExtArgs["result"]["evaluation"]>
  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    submission?: boolean | RFQSubmissionDefaultArgs<ExtArgs>
  }
  export type EvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    submission?: boolean | RFQSubmissionDefaultArgs<ExtArgs>
  }
  export type EvaluationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    submission?: boolean | RFQSubmissionDefaultArgs<ExtArgs>
  }

  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      evaluator: Prisma.$UserPayload<ExtArgs>
      submission: Prisma.$RFQSubmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      submissionId: number
      evaluatorId: number
      technicalScore: number | null
      financialScore: number | null
      experienceScore: number | null
      responsiveness: number | null
      otherScore: number | null
      totalScore: number | null
      comments: string | null
      createdAt: Date
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }

  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationFindUniqueArgs>(args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationFindFirstArgs>(args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationFindManyArgs>(args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
     */
    create<T extends EvaluationCreateArgs>(args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evaluations.
     * @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationCreateManyArgs>(args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evaluations and returns the data saved in the database.
     * @param {EvaluationCreateManyAndReturnArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evaluations and only return the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
     */
    delete<T extends EvaluationDeleteArgs>(args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationUpdateArgs>(args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationDeleteManyArgs>(args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationUpdateManyArgs>(args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations and returns the data updated in the database.
     * @param {EvaluationUpdateManyAndReturnArgs} args - Arguments to update many Evaluations.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evaluations and only return the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvaluationUpdateManyAndReturnArgs>(args: SelectSubset<T, EvaluationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationUpsertArgs>(args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submission<T extends RFQSubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RFQSubmissionDefaultArgs<ExtArgs>>): Prisma__RFQSubmissionClient<$Result.GetResult<Prisma.$RFQSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evaluation model
   */
  interface EvaluationFieldRefs {
    readonly id: FieldRef<"Evaluation", 'Int'>
    readonly submissionId: FieldRef<"Evaluation", 'Int'>
    readonly evaluatorId: FieldRef<"Evaluation", 'Int'>
    readonly technicalScore: FieldRef<"Evaluation", 'Float'>
    readonly financialScore: FieldRef<"Evaluation", 'Float'>
    readonly experienceScore: FieldRef<"Evaluation", 'Float'>
    readonly responsiveness: FieldRef<"Evaluation", 'Float'>
    readonly otherScore: FieldRef<"Evaluation", 'Float'>
    readonly totalScore: FieldRef<"Evaluation", 'Float'>
    readonly comments: FieldRef<"Evaluation", 'String'>
    readonly createdAt: FieldRef<"Evaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }

  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation createManyAndReturn
   */
  export type EvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to update.
     */
    limit?: number
  }

  /**
   * Evaluation updateManyAndReturn
   */
  export type EvaluationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }

  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to delete.
     */
    limit?: number
  }

  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    rfqId: number | null
    vendorId: number | null
    contractValue: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    rfqId: number | null
    vendorId: number | null
    contractValue: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    contractNumber: string | null
    rfqId: number | null
    vendorId: number | null
    contractValue: number | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    contractNumber: string | null
    rfqId: number | null
    vendorId: number | null
    contractValue: number | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    contractNumber: number
    rfqId: number
    vendorId: number
    contractValue: number
    currency: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    rfqId?: true
    vendorId?: true
    contractValue?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    rfqId?: true
    vendorId?: true
    contractValue?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    contractNumber?: true
    rfqId?: true
    vendorId?: true
    contractValue?: true
    currency?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    contractNumber?: true
    rfqId?: true
    vendorId?: true
    contractValue?: true
    currency?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    contractNumber?: true
    rfqId?: true
    vendorId?: true
    contractValue?: true
    currency?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: number
    contractNumber: string
    rfqId: number | null
    vendorId: number
    contractValue: number
    currency: string
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    rfqId?: boolean
    vendorId?: boolean
    contractValue?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    rfq?: boolean | Contract$rfqArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    documents?: boolean | Contract$documentsArgs<ExtArgs>
    ipcs?: boolean | Contract$ipcsArgs<ExtArgs>
    variationOrders?: boolean | Contract$variationOrdersArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    rfqId?: boolean
    vendorId?: boolean
    contractValue?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    rfq?: boolean | Contract$rfqArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    rfqId?: boolean
    vendorId?: boolean
    contractValue?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    rfq?: boolean | Contract$rfqArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    contractNumber?: boolean
    rfqId?: boolean
    vendorId?: boolean
    contractValue?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractNumber" | "rfqId" | "vendorId" | "contractValue" | "currency" | "startDate" | "endDate" | "status" | "createdAt", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfq?: boolean | Contract$rfqArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    documents?: boolean | Contract$documentsArgs<ExtArgs>
    ipcs?: boolean | Contract$ipcsArgs<ExtArgs>
    variationOrders?: boolean | Contract$variationOrdersArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfq?: boolean | Contract$rfqArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rfq?: boolean | Contract$rfqArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      rfq: Prisma.$RFQPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      ipcs: Prisma.$IPCPayload<ExtArgs>[]
      variationOrders: Prisma.$VariationOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractNumber: string
      rfqId: number | null
      vendorId: number
      contractValue: number
      currency: string
      startDate: Date | null
      endDate: Date | null
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rfq<T extends Contract$rfqArgs<ExtArgs> = {}>(args?: Subset<T, Contract$rfqArgs<ExtArgs>>): Prisma__RFQClient<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends Contract$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ipcs<T extends Contract$ipcsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$ipcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variationOrders<T extends Contract$variationOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Contract$variationOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'Int'>
    readonly contractNumber: FieldRef<"Contract", 'String'>
    readonly rfqId: FieldRef<"Contract", 'Int'>
    readonly vendorId: FieldRef<"Contract", 'Int'>
    readonly contractValue: FieldRef<"Contract", 'Float'>
    readonly currency: FieldRef<"Contract", 'String'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly status: FieldRef<"Contract", 'String'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract.rfq
   */
  export type Contract$rfqArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    where?: RFQWhereInput
  }

  /**
   * Contract.documents
   */
  export type Contract$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Contract.ipcs
   */
  export type Contract$ipcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    where?: IPCWhereInput
    orderBy?: IPCOrderByWithRelationInput | IPCOrderByWithRelationInput[]
    cursor?: IPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IPCScalarFieldEnum | IPCScalarFieldEnum[]
  }

  /**
   * Contract.variationOrders
   */
  export type Contract$variationOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    where?: VariationOrderWhereInput
    orderBy?: VariationOrderOrderByWithRelationInput | VariationOrderOrderByWithRelationInput[]
    cursor?: VariationOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariationOrderScalarFieldEnum | VariationOrderScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model VariationOrder
   */

  export type AggregateVariationOrder = {
    _count: VariationOrderCountAggregateOutputType | null
    _avg: VariationOrderAvgAggregateOutputType | null
    _sum: VariationOrderSumAggregateOutputType | null
    _min: VariationOrderMinAggregateOutputType | null
    _max: VariationOrderMaxAggregateOutputType | null
  }

  export type VariationOrderAvgAggregateOutputType = {
    id: number | null
    contractId: number | null
    costImpact: number | null
    timeImpact: number | null
  }

  export type VariationOrderSumAggregateOutputType = {
    id: number | null
    contractId: number | null
    costImpact: number | null
    timeImpact: number | null
  }

  export type VariationOrderMinAggregateOutputType = {
    id: number | null
    voRef: string | null
    contractId: number | null
    description: string | null
    costImpact: number | null
    timeImpact: number | null
    status: string | null
    createdAt: Date | null
  }

  export type VariationOrderMaxAggregateOutputType = {
    id: number | null
    voRef: string | null
    contractId: number | null
    description: string | null
    costImpact: number | null
    timeImpact: number | null
    status: string | null
    createdAt: Date | null
  }

  export type VariationOrderCountAggregateOutputType = {
    id: number
    voRef: number
    contractId: number
    description: number
    costImpact: number
    timeImpact: number
    status: number
    createdAt: number
    _all: number
  }


  export type VariationOrderAvgAggregateInputType = {
    id?: true
    contractId?: true
    costImpact?: true
    timeImpact?: true
  }

  export type VariationOrderSumAggregateInputType = {
    id?: true
    contractId?: true
    costImpact?: true
    timeImpact?: true
  }

  export type VariationOrderMinAggregateInputType = {
    id?: true
    voRef?: true
    contractId?: true
    description?: true
    costImpact?: true
    timeImpact?: true
    status?: true
    createdAt?: true
  }

  export type VariationOrderMaxAggregateInputType = {
    id?: true
    voRef?: true
    contractId?: true
    description?: true
    costImpact?: true
    timeImpact?: true
    status?: true
    createdAt?: true
  }

  export type VariationOrderCountAggregateInputType = {
    id?: true
    voRef?: true
    contractId?: true
    description?: true
    costImpact?: true
    timeImpact?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type VariationOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationOrder to aggregate.
     */
    where?: VariationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationOrders to fetch.
     */
    orderBy?: VariationOrderOrderByWithRelationInput | VariationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariationOrders
    **/
    _count?: true | VariationOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariationOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariationOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariationOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariationOrderMaxAggregateInputType
  }

  export type GetVariationOrderAggregateType<T extends VariationOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateVariationOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariationOrder[P]>
      : GetScalarType<T[P], AggregateVariationOrder[P]>
  }




  export type VariationOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationOrderWhereInput
    orderBy?: VariationOrderOrderByWithAggregationInput | VariationOrderOrderByWithAggregationInput[]
    by: VariationOrderScalarFieldEnum[] | VariationOrderScalarFieldEnum
    having?: VariationOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariationOrderCountAggregateInputType | true
    _avg?: VariationOrderAvgAggregateInputType
    _sum?: VariationOrderSumAggregateInputType
    _min?: VariationOrderMinAggregateInputType
    _max?: VariationOrderMaxAggregateInputType
  }

  export type VariationOrderGroupByOutputType = {
    id: number
    voRef: string
    contractId: number
    description: string | null
    costImpact: number | null
    timeImpact: number | null
    status: string | null
    createdAt: Date
    _count: VariationOrderCountAggregateOutputType | null
    _avg: VariationOrderAvgAggregateOutputType | null
    _sum: VariationOrderSumAggregateOutputType | null
    _min: VariationOrderMinAggregateOutputType | null
    _max: VariationOrderMaxAggregateOutputType | null
  }

  type GetVariationOrderGroupByPayload<T extends VariationOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariationOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariationOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariationOrderGroupByOutputType[P]>
            : GetScalarType<T[P], VariationOrderGroupByOutputType[P]>
        }
      >
    >


  export type VariationOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voRef?: boolean
    contractId?: boolean
    description?: boolean
    costImpact?: boolean
    timeImpact?: boolean
    status?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationOrder"]>

  export type VariationOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voRef?: boolean
    contractId?: boolean
    description?: boolean
    costImpact?: boolean
    timeImpact?: boolean
    status?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationOrder"]>

  export type VariationOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voRef?: boolean
    contractId?: boolean
    description?: boolean
    costImpact?: boolean
    timeImpact?: boolean
    status?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationOrder"]>

  export type VariationOrderSelectScalar = {
    id?: boolean
    voRef?: boolean
    contractId?: boolean
    description?: boolean
    costImpact?: boolean
    timeImpact?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type VariationOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voRef" | "contractId" | "description" | "costImpact" | "timeImpact" | "status" | "createdAt", ExtArgs["result"]["variationOrder"]>
  export type VariationOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type VariationOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type VariationOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $VariationOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariationOrder"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      voRef: string
      contractId: number
      description: string | null
      costImpact: number | null
      timeImpact: number | null
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["variationOrder"]>
    composites: {}
  }

  type VariationOrderGetPayload<S extends boolean | null | undefined | VariationOrderDefaultArgs> = $Result.GetResult<Prisma.$VariationOrderPayload, S>

  type VariationOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariationOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariationOrderCountAggregateInputType | true
    }

  export interface VariationOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariationOrder'], meta: { name: 'VariationOrder' } }
    /**
     * Find zero or one VariationOrder that matches the filter.
     * @param {VariationOrderFindUniqueArgs} args - Arguments to find a VariationOrder
     * @example
     * // Get one VariationOrder
     * const variationOrder = await prisma.variationOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariationOrderFindUniqueArgs>(args: SelectSubset<T, VariationOrderFindUniqueArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariationOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariationOrderFindUniqueOrThrowArgs} args - Arguments to find a VariationOrder
     * @example
     * // Get one VariationOrder
     * const variationOrder = await prisma.variationOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariationOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, VariationOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationOrderFindFirstArgs} args - Arguments to find a VariationOrder
     * @example
     * // Get one VariationOrder
     * const variationOrder = await prisma.variationOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariationOrderFindFirstArgs>(args?: SelectSubset<T, VariationOrderFindFirstArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationOrderFindFirstOrThrowArgs} args - Arguments to find a VariationOrder
     * @example
     * // Get one VariationOrder
     * const variationOrder = await prisma.variationOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariationOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, VariationOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariationOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariationOrders
     * const variationOrders = await prisma.variationOrder.findMany()
     * 
     * // Get first 10 VariationOrders
     * const variationOrders = await prisma.variationOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variationOrderWithIdOnly = await prisma.variationOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariationOrderFindManyArgs>(args?: SelectSubset<T, VariationOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariationOrder.
     * @param {VariationOrderCreateArgs} args - Arguments to create a VariationOrder.
     * @example
     * // Create one VariationOrder
     * const VariationOrder = await prisma.variationOrder.create({
     *   data: {
     *     // ... data to create a VariationOrder
     *   }
     * })
     * 
     */
    create<T extends VariationOrderCreateArgs>(args: SelectSubset<T, VariationOrderCreateArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariationOrders.
     * @param {VariationOrderCreateManyArgs} args - Arguments to create many VariationOrders.
     * @example
     * // Create many VariationOrders
     * const variationOrder = await prisma.variationOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariationOrderCreateManyArgs>(args?: SelectSubset<T, VariationOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariationOrders and returns the data saved in the database.
     * @param {VariationOrderCreateManyAndReturnArgs} args - Arguments to create many VariationOrders.
     * @example
     * // Create many VariationOrders
     * const variationOrder = await prisma.variationOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariationOrders and only return the `id`
     * const variationOrderWithIdOnly = await prisma.variationOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariationOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, VariationOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariationOrder.
     * @param {VariationOrderDeleteArgs} args - Arguments to delete one VariationOrder.
     * @example
     * // Delete one VariationOrder
     * const VariationOrder = await prisma.variationOrder.delete({
     *   where: {
     *     // ... filter to delete one VariationOrder
     *   }
     * })
     * 
     */
    delete<T extends VariationOrderDeleteArgs>(args: SelectSubset<T, VariationOrderDeleteArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariationOrder.
     * @param {VariationOrderUpdateArgs} args - Arguments to update one VariationOrder.
     * @example
     * // Update one VariationOrder
     * const variationOrder = await prisma.variationOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariationOrderUpdateArgs>(args: SelectSubset<T, VariationOrderUpdateArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariationOrders.
     * @param {VariationOrderDeleteManyArgs} args - Arguments to filter VariationOrders to delete.
     * @example
     * // Delete a few VariationOrders
     * const { count } = await prisma.variationOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariationOrderDeleteManyArgs>(args?: SelectSubset<T, VariationOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariationOrders
     * const variationOrder = await prisma.variationOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariationOrderUpdateManyArgs>(args: SelectSubset<T, VariationOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationOrders and returns the data updated in the database.
     * @param {VariationOrderUpdateManyAndReturnArgs} args - Arguments to update many VariationOrders.
     * @example
     * // Update many VariationOrders
     * const variationOrder = await prisma.variationOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariationOrders and only return the `id`
     * const variationOrderWithIdOnly = await prisma.variationOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariationOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, VariationOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariationOrder.
     * @param {VariationOrderUpsertArgs} args - Arguments to update or create a VariationOrder.
     * @example
     * // Update or create a VariationOrder
     * const variationOrder = await prisma.variationOrder.upsert({
     *   create: {
     *     // ... data to create a VariationOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariationOrder we want to update
     *   }
     * })
     */
    upsert<T extends VariationOrderUpsertArgs>(args: SelectSubset<T, VariationOrderUpsertArgs<ExtArgs>>): Prisma__VariationOrderClient<$Result.GetResult<Prisma.$VariationOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariationOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationOrderCountArgs} args - Arguments to filter VariationOrders to count.
     * @example
     * // Count the number of VariationOrders
     * const count = await prisma.variationOrder.count({
     *   where: {
     *     // ... the filter for the VariationOrders we want to count
     *   }
     * })
    **/
    count<T extends VariationOrderCountArgs>(
      args?: Subset<T, VariationOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariationOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariationOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariationOrderAggregateArgs>(args: Subset<T, VariationOrderAggregateArgs>): Prisma.PrismaPromise<GetVariationOrderAggregateType<T>>

    /**
     * Group by VariationOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariationOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariationOrderGroupByArgs['orderBy'] }
        : { orderBy?: VariationOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariationOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariationOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariationOrder model
   */
  readonly fields: VariationOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariationOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariationOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariationOrder model
   */
  interface VariationOrderFieldRefs {
    readonly id: FieldRef<"VariationOrder", 'Int'>
    readonly voRef: FieldRef<"VariationOrder", 'String'>
    readonly contractId: FieldRef<"VariationOrder", 'Int'>
    readonly description: FieldRef<"VariationOrder", 'String'>
    readonly costImpact: FieldRef<"VariationOrder", 'Float'>
    readonly timeImpact: FieldRef<"VariationOrder", 'Int'>
    readonly status: FieldRef<"VariationOrder", 'String'>
    readonly createdAt: FieldRef<"VariationOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VariationOrder findUnique
   */
  export type VariationOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * Filter, which VariationOrder to fetch.
     */
    where: VariationOrderWhereUniqueInput
  }

  /**
   * VariationOrder findUniqueOrThrow
   */
  export type VariationOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * Filter, which VariationOrder to fetch.
     */
    where: VariationOrderWhereUniqueInput
  }

  /**
   * VariationOrder findFirst
   */
  export type VariationOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * Filter, which VariationOrder to fetch.
     */
    where?: VariationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationOrders to fetch.
     */
    orderBy?: VariationOrderOrderByWithRelationInput | VariationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationOrders.
     */
    cursor?: VariationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationOrders.
     */
    distinct?: VariationOrderScalarFieldEnum | VariationOrderScalarFieldEnum[]
  }

  /**
   * VariationOrder findFirstOrThrow
   */
  export type VariationOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * Filter, which VariationOrder to fetch.
     */
    where?: VariationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationOrders to fetch.
     */
    orderBy?: VariationOrderOrderByWithRelationInput | VariationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationOrders.
     */
    cursor?: VariationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationOrders.
     */
    distinct?: VariationOrderScalarFieldEnum | VariationOrderScalarFieldEnum[]
  }

  /**
   * VariationOrder findMany
   */
  export type VariationOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * Filter, which VariationOrders to fetch.
     */
    where?: VariationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationOrders to fetch.
     */
    orderBy?: VariationOrderOrderByWithRelationInput | VariationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariationOrders.
     */
    cursor?: VariationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationOrders.
     */
    skip?: number
    distinct?: VariationOrderScalarFieldEnum | VariationOrderScalarFieldEnum[]
  }

  /**
   * VariationOrder create
   */
  export type VariationOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a VariationOrder.
     */
    data: XOR<VariationOrderCreateInput, VariationOrderUncheckedCreateInput>
  }

  /**
   * VariationOrder createMany
   */
  export type VariationOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariationOrders.
     */
    data: VariationOrderCreateManyInput | VariationOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariationOrder createManyAndReturn
   */
  export type VariationOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * The data used to create many VariationOrders.
     */
    data: VariationOrderCreateManyInput | VariationOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationOrder update
   */
  export type VariationOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a VariationOrder.
     */
    data: XOR<VariationOrderUpdateInput, VariationOrderUncheckedUpdateInput>
    /**
     * Choose, which VariationOrder to update.
     */
    where: VariationOrderWhereUniqueInput
  }

  /**
   * VariationOrder updateMany
   */
  export type VariationOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariationOrders.
     */
    data: XOR<VariationOrderUpdateManyMutationInput, VariationOrderUncheckedUpdateManyInput>
    /**
     * Filter which VariationOrders to update
     */
    where?: VariationOrderWhereInput
    /**
     * Limit how many VariationOrders to update.
     */
    limit?: number
  }

  /**
   * VariationOrder updateManyAndReturn
   */
  export type VariationOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * The data used to update VariationOrders.
     */
    data: XOR<VariationOrderUpdateManyMutationInput, VariationOrderUncheckedUpdateManyInput>
    /**
     * Filter which VariationOrders to update
     */
    where?: VariationOrderWhereInput
    /**
     * Limit how many VariationOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationOrder upsert
   */
  export type VariationOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the VariationOrder to update in case it exists.
     */
    where: VariationOrderWhereUniqueInput
    /**
     * In case the VariationOrder found by the `where` argument doesn't exist, create a new VariationOrder with this data.
     */
    create: XOR<VariationOrderCreateInput, VariationOrderUncheckedCreateInput>
    /**
     * In case the VariationOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariationOrderUpdateInput, VariationOrderUncheckedUpdateInput>
  }

  /**
   * VariationOrder delete
   */
  export type VariationOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
    /**
     * Filter which VariationOrder to delete.
     */
    where: VariationOrderWhereUniqueInput
  }

  /**
   * VariationOrder deleteMany
   */
  export type VariationOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationOrders to delete
     */
    where?: VariationOrderWhereInput
    /**
     * Limit how many VariationOrders to delete.
     */
    limit?: number
  }

  /**
   * VariationOrder without action
   */
  export type VariationOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationOrder
     */
    select?: VariationOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationOrder
     */
    omit?: VariationOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationOrderInclude<ExtArgs> | null
  }


  /**
   * Model IPC
   */

  export type AggregateIPC = {
    _count: IPCCountAggregateOutputType | null
    _avg: IPCAvgAggregateOutputType | null
    _sum: IPCSumAggregateOutputType | null
    _min: IPCMinAggregateOutputType | null
    _max: IPCMaxAggregateOutputType | null
  }

  export type IPCAvgAggregateOutputType = {
    id: number | null
    contractId: number | null
    currentValue: number | null
    cumulativeValue: number | null
    deductions: number | null
    netPayable: number | null
    submittedById: number | null
  }

  export type IPCSumAggregateOutputType = {
    id: number | null
    contractId: number | null
    currentValue: number | null
    cumulativeValue: number | null
    deductions: number | null
    netPayable: number | null
    submittedById: number | null
  }

  export type IPCMinAggregateOutputType = {
    id: number | null
    ipcNumber: string | null
    projectName: string | null
    contractId: number | null
    periodFrom: Date | null
    periodTo: Date | null
    currentValue: number | null
    cumulativeValue: number | null
    deductions: number | null
    netPayable: number | null
    status: $Enums.IPCStatus | null
    submittedById: number | null
    createdAt: Date | null
  }

  export type IPCMaxAggregateOutputType = {
    id: number | null
    ipcNumber: string | null
    projectName: string | null
    contractId: number | null
    periodFrom: Date | null
    periodTo: Date | null
    currentValue: number | null
    cumulativeValue: number | null
    deductions: number | null
    netPayable: number | null
    status: $Enums.IPCStatus | null
    submittedById: number | null
    createdAt: Date | null
  }

  export type IPCCountAggregateOutputType = {
    id: number
    ipcNumber: number
    projectName: number
    contractId: number
    periodFrom: number
    periodTo: number
    currentValue: number
    cumulativeValue: number
    deductions: number
    netPayable: number
    status: number
    submittedById: number
    createdAt: number
    _all: number
  }


  export type IPCAvgAggregateInputType = {
    id?: true
    contractId?: true
    currentValue?: true
    cumulativeValue?: true
    deductions?: true
    netPayable?: true
    submittedById?: true
  }

  export type IPCSumAggregateInputType = {
    id?: true
    contractId?: true
    currentValue?: true
    cumulativeValue?: true
    deductions?: true
    netPayable?: true
    submittedById?: true
  }

  export type IPCMinAggregateInputType = {
    id?: true
    ipcNumber?: true
    projectName?: true
    contractId?: true
    periodFrom?: true
    periodTo?: true
    currentValue?: true
    cumulativeValue?: true
    deductions?: true
    netPayable?: true
    status?: true
    submittedById?: true
    createdAt?: true
  }

  export type IPCMaxAggregateInputType = {
    id?: true
    ipcNumber?: true
    projectName?: true
    contractId?: true
    periodFrom?: true
    periodTo?: true
    currentValue?: true
    cumulativeValue?: true
    deductions?: true
    netPayable?: true
    status?: true
    submittedById?: true
    createdAt?: true
  }

  export type IPCCountAggregateInputType = {
    id?: true
    ipcNumber?: true
    projectName?: true
    contractId?: true
    periodFrom?: true
    periodTo?: true
    currentValue?: true
    cumulativeValue?: true
    deductions?: true
    netPayable?: true
    status?: true
    submittedById?: true
    createdAt?: true
    _all?: true
  }

  export type IPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPC to aggregate.
     */
    where?: IPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPCS to fetch.
     */
    orderBy?: IPCOrderByWithRelationInput | IPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IPCS
    **/
    _count?: true | IPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IPCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IPCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IPCMaxAggregateInputType
  }

  export type GetIPCAggregateType<T extends IPCAggregateArgs> = {
        [P in keyof T & keyof AggregateIPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIPC[P]>
      : GetScalarType<T[P], AggregateIPC[P]>
  }




  export type IPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IPCWhereInput
    orderBy?: IPCOrderByWithAggregationInput | IPCOrderByWithAggregationInput[]
    by: IPCScalarFieldEnum[] | IPCScalarFieldEnum
    having?: IPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IPCCountAggregateInputType | true
    _avg?: IPCAvgAggregateInputType
    _sum?: IPCSumAggregateInputType
    _min?: IPCMinAggregateInputType
    _max?: IPCMaxAggregateInputType
  }

  export type IPCGroupByOutputType = {
    id: number
    ipcNumber: string
    projectName: string | null
    contractId: number
    periodFrom: Date | null
    periodTo: Date | null
    currentValue: number
    cumulativeValue: number | null
    deductions: number | null
    netPayable: number | null
    status: $Enums.IPCStatus
    submittedById: number
    createdAt: Date
    _count: IPCCountAggregateOutputType | null
    _avg: IPCAvgAggregateOutputType | null
    _sum: IPCSumAggregateOutputType | null
    _min: IPCMinAggregateOutputType | null
    _max: IPCMaxAggregateOutputType | null
  }

  type GetIPCGroupByPayload<T extends IPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IPCGroupByOutputType[P]>
            : GetScalarType<T[P], IPCGroupByOutputType[P]>
        }
      >
    >


  export type IPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipcNumber?: boolean
    projectName?: boolean
    contractId?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    currentValue?: boolean
    cumulativeValue?: boolean
    deductions?: boolean
    netPayable?: boolean
    status?: boolean
    submittedById?: boolean
    createdAt?: boolean
    attachments?: boolean | IPC$attachmentsArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | IPCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iPC"]>

  export type IPCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipcNumber?: boolean
    projectName?: boolean
    contractId?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    currentValue?: boolean
    cumulativeValue?: boolean
    deductions?: boolean
    netPayable?: boolean
    status?: boolean
    submittedById?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iPC"]>

  export type IPCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipcNumber?: boolean
    projectName?: boolean
    contractId?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    currentValue?: boolean
    cumulativeValue?: boolean
    deductions?: boolean
    netPayable?: boolean
    status?: boolean
    submittedById?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iPC"]>

  export type IPCSelectScalar = {
    id?: boolean
    ipcNumber?: boolean
    projectName?: boolean
    contractId?: boolean
    periodFrom?: boolean
    periodTo?: boolean
    currentValue?: boolean
    cumulativeValue?: boolean
    deductions?: boolean
    netPayable?: boolean
    status?: boolean
    submittedById?: boolean
    createdAt?: boolean
  }

  export type IPCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ipcNumber" | "projectName" | "contractId" | "periodFrom" | "periodTo" | "currentValue" | "cumulativeValue" | "deductions" | "netPayable" | "status" | "submittedById" | "createdAt", ExtArgs["result"]["iPC"]>
  export type IPCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | IPC$attachmentsArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | IPCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IPCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IPCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IPC"
    objects: {
      attachments: Prisma.$DocumentPayload<ExtArgs>[]
      contract: Prisma.$ContractPayload<ExtArgs>
      submittedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ipcNumber: string
      projectName: string | null
      contractId: number
      periodFrom: Date | null
      periodTo: Date | null
      currentValue: number
      cumulativeValue: number | null
      deductions: number | null
      netPayable: number | null
      status: $Enums.IPCStatus
      submittedById: number
      createdAt: Date
    }, ExtArgs["result"]["iPC"]>
    composites: {}
  }

  type IPCGetPayload<S extends boolean | null | undefined | IPCDefaultArgs> = $Result.GetResult<Prisma.$IPCPayload, S>

  type IPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IPCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IPCCountAggregateInputType | true
    }

  export interface IPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IPC'], meta: { name: 'IPC' } }
    /**
     * Find zero or one IPC that matches the filter.
     * @param {IPCFindUniqueArgs} args - Arguments to find a IPC
     * @example
     * // Get one IPC
     * const iPC = await prisma.iPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IPCFindUniqueArgs>(args: SelectSubset<T, IPCFindUniqueArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IPC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IPCFindUniqueOrThrowArgs} args - Arguments to find a IPC
     * @example
     * // Get one IPC
     * const iPC = await prisma.iPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IPCFindUniqueOrThrowArgs>(args: SelectSubset<T, IPCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPCFindFirstArgs} args - Arguments to find a IPC
     * @example
     * // Get one IPC
     * const iPC = await prisma.iPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IPCFindFirstArgs>(args?: SelectSubset<T, IPCFindFirstArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPCFindFirstOrThrowArgs} args - Arguments to find a IPC
     * @example
     * // Get one IPC
     * const iPC = await prisma.iPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IPCFindFirstOrThrowArgs>(args?: SelectSubset<T, IPCFindFirstOrThrowArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IPCS
     * const iPCS = await prisma.iPC.findMany()
     * 
     * // Get first 10 IPCS
     * const iPCS = await prisma.iPC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iPCWithIdOnly = await prisma.iPC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IPCFindManyArgs>(args?: SelectSubset<T, IPCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IPC.
     * @param {IPCCreateArgs} args - Arguments to create a IPC.
     * @example
     * // Create one IPC
     * const IPC = await prisma.iPC.create({
     *   data: {
     *     // ... data to create a IPC
     *   }
     * })
     * 
     */
    create<T extends IPCCreateArgs>(args: SelectSubset<T, IPCCreateArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IPCS.
     * @param {IPCCreateManyArgs} args - Arguments to create many IPCS.
     * @example
     * // Create many IPCS
     * const iPC = await prisma.iPC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IPCCreateManyArgs>(args?: SelectSubset<T, IPCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IPCS and returns the data saved in the database.
     * @param {IPCCreateManyAndReturnArgs} args - Arguments to create many IPCS.
     * @example
     * // Create many IPCS
     * const iPC = await prisma.iPC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IPCS and only return the `id`
     * const iPCWithIdOnly = await prisma.iPC.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IPCCreateManyAndReturnArgs>(args?: SelectSubset<T, IPCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IPC.
     * @param {IPCDeleteArgs} args - Arguments to delete one IPC.
     * @example
     * // Delete one IPC
     * const IPC = await prisma.iPC.delete({
     *   where: {
     *     // ... filter to delete one IPC
     *   }
     * })
     * 
     */
    delete<T extends IPCDeleteArgs>(args: SelectSubset<T, IPCDeleteArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IPC.
     * @param {IPCUpdateArgs} args - Arguments to update one IPC.
     * @example
     * // Update one IPC
     * const iPC = await prisma.iPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IPCUpdateArgs>(args: SelectSubset<T, IPCUpdateArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IPCS.
     * @param {IPCDeleteManyArgs} args - Arguments to filter IPCS to delete.
     * @example
     * // Delete a few IPCS
     * const { count } = await prisma.iPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IPCDeleteManyArgs>(args?: SelectSubset<T, IPCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IPCS
     * const iPC = await prisma.iPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IPCUpdateManyArgs>(args: SelectSubset<T, IPCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IPCS and returns the data updated in the database.
     * @param {IPCUpdateManyAndReturnArgs} args - Arguments to update many IPCS.
     * @example
     * // Update many IPCS
     * const iPC = await prisma.iPC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IPCS and only return the `id`
     * const iPCWithIdOnly = await prisma.iPC.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IPCUpdateManyAndReturnArgs>(args: SelectSubset<T, IPCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IPC.
     * @param {IPCUpsertArgs} args - Arguments to update or create a IPC.
     * @example
     * // Update or create a IPC
     * const iPC = await prisma.iPC.upsert({
     *   create: {
     *     // ... data to create a IPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IPC we want to update
     *   }
     * })
     */
    upsert<T extends IPCUpsertArgs>(args: SelectSubset<T, IPCUpsertArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPCCountArgs} args - Arguments to filter IPCS to count.
     * @example
     * // Count the number of IPCS
     * const count = await prisma.iPC.count({
     *   where: {
     *     // ... the filter for the IPCS we want to count
     *   }
     * })
    **/
    count<T extends IPCCountArgs>(
      args?: Subset<T, IPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IPCAggregateArgs>(args: Subset<T, IPCAggregateArgs>): Prisma.PrismaPromise<GetIPCAggregateType<T>>

    /**
     * Group by IPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IPCGroupByArgs['orderBy'] }
        : { orderBy?: IPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IPC model
   */
  readonly fields: IPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends IPC$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, IPC$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submittedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IPC model
   */
  interface IPCFieldRefs {
    readonly id: FieldRef<"IPC", 'Int'>
    readonly ipcNumber: FieldRef<"IPC", 'String'>
    readonly projectName: FieldRef<"IPC", 'String'>
    readonly contractId: FieldRef<"IPC", 'Int'>
    readonly periodFrom: FieldRef<"IPC", 'DateTime'>
    readonly periodTo: FieldRef<"IPC", 'DateTime'>
    readonly currentValue: FieldRef<"IPC", 'Float'>
    readonly cumulativeValue: FieldRef<"IPC", 'Float'>
    readonly deductions: FieldRef<"IPC", 'Float'>
    readonly netPayable: FieldRef<"IPC", 'Float'>
    readonly status: FieldRef<"IPC", 'IPCStatus'>
    readonly submittedById: FieldRef<"IPC", 'Int'>
    readonly createdAt: FieldRef<"IPC", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IPC findUnique
   */
  export type IPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * Filter, which IPC to fetch.
     */
    where: IPCWhereUniqueInput
  }

  /**
   * IPC findUniqueOrThrow
   */
  export type IPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * Filter, which IPC to fetch.
     */
    where: IPCWhereUniqueInput
  }

  /**
   * IPC findFirst
   */
  export type IPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * Filter, which IPC to fetch.
     */
    where?: IPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPCS to fetch.
     */
    orderBy?: IPCOrderByWithRelationInput | IPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPCS.
     */
    cursor?: IPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPCS.
     */
    distinct?: IPCScalarFieldEnum | IPCScalarFieldEnum[]
  }

  /**
   * IPC findFirstOrThrow
   */
  export type IPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * Filter, which IPC to fetch.
     */
    where?: IPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPCS to fetch.
     */
    orderBy?: IPCOrderByWithRelationInput | IPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IPCS.
     */
    cursor?: IPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IPCS.
     */
    distinct?: IPCScalarFieldEnum | IPCScalarFieldEnum[]
  }

  /**
   * IPC findMany
   */
  export type IPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * Filter, which IPCS to fetch.
     */
    where?: IPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IPCS to fetch.
     */
    orderBy?: IPCOrderByWithRelationInput | IPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IPCS.
     */
    cursor?: IPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IPCS.
     */
    skip?: number
    distinct?: IPCScalarFieldEnum | IPCScalarFieldEnum[]
  }

  /**
   * IPC create
   */
  export type IPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * The data needed to create a IPC.
     */
    data: XOR<IPCCreateInput, IPCUncheckedCreateInput>
  }

  /**
   * IPC createMany
   */
  export type IPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IPCS.
     */
    data: IPCCreateManyInput | IPCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IPC createManyAndReturn
   */
  export type IPCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * The data used to create many IPCS.
     */
    data: IPCCreateManyInput | IPCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IPC update
   */
  export type IPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * The data needed to update a IPC.
     */
    data: XOR<IPCUpdateInput, IPCUncheckedUpdateInput>
    /**
     * Choose, which IPC to update.
     */
    where: IPCWhereUniqueInput
  }

  /**
   * IPC updateMany
   */
  export type IPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IPCS.
     */
    data: XOR<IPCUpdateManyMutationInput, IPCUncheckedUpdateManyInput>
    /**
     * Filter which IPCS to update
     */
    where?: IPCWhereInput
    /**
     * Limit how many IPCS to update.
     */
    limit?: number
  }

  /**
   * IPC updateManyAndReturn
   */
  export type IPCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * The data used to update IPCS.
     */
    data: XOR<IPCUpdateManyMutationInput, IPCUncheckedUpdateManyInput>
    /**
     * Filter which IPCS to update
     */
    where?: IPCWhereInput
    /**
     * Limit how many IPCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IPC upsert
   */
  export type IPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * The filter to search for the IPC to update in case it exists.
     */
    where: IPCWhereUniqueInput
    /**
     * In case the IPC found by the `where` argument doesn't exist, create a new IPC with this data.
     */
    create: XOR<IPCCreateInput, IPCUncheckedCreateInput>
    /**
     * In case the IPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IPCUpdateInput, IPCUncheckedUpdateInput>
  }

  /**
   * IPC delete
   */
  export type IPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    /**
     * Filter which IPC to delete.
     */
    where: IPCWhereUniqueInput
  }

  /**
   * IPC deleteMany
   */
  export type IPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IPCS to delete
     */
    where?: IPCWhereInput
    /**
     * Limit how many IPCS to delete.
     */
    limit?: number
  }

  /**
   * IPC.attachments
   */
  export type IPC$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * IPC without action
   */
  export type IPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    size: number | null
    uploadedById: number | null
    ipcId: number | null
    contractId: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    size: number | null
    uploadedById: number | null
    ipcId: number | null
    contractId: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    fileName: string | null
    fileUrl: string | null
    url: string | null
    mimeType: string | null
    size: number | null
    uploadedById: number | null
    uploadedAt: Date | null
    ipcId: number | null
    contractId: number | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    fileName: string | null
    fileUrl: string | null
    url: string | null
    mimeType: string | null
    size: number | null
    uploadedById: number | null
    uploadedAt: Date | null
    ipcId: number | null
    contractId: number | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    fileName: number
    fileUrl: number
    url: number
    mimeType: number
    size: number
    uploadedById: number
    uploadedAt: number
    ipcId: number
    contractId: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    size?: true
    uploadedById?: true
    ipcId?: true
    contractId?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    size?: true
    uploadedById?: true
    ipcId?: true
    contractId?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    url?: true
    mimeType?: true
    size?: true
    uploadedById?: true
    uploadedAt?: true
    ipcId?: true
    contractId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    url?: true
    mimeType?: true
    size?: true
    uploadedById?: true
    uploadedAt?: true
    ipcId?: true
    contractId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    url?: true
    mimeType?: true
    size?: true
    uploadedById?: true
    uploadedAt?: true
    ipcId?: true
    contractId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    fileName: string
    fileUrl: string
    url: string
    mimeType: string | null
    size: number | null
    uploadedById: number | null
    uploadedAt: Date
    ipcId: number | null
    contractId: number | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    url?: boolean
    mimeType?: boolean
    size?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    ipcId?: boolean
    contractId?: boolean
    contract?: boolean | Document$contractArgs<ExtArgs>
    ipc?: boolean | Document$ipcArgs<ExtArgs>
    uploadedBy?: boolean | Document$uploadedByArgs<ExtArgs>
    rfqAttachments?: boolean | Document$rfqAttachmentsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    url?: boolean
    mimeType?: boolean
    size?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    ipcId?: boolean
    contractId?: boolean
    contract?: boolean | Document$contractArgs<ExtArgs>
    ipc?: boolean | Document$ipcArgs<ExtArgs>
    uploadedBy?: boolean | Document$uploadedByArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    url?: boolean
    mimeType?: boolean
    size?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    ipcId?: boolean
    contractId?: boolean
    contract?: boolean | Document$contractArgs<ExtArgs>
    ipc?: boolean | Document$ipcArgs<ExtArgs>
    uploadedBy?: boolean | Document$uploadedByArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    url?: boolean
    mimeType?: boolean
    size?: boolean
    uploadedById?: boolean
    uploadedAt?: boolean
    ipcId?: boolean
    contractId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileName" | "fileUrl" | "url" | "mimeType" | "size" | "uploadedById" | "uploadedAt" | "ipcId" | "contractId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | Document$contractArgs<ExtArgs>
    ipc?: boolean | Document$ipcArgs<ExtArgs>
    uploadedBy?: boolean | Document$uploadedByArgs<ExtArgs>
    rfqAttachments?: boolean | Document$rfqAttachmentsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | Document$contractArgs<ExtArgs>
    ipc?: boolean | Document$ipcArgs<ExtArgs>
    uploadedBy?: boolean | Document$uploadedByArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | Document$contractArgs<ExtArgs>
    ipc?: boolean | Document$ipcArgs<ExtArgs>
    uploadedBy?: boolean | Document$uploadedByArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs> | null
      ipc: Prisma.$IPCPayload<ExtArgs> | null
      uploadedBy: Prisma.$UserPayload<ExtArgs> | null
      rfqAttachments: Prisma.$RFQPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fileName: string
      fileUrl: string
      url: string
      mimeType: string | null
      size: number | null
      uploadedById: number | null
      uploadedAt: Date
      ipcId: number | null
      contractId: number | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends Document$contractArgs<ExtArgs> = {}>(args?: Subset<T, Document$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ipc<T extends Document$ipcArgs<ExtArgs> = {}>(args?: Subset<T, Document$ipcArgs<ExtArgs>>): Prisma__IPCClient<$Result.GetResult<Prisma.$IPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends Document$uploadedByArgs<ExtArgs> = {}>(args?: Subset<T, Document$uploadedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rfqAttachments<T extends Document$rfqAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Document$rfqAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RFQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly uploadedById: FieldRef<"Document", 'Int'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
    readonly ipcId: FieldRef<"Document", 'Int'>
    readonly contractId: FieldRef<"Document", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.contract
   */
  export type Document$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * Document.ipc
   */
  export type Document$ipcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IPC
     */
    select?: IPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IPC
     */
    omit?: IPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IPCInclude<ExtArgs> | null
    where?: IPCWhereInput
  }

  /**
   * Document.uploadedBy
   */
  export type Document$uploadedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Document.rfqAttachments
   */
  export type Document$rfqAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RFQ
     */
    select?: RFQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RFQ
     */
    omit?: RFQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RFQInclude<ExtArgs> | null
    where?: RFQWhereInput
    orderBy?: RFQOrderByWithRelationInput | RFQOrderByWithRelationInput[]
    cursor?: RFQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RFQScalarFieldEnum | RFQScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Approval
   */

  export type AggregateApproval = {
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  export type ApprovalAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    approverId: number | null
    sequence: number | null
  }

  export type ApprovalSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    approverId: number | null
    sequence: number | null
  }

  export type ApprovalMinAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    approverId: number | null
    sequence: number | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    createdAt: Date | null
    actedAt: Date | null
  }

  export type ApprovalMaxAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    approverId: number | null
    sequence: number | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    createdAt: Date | null
    actedAt: Date | null
  }

  export type ApprovalCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    approverId: number
    sequence: number
    status: number
    comment: number
    createdAt: number
    actedAt: number
    _all: number
  }


  export type ApprovalAvgAggregateInputType = {
    id?: true
    entityId?: true
    approverId?: true
    sequence?: true
  }

  export type ApprovalSumAggregateInputType = {
    id?: true
    entityId?: true
    approverId?: true
    sequence?: true
  }

  export type ApprovalMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    approverId?: true
    sequence?: true
    status?: true
    comment?: true
    createdAt?: true
    actedAt?: true
  }

  export type ApprovalMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    approverId?: true
    sequence?: true
    status?: true
    comment?: true
    createdAt?: true
    actedAt?: true
  }

  export type ApprovalCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    approverId?: true
    sequence?: true
    status?: true
    comment?: true
    createdAt?: true
    actedAt?: true
    _all?: true
  }

  export type ApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approval to aggregate.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Approvals
    **/
    _count?: true | ApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalMaxAggregateInputType
  }

  export type GetApprovalAggregateType<T extends ApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApproval[P]>
      : GetScalarType<T[P], AggregateApproval[P]>
  }




  export type ApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithAggregationInput | ApprovalOrderByWithAggregationInput[]
    by: ApprovalScalarFieldEnum[] | ApprovalScalarFieldEnum
    having?: ApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalCountAggregateInputType | true
    _avg?: ApprovalAvgAggregateInputType
    _sum?: ApprovalSumAggregateInputType
    _min?: ApprovalMinAggregateInputType
    _max?: ApprovalMaxAggregateInputType
  }

  export type ApprovalGroupByOutputType = {
    id: number
    entityType: string
    entityId: number
    approverId: number
    sequence: number
    status: $Enums.ApprovalStatus
    comment: string | null
    createdAt: Date
    actedAt: Date | null
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  type GetApprovalGroupByPayload<T extends ApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    approverId?: boolean
    sequence?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    actedAt?: boolean
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    approverId?: boolean
    sequence?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    actedAt?: boolean
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    approverId?: boolean
    sequence?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    actedAt?: boolean
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    approverId?: boolean
    sequence?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    actedAt?: boolean
  }

  export type ApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "approverId" | "sequence" | "status" | "comment" | "createdAt" | "actedAt", ExtArgs["result"]["approval"]>
  export type ApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Approval"
    objects: {
      approver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: string
      entityId: number
      approverId: number
      sequence: number
      status: $Enums.ApprovalStatus
      comment: string | null
      createdAt: Date
      actedAt: Date | null
    }, ExtArgs["result"]["approval"]>
    composites: {}
  }

  type ApprovalGetPayload<S extends boolean | null | undefined | ApprovalDefaultArgs> = $Result.GetResult<Prisma.$ApprovalPayload, S>

  type ApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovalCountAggregateInputType | true
    }

  export interface ApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Approval'], meta: { name: 'Approval' } }
    /**
     * Find zero or one Approval that matches the filter.
     * @param {ApprovalFindUniqueArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalFindUniqueArgs>(args: SelectSubset<T, ApprovalFindUniqueArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Approval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovalFindUniqueOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalFindFirstArgs>(args?: SelectSubset<T, ApprovalFindFirstArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Approval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Approvals
     * const approvals = await prisma.approval.findMany()
     * 
     * // Get first 10 Approvals
     * const approvals = await prisma.approval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWithIdOnly = await prisma.approval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalFindManyArgs>(args?: SelectSubset<T, ApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Approval.
     * @param {ApprovalCreateArgs} args - Arguments to create a Approval.
     * @example
     * // Create one Approval
     * const Approval = await prisma.approval.create({
     *   data: {
     *     // ... data to create a Approval
     *   }
     * })
     * 
     */
    create<T extends ApprovalCreateArgs>(args: SelectSubset<T, ApprovalCreateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Approvals.
     * @param {ApprovalCreateManyArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalCreateManyArgs>(args?: SelectSubset<T, ApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Approvals and returns the data saved in the database.
     * @param {ApprovalCreateManyAndReturnArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Approvals and only return the `id`
     * const approvalWithIdOnly = await prisma.approval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Approval.
     * @param {ApprovalDeleteArgs} args - Arguments to delete one Approval.
     * @example
     * // Delete one Approval
     * const Approval = await prisma.approval.delete({
     *   where: {
     *     // ... filter to delete one Approval
     *   }
     * })
     * 
     */
    delete<T extends ApprovalDeleteArgs>(args: SelectSubset<T, ApprovalDeleteArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Approval.
     * @param {ApprovalUpdateArgs} args - Arguments to update one Approval.
     * @example
     * // Update one Approval
     * const approval = await prisma.approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalUpdateArgs>(args: SelectSubset<T, ApprovalUpdateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Approvals.
     * @param {ApprovalDeleteManyArgs} args - Arguments to filter Approvals to delete.
     * @example
     * // Delete a few Approvals
     * const { count } = await prisma.approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalDeleteManyArgs>(args?: SelectSubset<T, ApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalUpdateManyArgs>(args: SelectSubset<T, ApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals and returns the data updated in the database.
     * @param {ApprovalUpdateManyAndReturnArgs} args - Arguments to update many Approvals.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Approvals and only return the `id`
     * const approvalWithIdOnly = await prisma.approval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApprovalUpdateManyAndReturnArgs>(args: SelectSubset<T, ApprovalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Approval.
     * @param {ApprovalUpsertArgs} args - Arguments to update or create a Approval.
     * @example
     * // Update or create a Approval
     * const approval = await prisma.approval.upsert({
     *   create: {
     *     // ... data to create a Approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Approval we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalUpsertArgs>(args: SelectSubset<T, ApprovalUpsertArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalCountArgs} args - Arguments to filter Approvals to count.
     * @example
     * // Count the number of Approvals
     * const count = await prisma.approval.count({
     *   where: {
     *     // ... the filter for the Approvals we want to count
     *   }
     * })
    **/
    count<T extends ApprovalCountArgs>(
      args?: Subset<T, ApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalAggregateArgs>(args: Subset<T, ApprovalAggregateArgs>): Prisma.PrismaPromise<GetApprovalAggregateType<T>>

    /**
     * Group by Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Approval model
   */
  readonly fields: ApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Approval model
   */
  interface ApprovalFieldRefs {
    readonly id: FieldRef<"Approval", 'Int'>
    readonly entityType: FieldRef<"Approval", 'String'>
    readonly entityId: FieldRef<"Approval", 'Int'>
    readonly approverId: FieldRef<"Approval", 'Int'>
    readonly sequence: FieldRef<"Approval", 'Int'>
    readonly status: FieldRef<"Approval", 'ApprovalStatus'>
    readonly comment: FieldRef<"Approval", 'String'>
    readonly createdAt: FieldRef<"Approval", 'DateTime'>
    readonly actedAt: FieldRef<"Approval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Approval findUnique
   */
  export type ApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findUniqueOrThrow
   */
  export type ApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findFirst
   */
  export type ApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findFirstOrThrow
   */
  export type ApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findMany
   */
  export type ApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approvals to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval create
   */
  export type ApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a Approval.
     */
    data: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
  }

  /**
   * Approval createMany
   */
  export type ApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Approval createManyAndReturn
   */
  export type ApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Approval update
   */
  export type ApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a Approval.
     */
    data: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
    /**
     * Choose, which Approval to update.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval updateMany
   */
  export type ApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
    /**
     * Limit how many Approvals to update.
     */
    limit?: number
  }

  /**
   * Approval updateManyAndReturn
   */
  export type ApprovalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
    /**
     * Limit how many Approvals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Approval upsert
   */
  export type ApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the Approval to update in case it exists.
     */
    where: ApprovalWhereUniqueInput
    /**
     * In case the Approval found by the `where` argument doesn't exist, create a new Approval with this data.
     */
    create: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
    /**
     * In case the Approval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
  }

  /**
   * Approval delete
   */
  export type ApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter which Approval to delete.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval deleteMany
   */
  export type ApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approvals to delete
     */
    where?: ApprovalWhereInput
    /**
     * Limit how many Approvals to delete.
     */
    limit?: number
  }

  /**
   * Approval without action
   */
  export type ApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entity: string | null
    entityId: number | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entity: string | null
    entityId: number | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    data: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number | null
    action: string
    entity: string | null
    entityId: number | null
    data: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "data" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      action: string
      entity: string | null
      entityId: number | null
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'Int'>
    readonly data: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    body: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    title: string
    body: string | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "body" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      body: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    email: 'email',
    password: 'password',
    roleId: 'roleId',
    vendorId: 'vendorId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accessCode: 'accessCode',
    status: 'status'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    desc: 'desc',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    contactName: 'contactName',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    status: 'status',
    address: 'address',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VendorCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorCategoryScalarFieldEnum = (typeof VendorCategoryScalarFieldEnum)[keyof typeof VendorCategoryScalarFieldEnum]


  export const VendorDocumentScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    docType: 'docType',
    url: 'url',
    fileName: 'fileName',
    expiryDate: 'expiryDate',
    uploadedAt: 'uploadedAt'
  };

  export type VendorDocumentScalarFieldEnum = (typeof VendorDocumentScalarFieldEnum)[keyof typeof VendorDocumentScalarFieldEnum]


  export const CSI_MaterialScalarFieldEnum: {
    id: 'id',
    csiCode: 'csiCode',
    name: 'name',
    unit: 'unit',
    defaultVendorId: 'defaultVendorId'
  };

  export type CSI_MaterialScalarFieldEnum = (typeof CSI_MaterialScalarFieldEnum)[keyof typeof CSI_MaterialScalarFieldEnum]


  export const PriceEntryScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    vendorId: 'vendorId',
    unitPrice: 'unitPrice',
    currency: 'currency',
    createdAt: 'createdAt',
    effectiveDate: 'effectiveDate',
    expiryDate: 'expiryDate',
    updatedAt: 'updatedAt'
  };

  export type PriceEntryScalarFieldEnum = (typeof PriceEntryScalarFieldEnum)[keyof typeof PriceEntryScalarFieldEnum]


  export const RFQScalarFieldEnum: {
    id: 'id',
    rfqNumber: 'rfqNumber',
    projectName: 'projectName',
    packageScope: 'packageScope',
    itemDesc: 'itemDesc',
    csiCode: 'csiCode',
    estimatedUnitPrice: 'estimatedUnitPrice',
    requiredDate: 'requiredDate',
    targetSubmissionDate: 'targetSubmissionDate',
    currency: 'currency',
    createdById: 'createdById',
    status: 'status',
    createdAt: 'createdAt',
    description: 'description',
    dueDate: 'dueDate',
    title: 'title',
    updatedAt: 'updatedAt'
  };

  export type RFQScalarFieldEnum = (typeof RFQScalarFieldEnum)[keyof typeof RFQScalarFieldEnum]


  export const RFQSubmissionScalarFieldEnum: {
    id: 'id',
    rfqId: 'rfqId',
    vendorId: 'vendorId',
    submittedAt: 'submittedAt',
    totalValue: 'totalValue',
    currency: 'currency',
    docUrl: 'docUrl',
    items: 'items',
    status: 'status',
    totalAmount: 'totalAmount'
  };

  export type RFQSubmissionScalarFieldEnum = (typeof RFQSubmissionScalarFieldEnum)[keyof typeof RFQSubmissionScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    submissionId: 'submissionId',
    evaluatorId: 'evaluatorId',
    technicalScore: 'technicalScore',
    financialScore: 'financialScore',
    experienceScore: 'experienceScore',
    responsiveness: 'responsiveness',
    otherScore: 'otherScore',
    totalScore: 'totalScore',
    comments: 'comments',
    createdAt: 'createdAt'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    contractNumber: 'contractNumber',
    rfqId: 'rfqId',
    vendorId: 'vendorId',
    contractValue: 'contractValue',
    currency: 'currency',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const VariationOrderScalarFieldEnum: {
    id: 'id',
    voRef: 'voRef',
    contractId: 'contractId',
    description: 'description',
    costImpact: 'costImpact',
    timeImpact: 'timeImpact',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type VariationOrderScalarFieldEnum = (typeof VariationOrderScalarFieldEnum)[keyof typeof VariationOrderScalarFieldEnum]


  export const IPCScalarFieldEnum: {
    id: 'id',
    ipcNumber: 'ipcNumber',
    projectName: 'projectName',
    contractId: 'contractId',
    periodFrom: 'periodFrom',
    periodTo: 'periodTo',
    currentValue: 'currentValue',
    cumulativeValue: 'cumulativeValue',
    deductions: 'deductions',
    netPayable: 'netPayable',
    status: 'status',
    submittedById: 'submittedById',
    createdAt: 'createdAt'
  };

  export type IPCScalarFieldEnum = (typeof IPCScalarFieldEnum)[keyof typeof IPCScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    url: 'url',
    mimeType: 'mimeType',
    size: 'size',
    uploadedById: 'uploadedById',
    uploadedAt: 'uploadedAt',
    ipcId: 'ipcId',
    contractId: 'contractId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ApprovalScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    approverId: 'approverId',
    sequence: 'sequence',
    status: 'status',
    comment: 'comment',
    createdAt: 'createdAt',
    actedAt: 'actedAt'
  };

  export type ApprovalScalarFieldEnum = (typeof ApprovalScalarFieldEnum)[keyof typeof ApprovalScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    body: 'body',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'VendorStatus'
   */
  export type EnumVendorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorStatus'>
    


  /**
   * Reference to a field of type 'VendorStatus[]'
   */
  export type ListEnumVendorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VendorStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RFQStatus'
   */
  export type EnumRFQStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RFQStatus'>
    


  /**
   * Reference to a field of type 'RFQStatus[]'
   */
  export type ListEnumRFQStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RFQStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'IPCStatus'
   */
  export type EnumIPCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IPCStatus'>
    


  /**
   * Reference to a field of type 'IPCStatus[]'
   */
  export type ListEnumIPCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IPCStatus[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    uuid?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    vendorId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accessCode?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    approvals?: ApprovalListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    documents?: DocumentListRelationFilter
    evaluations?: EvaluationListRelationFilter
    ipcs?: IPCListRelationFilter
    notifications?: NotificationListRelationFilter
    rfqs?: RFQListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessCode?: SortOrderInput | SortOrder
    status?: SortOrder
    approvals?: ApprovalOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    ipcs?: IPCOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    rfqs?: RFQOrderByRelationAggregateInput
    role?: RoleOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    vendorId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accessCode?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    approvals?: ApprovalListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    documents?: DocumentListRelationFilter
    evaluations?: EvaluationListRelationFilter
    ipcs?: IPCListRelationFilter
    notifications?: NotificationListRelationFilter
    rfqs?: RFQListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
  }, "id" | "uuid" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessCode?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    uuid?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    roleId?: IntWithAggregatesFilter<"User"> | number
    vendorId?: IntNullableWithAggregatesFilter<"User"> | number | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    accessCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: StringWithAggregatesFilter<"User"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    desc?: StringNullableFilter<"Role"> | string | null
    name?: StringFilter<"Role"> | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    desc?: SortOrderInput | SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    desc?: StringNullableFilter<"Role"> | string | null
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    desc?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    desc?: StringNullableWithAggregatesFilter<"Role"> | string | null
    name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: IntFilter<"Vendor"> | number
    code?: StringNullableFilter<"Vendor"> | string | null
    name?: StringFilter<"Vendor"> | string
    contactName?: StringNullableFilter<"Vendor"> | string | null
    contactEmail?: StringNullableFilter<"Vendor"> | string | null
    contactPhone?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    address?: StringNullableFilter<"Vendor"> | string | null
    country?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    materials?: CSI_MaterialListRelationFilter
    contracts?: ContractListRelationFilter
    priceEntries?: PriceEntryListRelationFilter
    submissions?: RFQSubmissionListRelationFilter
    users?: UserListRelationFilter
    documents?: VendorDocumentListRelationFilter
    categories?: VendorCategoryListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    materials?: CSI_MaterialOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    priceEntries?: PriceEntryOrderByRelationAggregateInput
    submissions?: RFQSubmissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    documents?: VendorDocumentOrderByRelationAggregateInput
    categories?: VendorCategoryOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    contactName?: StringNullableFilter<"Vendor"> | string | null
    contactEmail?: StringNullableFilter<"Vendor"> | string | null
    contactPhone?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    address?: StringNullableFilter<"Vendor"> | string | null
    country?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    materials?: CSI_MaterialListRelationFilter
    contracts?: ContractListRelationFilter
    priceEntries?: PriceEntryListRelationFilter
    submissions?: RFQSubmissionListRelationFilter
    users?: UserListRelationFilter
    documents?: VendorDocumentListRelationFilter
    categories?: VendorCategoryListRelationFilter
  }, "id" | "code">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendor"> | number
    code?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    name?: StringWithAggregatesFilter<"Vendor"> | string
    contactName?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    status?: EnumVendorStatusWithAggregatesFilter<"Vendor"> | $Enums.VendorStatus
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    country?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type VendorCategoryWhereInput = {
    AND?: VendorCategoryWhereInput | VendorCategoryWhereInput[]
    OR?: VendorCategoryWhereInput[]
    NOT?: VendorCategoryWhereInput | VendorCategoryWhereInput[]
    id?: IntFilter<"VendorCategory"> | number
    name?: StringFilter<"VendorCategory"> | string
    createdAt?: DateTimeFilter<"VendorCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VendorCategory"> | Date | string
    vendors?: VendorListRelationFilter
  }

  export type VendorCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendors?: VendorOrderByRelationAggregateInput
  }

  export type VendorCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: VendorCategoryWhereInput | VendorCategoryWhereInput[]
    OR?: VendorCategoryWhereInput[]
    NOT?: VendorCategoryWhereInput | VendorCategoryWhereInput[]
    createdAt?: DateTimeFilter<"VendorCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VendorCategory"> | Date | string
    vendors?: VendorListRelationFilter
  }, "id" | "name">

  export type VendorCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCategoryCountOrderByAggregateInput
    _avg?: VendorCategoryAvgOrderByAggregateInput
    _max?: VendorCategoryMaxOrderByAggregateInput
    _min?: VendorCategoryMinOrderByAggregateInput
    _sum?: VendorCategorySumOrderByAggregateInput
  }

  export type VendorCategoryScalarWhereWithAggregatesInput = {
    AND?: VendorCategoryScalarWhereWithAggregatesInput | VendorCategoryScalarWhereWithAggregatesInput[]
    OR?: VendorCategoryScalarWhereWithAggregatesInput[]
    NOT?: VendorCategoryScalarWhereWithAggregatesInput | VendorCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VendorCategory"> | number
    name?: StringWithAggregatesFilter<"VendorCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorCategory"> | Date | string
  }

  export type VendorDocumentWhereInput = {
    AND?: VendorDocumentWhereInput | VendorDocumentWhereInput[]
    OR?: VendorDocumentWhereInput[]
    NOT?: VendorDocumentWhereInput | VendorDocumentWhereInput[]
    id?: IntFilter<"VendorDocument"> | number
    vendorId?: IntFilter<"VendorDocument"> | number
    docType?: StringFilter<"VendorDocument"> | string
    url?: StringFilter<"VendorDocument"> | string
    fileName?: StringFilter<"VendorDocument"> | string
    expiryDate?: DateTimeNullableFilter<"VendorDocument"> | Date | string | null
    uploadedAt?: DateTimeFilter<"VendorDocument"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorDocumentOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    docType?: SortOrder
    url?: SortOrder
    fileName?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorDocumentWhereInput | VendorDocumentWhereInput[]
    OR?: VendorDocumentWhereInput[]
    NOT?: VendorDocumentWhereInput | VendorDocumentWhereInput[]
    vendorId?: IntFilter<"VendorDocument"> | number
    docType?: StringFilter<"VendorDocument"> | string
    url?: StringFilter<"VendorDocument"> | string
    fileName?: StringFilter<"VendorDocument"> | string
    expiryDate?: DateTimeNullableFilter<"VendorDocument"> | Date | string | null
    uploadedAt?: DateTimeFilter<"VendorDocument"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id">

  export type VendorDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    docType?: SortOrder
    url?: SortOrder
    fileName?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: VendorDocumentCountOrderByAggregateInput
    _avg?: VendorDocumentAvgOrderByAggregateInput
    _max?: VendorDocumentMaxOrderByAggregateInput
    _min?: VendorDocumentMinOrderByAggregateInput
    _sum?: VendorDocumentSumOrderByAggregateInput
  }

  export type VendorDocumentScalarWhereWithAggregatesInput = {
    AND?: VendorDocumentScalarWhereWithAggregatesInput | VendorDocumentScalarWhereWithAggregatesInput[]
    OR?: VendorDocumentScalarWhereWithAggregatesInput[]
    NOT?: VendorDocumentScalarWhereWithAggregatesInput | VendorDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VendorDocument"> | number
    vendorId?: IntWithAggregatesFilter<"VendorDocument"> | number
    docType?: StringWithAggregatesFilter<"VendorDocument"> | string
    url?: StringWithAggregatesFilter<"VendorDocument"> | string
    fileName?: StringWithAggregatesFilter<"VendorDocument"> | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"VendorDocument"> | Date | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"VendorDocument"> | Date | string
  }

  export type CSI_MaterialWhereInput = {
    AND?: CSI_MaterialWhereInput | CSI_MaterialWhereInput[]
    OR?: CSI_MaterialWhereInput[]
    NOT?: CSI_MaterialWhereInput | CSI_MaterialWhereInput[]
    id?: IntFilter<"CSI_Material"> | number
    csiCode?: StringNullableFilter<"CSI_Material"> | string | null
    name?: StringFilter<"CSI_Material"> | string
    unit?: StringNullableFilter<"CSI_Material"> | string | null
    defaultVendorId?: IntNullableFilter<"CSI_Material"> | number | null
    defaultVendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    priceEntries?: PriceEntryListRelationFilter
  }

  export type CSI_MaterialOrderByWithRelationInput = {
    id?: SortOrder
    csiCode?: SortOrderInput | SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    defaultVendorId?: SortOrderInput | SortOrder
    defaultVendor?: VendorOrderByWithRelationInput
    priceEntries?: PriceEntryOrderByRelationAggregateInput
  }

  export type CSI_MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CSI_MaterialWhereInput | CSI_MaterialWhereInput[]
    OR?: CSI_MaterialWhereInput[]
    NOT?: CSI_MaterialWhereInput | CSI_MaterialWhereInput[]
    csiCode?: StringNullableFilter<"CSI_Material"> | string | null
    name?: StringFilter<"CSI_Material"> | string
    unit?: StringNullableFilter<"CSI_Material"> | string | null
    defaultVendorId?: IntNullableFilter<"CSI_Material"> | number | null
    defaultVendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    priceEntries?: PriceEntryListRelationFilter
  }, "id">

  export type CSI_MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    csiCode?: SortOrderInput | SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    defaultVendorId?: SortOrderInput | SortOrder
    _count?: CSI_MaterialCountOrderByAggregateInput
    _avg?: CSI_MaterialAvgOrderByAggregateInput
    _max?: CSI_MaterialMaxOrderByAggregateInput
    _min?: CSI_MaterialMinOrderByAggregateInput
    _sum?: CSI_MaterialSumOrderByAggregateInput
  }

  export type CSI_MaterialScalarWhereWithAggregatesInput = {
    AND?: CSI_MaterialScalarWhereWithAggregatesInput | CSI_MaterialScalarWhereWithAggregatesInput[]
    OR?: CSI_MaterialScalarWhereWithAggregatesInput[]
    NOT?: CSI_MaterialScalarWhereWithAggregatesInput | CSI_MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CSI_Material"> | number
    csiCode?: StringNullableWithAggregatesFilter<"CSI_Material"> | string | null
    name?: StringWithAggregatesFilter<"CSI_Material"> | string
    unit?: StringNullableWithAggregatesFilter<"CSI_Material"> | string | null
    defaultVendorId?: IntNullableWithAggregatesFilter<"CSI_Material"> | number | null
  }

  export type PriceEntryWhereInput = {
    AND?: PriceEntryWhereInput | PriceEntryWhereInput[]
    OR?: PriceEntryWhereInput[]
    NOT?: PriceEntryWhereInput | PriceEntryWhereInput[]
    id?: IntFilter<"PriceEntry"> | number
    materialId?: IntFilter<"PriceEntry"> | number
    vendorId?: IntFilter<"PriceEntry"> | number
    unitPrice?: FloatFilter<"PriceEntry"> | number
    currency?: StringFilter<"PriceEntry"> | string
    createdAt?: DateTimeFilter<"PriceEntry"> | Date | string
    effectiveDate?: DateTimeFilter<"PriceEntry"> | Date | string
    expiryDate?: DateTimeNullableFilter<"PriceEntry"> | Date | string | null
    updatedAt?: DateTimeFilter<"PriceEntry"> | Date | string
    material?: XOR<CSI_MaterialScalarRelationFilter, CSI_MaterialWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type PriceEntryOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    vendorId?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    effectiveDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    material?: CSI_MaterialOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type PriceEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PriceEntryWhereInput | PriceEntryWhereInput[]
    OR?: PriceEntryWhereInput[]
    NOT?: PriceEntryWhereInput | PriceEntryWhereInput[]
    materialId?: IntFilter<"PriceEntry"> | number
    vendorId?: IntFilter<"PriceEntry"> | number
    unitPrice?: FloatFilter<"PriceEntry"> | number
    currency?: StringFilter<"PriceEntry"> | string
    createdAt?: DateTimeFilter<"PriceEntry"> | Date | string
    effectiveDate?: DateTimeFilter<"PriceEntry"> | Date | string
    expiryDate?: DateTimeNullableFilter<"PriceEntry"> | Date | string | null
    updatedAt?: DateTimeFilter<"PriceEntry"> | Date | string
    material?: XOR<CSI_MaterialScalarRelationFilter, CSI_MaterialWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id">

  export type PriceEntryOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    vendorId?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    effectiveDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: PriceEntryCountOrderByAggregateInput
    _avg?: PriceEntryAvgOrderByAggregateInput
    _max?: PriceEntryMaxOrderByAggregateInput
    _min?: PriceEntryMinOrderByAggregateInput
    _sum?: PriceEntrySumOrderByAggregateInput
  }

  export type PriceEntryScalarWhereWithAggregatesInput = {
    AND?: PriceEntryScalarWhereWithAggregatesInput | PriceEntryScalarWhereWithAggregatesInput[]
    OR?: PriceEntryScalarWhereWithAggregatesInput[]
    NOT?: PriceEntryScalarWhereWithAggregatesInput | PriceEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PriceEntry"> | number
    materialId?: IntWithAggregatesFilter<"PriceEntry"> | number
    vendorId?: IntWithAggregatesFilter<"PriceEntry"> | number
    unitPrice?: FloatWithAggregatesFilter<"PriceEntry"> | number
    currency?: StringWithAggregatesFilter<"PriceEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PriceEntry"> | Date | string
    effectiveDate?: DateTimeWithAggregatesFilter<"PriceEntry"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"PriceEntry"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"PriceEntry"> | Date | string
  }

  export type RFQWhereInput = {
    AND?: RFQWhereInput | RFQWhereInput[]
    OR?: RFQWhereInput[]
    NOT?: RFQWhereInput | RFQWhereInput[]
    id?: IntFilter<"RFQ"> | number
    rfqNumber?: StringFilter<"RFQ"> | string
    projectName?: StringFilter<"RFQ"> | string
    packageScope?: StringNullableFilter<"RFQ"> | string | null
    itemDesc?: StringNullableFilter<"RFQ"> | string | null
    csiCode?: StringNullableFilter<"RFQ"> | string | null
    estimatedUnitPrice?: FloatNullableFilter<"RFQ"> | number | null
    requiredDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    targetSubmissionDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    currency?: StringFilter<"RFQ"> | string
    createdById?: IntFilter<"RFQ"> | number
    status?: EnumRFQStatusFilter<"RFQ"> | $Enums.RFQStatus
    createdAt?: DateTimeFilter<"RFQ"> | Date | string
    description?: StringNullableFilter<"RFQ"> | string | null
    dueDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    title?: StringFilter<"RFQ"> | string
    updatedAt?: DateTimeFilter<"RFQ"> | Date | string
    contracts?: ContractListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    submissions?: RFQSubmissionListRelationFilter
    attachments?: DocumentListRelationFilter
  }

  export type RFQOrderByWithRelationInput = {
    id?: SortOrder
    rfqNumber?: SortOrder
    projectName?: SortOrder
    packageScope?: SortOrderInput | SortOrder
    itemDesc?: SortOrderInput | SortOrder
    csiCode?: SortOrderInput | SortOrder
    estimatedUnitPrice?: SortOrderInput | SortOrder
    requiredDate?: SortOrderInput | SortOrder
    targetSubmissionDate?: SortOrderInput | SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    contracts?: ContractOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    submissions?: RFQSubmissionOrderByRelationAggregateInput
    attachments?: DocumentOrderByRelationAggregateInput
  }

  export type RFQWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rfqNumber?: string
    AND?: RFQWhereInput | RFQWhereInput[]
    OR?: RFQWhereInput[]
    NOT?: RFQWhereInput | RFQWhereInput[]
    projectName?: StringFilter<"RFQ"> | string
    packageScope?: StringNullableFilter<"RFQ"> | string | null
    itemDesc?: StringNullableFilter<"RFQ"> | string | null
    csiCode?: StringNullableFilter<"RFQ"> | string | null
    estimatedUnitPrice?: FloatNullableFilter<"RFQ"> | number | null
    requiredDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    targetSubmissionDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    currency?: StringFilter<"RFQ"> | string
    createdById?: IntFilter<"RFQ"> | number
    status?: EnumRFQStatusFilter<"RFQ"> | $Enums.RFQStatus
    createdAt?: DateTimeFilter<"RFQ"> | Date | string
    description?: StringNullableFilter<"RFQ"> | string | null
    dueDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    title?: StringFilter<"RFQ"> | string
    updatedAt?: DateTimeFilter<"RFQ"> | Date | string
    contracts?: ContractListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    submissions?: RFQSubmissionListRelationFilter
    attachments?: DocumentListRelationFilter
  }, "id" | "rfqNumber">

  export type RFQOrderByWithAggregationInput = {
    id?: SortOrder
    rfqNumber?: SortOrder
    projectName?: SortOrder
    packageScope?: SortOrderInput | SortOrder
    itemDesc?: SortOrderInput | SortOrder
    csiCode?: SortOrderInput | SortOrder
    estimatedUnitPrice?: SortOrderInput | SortOrder
    requiredDate?: SortOrderInput | SortOrder
    targetSubmissionDate?: SortOrderInput | SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    _count?: RFQCountOrderByAggregateInput
    _avg?: RFQAvgOrderByAggregateInput
    _max?: RFQMaxOrderByAggregateInput
    _min?: RFQMinOrderByAggregateInput
    _sum?: RFQSumOrderByAggregateInput
  }

  export type RFQScalarWhereWithAggregatesInput = {
    AND?: RFQScalarWhereWithAggregatesInput | RFQScalarWhereWithAggregatesInput[]
    OR?: RFQScalarWhereWithAggregatesInput[]
    NOT?: RFQScalarWhereWithAggregatesInput | RFQScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RFQ"> | number
    rfqNumber?: StringWithAggregatesFilter<"RFQ"> | string
    projectName?: StringWithAggregatesFilter<"RFQ"> | string
    packageScope?: StringNullableWithAggregatesFilter<"RFQ"> | string | null
    itemDesc?: StringNullableWithAggregatesFilter<"RFQ"> | string | null
    csiCode?: StringNullableWithAggregatesFilter<"RFQ"> | string | null
    estimatedUnitPrice?: FloatNullableWithAggregatesFilter<"RFQ"> | number | null
    requiredDate?: DateTimeNullableWithAggregatesFilter<"RFQ"> | Date | string | null
    targetSubmissionDate?: DateTimeNullableWithAggregatesFilter<"RFQ"> | Date | string | null
    currency?: StringWithAggregatesFilter<"RFQ"> | string
    createdById?: IntWithAggregatesFilter<"RFQ"> | number
    status?: EnumRFQStatusWithAggregatesFilter<"RFQ"> | $Enums.RFQStatus
    createdAt?: DateTimeWithAggregatesFilter<"RFQ"> | Date | string
    description?: StringNullableWithAggregatesFilter<"RFQ"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"RFQ"> | Date | string | null
    title?: StringWithAggregatesFilter<"RFQ"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"RFQ"> | Date | string
  }

  export type RFQSubmissionWhereInput = {
    AND?: RFQSubmissionWhereInput | RFQSubmissionWhereInput[]
    OR?: RFQSubmissionWhereInput[]
    NOT?: RFQSubmissionWhereInput | RFQSubmissionWhereInput[]
    id?: IntFilter<"RFQSubmission"> | number
    rfqId?: IntFilter<"RFQSubmission"> | number
    vendorId?: IntFilter<"RFQSubmission"> | number
    submittedAt?: DateTimeNullableFilter<"RFQSubmission"> | Date | string | null
    totalValue?: FloatNullableFilter<"RFQSubmission"> | number | null
    currency?: StringFilter<"RFQSubmission"> | string
    docUrl?: StringNullableFilter<"RFQSubmission"> | string | null
    items?: JsonNullableFilter<"RFQSubmission">
    status?: StringNullableFilter<"RFQSubmission"> | string | null
    totalAmount?: FloatNullableFilter<"RFQSubmission"> | number | null
    evaluations?: EvaluationListRelationFilter
    rfq?: XOR<RFQScalarRelationFilter, RFQWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type RFQSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    totalValue?: SortOrderInput | SortOrder
    currency?: SortOrder
    docUrl?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
    rfq?: RFQOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
  }

  export type RFQSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RFQSubmissionWhereInput | RFQSubmissionWhereInput[]
    OR?: RFQSubmissionWhereInput[]
    NOT?: RFQSubmissionWhereInput | RFQSubmissionWhereInput[]
    rfqId?: IntFilter<"RFQSubmission"> | number
    vendorId?: IntFilter<"RFQSubmission"> | number
    submittedAt?: DateTimeNullableFilter<"RFQSubmission"> | Date | string | null
    totalValue?: FloatNullableFilter<"RFQSubmission"> | number | null
    currency?: StringFilter<"RFQSubmission"> | string
    docUrl?: StringNullableFilter<"RFQSubmission"> | string | null
    items?: JsonNullableFilter<"RFQSubmission">
    status?: StringNullableFilter<"RFQSubmission"> | string | null
    totalAmount?: FloatNullableFilter<"RFQSubmission"> | number | null
    evaluations?: EvaluationListRelationFilter
    rfq?: XOR<RFQScalarRelationFilter, RFQWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "id">

  export type RFQSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    totalValue?: SortOrderInput | SortOrder
    currency?: SortOrder
    docUrl?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    _count?: RFQSubmissionCountOrderByAggregateInput
    _avg?: RFQSubmissionAvgOrderByAggregateInput
    _max?: RFQSubmissionMaxOrderByAggregateInput
    _min?: RFQSubmissionMinOrderByAggregateInput
    _sum?: RFQSubmissionSumOrderByAggregateInput
  }

  export type RFQSubmissionScalarWhereWithAggregatesInput = {
    AND?: RFQSubmissionScalarWhereWithAggregatesInput | RFQSubmissionScalarWhereWithAggregatesInput[]
    OR?: RFQSubmissionScalarWhereWithAggregatesInput[]
    NOT?: RFQSubmissionScalarWhereWithAggregatesInput | RFQSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RFQSubmission"> | number
    rfqId?: IntWithAggregatesFilter<"RFQSubmission"> | number
    vendorId?: IntWithAggregatesFilter<"RFQSubmission"> | number
    submittedAt?: DateTimeNullableWithAggregatesFilter<"RFQSubmission"> | Date | string | null
    totalValue?: FloatNullableWithAggregatesFilter<"RFQSubmission"> | number | null
    currency?: StringWithAggregatesFilter<"RFQSubmission"> | string
    docUrl?: StringNullableWithAggregatesFilter<"RFQSubmission"> | string | null
    items?: JsonNullableWithAggregatesFilter<"RFQSubmission">
    status?: StringNullableWithAggregatesFilter<"RFQSubmission"> | string | null
    totalAmount?: FloatNullableWithAggregatesFilter<"RFQSubmission"> | number | null
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    id?: IntFilter<"Evaluation"> | number
    submissionId?: IntFilter<"Evaluation"> | number
    evaluatorId?: IntFilter<"Evaluation"> | number
    technicalScore?: FloatNullableFilter<"Evaluation"> | number | null
    financialScore?: FloatNullableFilter<"Evaluation"> | number | null
    experienceScore?: FloatNullableFilter<"Evaluation"> | number | null
    responsiveness?: FloatNullableFilter<"Evaluation"> | number | null
    otherScore?: FloatNullableFilter<"Evaluation"> | number | null
    totalScore?: FloatNullableFilter<"Evaluation"> | number | null
    comments?: StringNullableFilter<"Evaluation"> | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    evaluator?: XOR<UserScalarRelationFilter, UserWhereInput>
    submission?: XOR<RFQSubmissionScalarRelationFilter, RFQSubmissionWhereInput>
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    submissionId?: SortOrder
    evaluatorId?: SortOrder
    technicalScore?: SortOrderInput | SortOrder
    financialScore?: SortOrderInput | SortOrder
    experienceScore?: SortOrderInput | SortOrder
    responsiveness?: SortOrderInput | SortOrder
    otherScore?: SortOrderInput | SortOrder
    totalScore?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    evaluator?: UserOrderByWithRelationInput
    submission?: RFQSubmissionOrderByWithRelationInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    submissionId?: IntFilter<"Evaluation"> | number
    evaluatorId?: IntFilter<"Evaluation"> | number
    technicalScore?: FloatNullableFilter<"Evaluation"> | number | null
    financialScore?: FloatNullableFilter<"Evaluation"> | number | null
    experienceScore?: FloatNullableFilter<"Evaluation"> | number | null
    responsiveness?: FloatNullableFilter<"Evaluation"> | number | null
    otherScore?: FloatNullableFilter<"Evaluation"> | number | null
    totalScore?: FloatNullableFilter<"Evaluation"> | number | null
    comments?: StringNullableFilter<"Evaluation"> | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    evaluator?: XOR<UserScalarRelationFilter, UserWhereInput>
    submission?: XOR<RFQSubmissionScalarRelationFilter, RFQSubmissionWhereInput>
  }, "id">

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    submissionId?: SortOrder
    evaluatorId?: SortOrder
    technicalScore?: SortOrderInput | SortOrder
    financialScore?: SortOrderInput | SortOrder
    experienceScore?: SortOrderInput | SortOrder
    responsiveness?: SortOrderInput | SortOrder
    otherScore?: SortOrderInput | SortOrder
    totalScore?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _avg?: EvaluationAvgOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
    _sum?: EvaluationSumOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evaluation"> | number
    submissionId?: IntWithAggregatesFilter<"Evaluation"> | number
    evaluatorId?: IntWithAggregatesFilter<"Evaluation"> | number
    technicalScore?: FloatNullableWithAggregatesFilter<"Evaluation"> | number | null
    financialScore?: FloatNullableWithAggregatesFilter<"Evaluation"> | number | null
    experienceScore?: FloatNullableWithAggregatesFilter<"Evaluation"> | number | null
    responsiveness?: FloatNullableWithAggregatesFilter<"Evaluation"> | number | null
    otherScore?: FloatNullableWithAggregatesFilter<"Evaluation"> | number | null
    totalScore?: FloatNullableWithAggregatesFilter<"Evaluation"> | number | null
    comments?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: IntFilter<"Contract"> | number
    contractNumber?: StringFilter<"Contract"> | string
    rfqId?: IntNullableFilter<"Contract"> | number | null
    vendorId?: IntFilter<"Contract"> | number
    contractValue?: FloatFilter<"Contract"> | number
    currency?: StringFilter<"Contract"> | string
    startDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: StringNullableFilter<"Contract"> | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    rfq?: XOR<RFQNullableScalarRelationFilter, RFQWhereInput> | null
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    documents?: DocumentListRelationFilter
    ipcs?: IPCListRelationFilter
    variationOrders?: VariationOrderListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    rfqId?: SortOrderInput | SortOrder
    vendorId?: SortOrder
    contractValue?: SortOrder
    currency?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rfq?: RFQOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    ipcs?: IPCOrderByRelationAggregateInput
    variationOrders?: VariationOrderOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contractNumber?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    rfqId?: IntNullableFilter<"Contract"> | number | null
    vendorId?: IntFilter<"Contract"> | number
    contractValue?: FloatFilter<"Contract"> | number
    currency?: StringFilter<"Contract"> | string
    startDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: StringNullableFilter<"Contract"> | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    rfq?: XOR<RFQNullableScalarRelationFilter, RFQWhereInput> | null
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    documents?: DocumentListRelationFilter
    ipcs?: IPCListRelationFilter
    variationOrders?: VariationOrderListRelationFilter
  }, "id" | "contractNumber">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    rfqId?: SortOrderInput | SortOrder
    vendorId?: SortOrder
    contractValue?: SortOrder
    currency?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contract"> | number
    contractNumber?: StringWithAggregatesFilter<"Contract"> | string
    rfqId?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    vendorId?: IntWithAggregatesFilter<"Contract"> | number
    contractValue?: FloatWithAggregatesFilter<"Contract"> | number
    currency?: StringWithAggregatesFilter<"Contract"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type VariationOrderWhereInput = {
    AND?: VariationOrderWhereInput | VariationOrderWhereInput[]
    OR?: VariationOrderWhereInput[]
    NOT?: VariationOrderWhereInput | VariationOrderWhereInput[]
    id?: IntFilter<"VariationOrder"> | number
    voRef?: StringFilter<"VariationOrder"> | string
    contractId?: IntFilter<"VariationOrder"> | number
    description?: StringNullableFilter<"VariationOrder"> | string | null
    costImpact?: FloatNullableFilter<"VariationOrder"> | number | null
    timeImpact?: IntNullableFilter<"VariationOrder"> | number | null
    status?: StringNullableFilter<"VariationOrder"> | string | null
    createdAt?: DateTimeFilter<"VariationOrder"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
  }

  export type VariationOrderOrderByWithRelationInput = {
    id?: SortOrder
    voRef?: SortOrder
    contractId?: SortOrder
    description?: SortOrderInput | SortOrder
    costImpact?: SortOrderInput | SortOrder
    timeImpact?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
  }

  export type VariationOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    voRef?: string
    AND?: VariationOrderWhereInput | VariationOrderWhereInput[]
    OR?: VariationOrderWhereInput[]
    NOT?: VariationOrderWhereInput | VariationOrderWhereInput[]
    contractId?: IntFilter<"VariationOrder"> | number
    description?: StringNullableFilter<"VariationOrder"> | string | null
    costImpact?: FloatNullableFilter<"VariationOrder"> | number | null
    timeImpact?: IntNullableFilter<"VariationOrder"> | number | null
    status?: StringNullableFilter<"VariationOrder"> | string | null
    createdAt?: DateTimeFilter<"VariationOrder"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
  }, "id" | "voRef">

  export type VariationOrderOrderByWithAggregationInput = {
    id?: SortOrder
    voRef?: SortOrder
    contractId?: SortOrder
    description?: SortOrderInput | SortOrder
    costImpact?: SortOrderInput | SortOrder
    timeImpact?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VariationOrderCountOrderByAggregateInput
    _avg?: VariationOrderAvgOrderByAggregateInput
    _max?: VariationOrderMaxOrderByAggregateInput
    _min?: VariationOrderMinOrderByAggregateInput
    _sum?: VariationOrderSumOrderByAggregateInput
  }

  export type VariationOrderScalarWhereWithAggregatesInput = {
    AND?: VariationOrderScalarWhereWithAggregatesInput | VariationOrderScalarWhereWithAggregatesInput[]
    OR?: VariationOrderScalarWhereWithAggregatesInput[]
    NOT?: VariationOrderScalarWhereWithAggregatesInput | VariationOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VariationOrder"> | number
    voRef?: StringWithAggregatesFilter<"VariationOrder"> | string
    contractId?: IntWithAggregatesFilter<"VariationOrder"> | number
    description?: StringNullableWithAggregatesFilter<"VariationOrder"> | string | null
    costImpact?: FloatNullableWithAggregatesFilter<"VariationOrder"> | number | null
    timeImpact?: IntNullableWithAggregatesFilter<"VariationOrder"> | number | null
    status?: StringNullableWithAggregatesFilter<"VariationOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VariationOrder"> | Date | string
  }

  export type IPCWhereInput = {
    AND?: IPCWhereInput | IPCWhereInput[]
    OR?: IPCWhereInput[]
    NOT?: IPCWhereInput | IPCWhereInput[]
    id?: IntFilter<"IPC"> | number
    ipcNumber?: StringFilter<"IPC"> | string
    projectName?: StringNullableFilter<"IPC"> | string | null
    contractId?: IntFilter<"IPC"> | number
    periodFrom?: DateTimeNullableFilter<"IPC"> | Date | string | null
    periodTo?: DateTimeNullableFilter<"IPC"> | Date | string | null
    currentValue?: FloatFilter<"IPC"> | number
    cumulativeValue?: FloatNullableFilter<"IPC"> | number | null
    deductions?: FloatNullableFilter<"IPC"> | number | null
    netPayable?: FloatNullableFilter<"IPC"> | number | null
    status?: EnumIPCStatusFilter<"IPC"> | $Enums.IPCStatus
    submittedById?: IntFilter<"IPC"> | number
    createdAt?: DateTimeFilter<"IPC"> | Date | string
    attachments?: DocumentListRelationFilter
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    submittedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IPCOrderByWithRelationInput = {
    id?: SortOrder
    ipcNumber?: SortOrder
    projectName?: SortOrderInput | SortOrder
    contractId?: SortOrder
    periodFrom?: SortOrderInput | SortOrder
    periodTo?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    cumulativeValue?: SortOrderInput | SortOrder
    deductions?: SortOrderInput | SortOrder
    netPayable?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedById?: SortOrder
    createdAt?: SortOrder
    attachments?: DocumentOrderByRelationAggregateInput
    contract?: ContractOrderByWithRelationInput
    submittedBy?: UserOrderByWithRelationInput
  }

  export type IPCWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ipcNumber?: string
    AND?: IPCWhereInput | IPCWhereInput[]
    OR?: IPCWhereInput[]
    NOT?: IPCWhereInput | IPCWhereInput[]
    projectName?: StringNullableFilter<"IPC"> | string | null
    contractId?: IntFilter<"IPC"> | number
    periodFrom?: DateTimeNullableFilter<"IPC"> | Date | string | null
    periodTo?: DateTimeNullableFilter<"IPC"> | Date | string | null
    currentValue?: FloatFilter<"IPC"> | number
    cumulativeValue?: FloatNullableFilter<"IPC"> | number | null
    deductions?: FloatNullableFilter<"IPC"> | number | null
    netPayable?: FloatNullableFilter<"IPC"> | number | null
    status?: EnumIPCStatusFilter<"IPC"> | $Enums.IPCStatus
    submittedById?: IntFilter<"IPC"> | number
    createdAt?: DateTimeFilter<"IPC"> | Date | string
    attachments?: DocumentListRelationFilter
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    submittedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "ipcNumber">

  export type IPCOrderByWithAggregationInput = {
    id?: SortOrder
    ipcNumber?: SortOrder
    projectName?: SortOrderInput | SortOrder
    contractId?: SortOrder
    periodFrom?: SortOrderInput | SortOrder
    periodTo?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    cumulativeValue?: SortOrderInput | SortOrder
    deductions?: SortOrderInput | SortOrder
    netPayable?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedById?: SortOrder
    createdAt?: SortOrder
    _count?: IPCCountOrderByAggregateInput
    _avg?: IPCAvgOrderByAggregateInput
    _max?: IPCMaxOrderByAggregateInput
    _min?: IPCMinOrderByAggregateInput
    _sum?: IPCSumOrderByAggregateInput
  }

  export type IPCScalarWhereWithAggregatesInput = {
    AND?: IPCScalarWhereWithAggregatesInput | IPCScalarWhereWithAggregatesInput[]
    OR?: IPCScalarWhereWithAggregatesInput[]
    NOT?: IPCScalarWhereWithAggregatesInput | IPCScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IPC"> | number
    ipcNumber?: StringWithAggregatesFilter<"IPC"> | string
    projectName?: StringNullableWithAggregatesFilter<"IPC"> | string | null
    contractId?: IntWithAggregatesFilter<"IPC"> | number
    periodFrom?: DateTimeNullableWithAggregatesFilter<"IPC"> | Date | string | null
    periodTo?: DateTimeNullableWithAggregatesFilter<"IPC"> | Date | string | null
    currentValue?: FloatWithAggregatesFilter<"IPC"> | number
    cumulativeValue?: FloatNullableWithAggregatesFilter<"IPC"> | number | null
    deductions?: FloatNullableWithAggregatesFilter<"IPC"> | number | null
    netPayable?: FloatNullableWithAggregatesFilter<"IPC"> | number | null
    status?: EnumIPCStatusWithAggregatesFilter<"IPC"> | $Enums.IPCStatus
    submittedById?: IntWithAggregatesFilter<"IPC"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IPC"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    fileName?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    size?: IntNullableFilter<"Document"> | number | null
    uploadedById?: IntNullableFilter<"Document"> | number | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    ipcId?: IntNullableFilter<"Document"> | number | null
    contractId?: IntNullableFilter<"Document"> | number | null
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    ipc?: XOR<IPCNullableScalarRelationFilter, IPCWhereInput> | null
    uploadedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    rfqAttachments?: RFQListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    ipcId?: SortOrderInput | SortOrder
    contractId?: SortOrderInput | SortOrder
    contract?: ContractOrderByWithRelationInput
    ipc?: IPCOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    rfqAttachments?: RFQOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    fileName?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    size?: IntNullableFilter<"Document"> | number | null
    uploadedById?: IntNullableFilter<"Document"> | number | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    ipcId?: IntNullableFilter<"Document"> | number | null
    contractId?: IntNullableFilter<"Document"> | number | null
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    ipc?: XOR<IPCNullableScalarRelationFilter, IPCWhereInput> | null
    uploadedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    rfqAttachments?: RFQListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    ipcId?: SortOrderInput | SortOrder
    contractId?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    fileName?: StringWithAggregatesFilter<"Document"> | string
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    size?: IntNullableWithAggregatesFilter<"Document"> | number | null
    uploadedById?: IntNullableWithAggregatesFilter<"Document"> | number | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    ipcId?: IntNullableWithAggregatesFilter<"Document"> | number | null
    contractId?: IntNullableWithAggregatesFilter<"Document"> | number | null
  }

  export type ApprovalWhereInput = {
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    id?: IntFilter<"Approval"> | number
    entityType?: StringFilter<"Approval"> | string
    entityId?: IntFilter<"Approval"> | number
    approverId?: IntFilter<"Approval"> | number
    sequence?: IntFilter<"Approval"> | number
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    actedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
    approver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApprovalOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    approverId?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actedAt?: SortOrderInput | SortOrder
    approver?: UserOrderByWithRelationInput
  }

  export type ApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    entityType?: StringFilter<"Approval"> | string
    entityId?: IntFilter<"Approval"> | number
    approverId?: IntFilter<"Approval"> | number
    sequence?: IntFilter<"Approval"> | number
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    actedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
    approver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    approverId?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actedAt?: SortOrderInput | SortOrder
    _count?: ApprovalCountOrderByAggregateInput
    _avg?: ApprovalAvgOrderByAggregateInput
    _max?: ApprovalMaxOrderByAggregateInput
    _min?: ApprovalMinOrderByAggregateInput
    _sum?: ApprovalSumOrderByAggregateInput
  }

  export type ApprovalScalarWhereWithAggregatesInput = {
    AND?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    OR?: ApprovalScalarWhereWithAggregatesInput[]
    NOT?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Approval"> | number
    entityType?: StringWithAggregatesFilter<"Approval"> | string
    entityId?: IntWithAggregatesFilter<"Approval"> | number
    approverId?: IntWithAggregatesFilter<"Approval"> | number
    sequence?: IntWithAggregatesFilter<"Approval"> | number
    status?: EnumApprovalStatusWithAggregatesFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
    actedAt?: DateTimeNullableWithAggregatesFilter<"Approval"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    data?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    data?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    data?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
  }

  export type UserUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    desc?: string | null
    name: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    desc?: string | null
    name: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    desc?: string | null
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VendorCreateInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionCreateNestedManyWithoutVendorInput
    users?: UserCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryCreateNestedManyWithoutVendorsInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentUncheckedCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutVendorNestedInput
    users?: UserUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUpdateManyWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors?: VendorCreateNestedManyWithoutCategoriesInput
  }

  export type VendorCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors?: VendorUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type VendorCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: VendorUpdateManyWithoutCategoriesNestedInput
  }

  export type VendorCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: VendorUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type VendorCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDocumentCreateInput = {
    docType: string
    url: string
    fileName: string
    expiryDate?: Date | string | null
    uploadedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutDocumentsInput
  }

  export type VendorDocumentUncheckedCreateInput = {
    id?: number
    vendorId: number
    docType: string
    url: string
    fileName: string
    expiryDate?: Date | string | null
    uploadedAt?: Date | string
  }

  export type VendorDocumentUpdateInput = {
    docType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type VendorDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDocumentCreateManyInput = {
    id?: number
    vendorId: number
    docType: string
    url: string
    fileName: string
    expiryDate?: Date | string | null
    uploadedAt?: Date | string
  }

  export type VendorDocumentUpdateManyMutationInput = {
    docType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CSI_MaterialCreateInput = {
    csiCode?: string | null
    name: string
    unit?: string | null
    defaultVendor?: VendorCreateNestedOneWithoutMaterialsInput
    priceEntries?: PriceEntryCreateNestedManyWithoutMaterialInput
  }

  export type CSI_MaterialUncheckedCreateInput = {
    id?: number
    csiCode?: string | null
    name: string
    unit?: string | null
    defaultVendorId?: number | null
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type CSI_MaterialUpdateInput = {
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVendor?: VendorUpdateOneWithoutMaterialsNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutMaterialNestedInput
  }

  export type CSI_MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type CSI_MaterialCreateManyInput = {
    id?: number
    csiCode?: string | null
    name: string
    unit?: string | null
    defaultVendorId?: number | null
  }

  export type CSI_MaterialUpdateManyMutationInput = {
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CSI_MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PriceEntryCreateInput = {
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
    material: CSI_MaterialCreateNestedOneWithoutPriceEntriesInput
    vendor: VendorCreateNestedOneWithoutPriceEntriesInput
  }

  export type PriceEntryUncheckedCreateInput = {
    id?: number
    materialId: number
    vendorId: number
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
  }

  export type PriceEntryUpdateInput = {
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: CSI_MaterialUpdateOneRequiredWithoutPriceEntriesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPriceEntriesNestedInput
  }

  export type PriceEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceEntryCreateManyInput = {
    id?: number
    materialId: number
    vendorId: number
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
  }

  export type PriceEntryUpdateManyMutationInput = {
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQCreateInput = {
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutRfqInput
    createdBy: UserCreateNestedOneWithoutRfqsInput
    submissions?: RFQSubmissionCreateNestedManyWithoutRfqInput
    attachments?: DocumentCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQUncheckedCreateInput = {
    id?: number
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    createdById: number
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutRfqInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutRfqInput
    attachments?: DocumentUncheckedCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQUpdateInput = {
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutRfqNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRfqsNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutRfqNestedInput
    attachments?: DocumentUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type RFQUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutRfqNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutRfqNestedInput
    attachments?: DocumentUncheckedUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type RFQCreateManyInput = {
    id?: number
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    createdById: number
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
  }

  export type RFQUpdateManyMutationInput = {
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQSubmissionCreateInput = {
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
    evaluations?: EvaluationCreateNestedManyWithoutSubmissionInput
    rfq: RFQCreateNestedOneWithoutSubmissionsInput
    vendor: VendorCreateNestedOneWithoutSubmissionsInput
  }

  export type RFQSubmissionUncheckedCreateInput = {
    id?: number
    rfqId: number
    vendorId: number
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type RFQSubmissionUpdateInput = {
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUpdateManyWithoutSubmissionNestedInput
    rfq?: RFQUpdateOneRequiredWithoutSubmissionsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type RFQSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type RFQSubmissionCreateManyInput = {
    id?: number
    rfqId: number
    vendorId: number
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
  }

  export type RFQSubmissionUpdateManyMutationInput = {
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RFQSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type EvaluationCreateInput = {
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsInput
    submission: RFQSubmissionCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: number
    submissionId: number
    evaluatorId: number
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
  }

  export type EvaluationUpdateInput = {
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsNestedInput
    submission?: RFQSubmissionUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    submissionId?: IntFieldUpdateOperationsInput | number
    evaluatorId?: IntFieldUpdateOperationsInput | number
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyInput = {
    id?: number
    submissionId: number
    evaluatorId: number
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
  }

  export type EvaluationUpdateManyMutationInput = {
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    submissionId?: IntFieldUpdateOperationsInput | number
    evaluatorId?: IntFieldUpdateOperationsInput | number
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    contractNumber: string
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    rfq?: RFQCreateNestedOneWithoutContractsInput
    vendor: VendorCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    ipcs?: IPCCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    contractNumber: string
    rfqId?: number | null
    vendorId: number
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    contractNumber?: StringFieldUpdateOperationsInput | string
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfq?: RFQUpdateOneWithoutContractsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    documents?: DocumentUpdateManyWithoutContractNestedInput
    ipcs?: IPCUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    rfqId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: IntFieldUpdateOperationsInput | number
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutContractNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    id?: number
    contractNumber: string
    rfqId?: number | null
    vendorId: number
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    contractNumber?: StringFieldUpdateOperationsInput | string
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    rfqId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: IntFieldUpdateOperationsInput | number
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationOrderCreateInput = {
    voRef: string
    description?: string | null
    costImpact?: number | null
    timeImpact?: number | null
    status?: string | null
    createdAt?: Date | string
    contract: ContractCreateNestedOneWithoutVariationOrdersInput
  }

  export type VariationOrderUncheckedCreateInput = {
    id?: number
    voRef: string
    contractId: number
    description?: string | null
    costImpact?: number | null
    timeImpact?: number | null
    status?: string | null
    createdAt?: Date | string
  }

  export type VariationOrderUpdateInput = {
    voRef?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timeImpact?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutVariationOrdersNestedInput
  }

  export type VariationOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    voRef?: StringFieldUpdateOperationsInput | string
    contractId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timeImpact?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationOrderCreateManyInput = {
    id?: number
    voRef: string
    contractId: number
    description?: string | null
    costImpact?: number | null
    timeImpact?: number | null
    status?: string | null
    createdAt?: Date | string
  }

  export type VariationOrderUpdateManyMutationInput = {
    voRef?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timeImpact?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    voRef?: StringFieldUpdateOperationsInput | string
    contractId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timeImpact?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPCCreateInput = {
    ipcNumber: string
    projectName?: string | null
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    createdAt?: Date | string
    attachments?: DocumentCreateNestedManyWithoutIpcInput
    contract: ContractCreateNestedOneWithoutIpcsInput
    submittedBy: UserCreateNestedOneWithoutIpcsInput
  }

  export type IPCUncheckedCreateInput = {
    id?: number
    ipcNumber: string
    projectName?: string | null
    contractId: number
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    submittedById: number
    createdAt?: Date | string
    attachments?: DocumentUncheckedCreateNestedManyWithoutIpcInput
  }

  export type IPCUpdateInput = {
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: DocumentUpdateManyWithoutIpcNestedInput
    contract?: ContractUpdateOneRequiredWithoutIpcsNestedInput
    submittedBy?: UserUpdateOneRequiredWithoutIpcsNestedInput
  }

  export type IPCUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: IntFieldUpdateOperationsInput | number
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    submittedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: DocumentUncheckedUpdateManyWithoutIpcNestedInput
  }

  export type IPCCreateManyInput = {
    id?: number
    ipcNumber: string
    projectName?: string | null
    contractId: number
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    submittedById: number
    createdAt?: Date | string
  }

  export type IPCUpdateManyMutationInput = {
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPCUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: IntFieldUpdateOperationsInput | number
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    submittedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedAt?: Date | string
    contract?: ContractCreateNestedOneWithoutDocumentsInput
    ipc?: IPCCreateNestedOneWithoutAttachmentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
    rfqAttachments?: RFQCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedById?: number | null
    uploadedAt?: Date | string
    ipcId?: number | null
    contractId?: number | null
    rfqAttachments?: RFQUncheckedCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutDocumentsNestedInput
    ipc?: IPCUpdateOneWithoutAttachmentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
    rfqAttachments?: RFQUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
    rfqAttachments?: RFQUncheckedUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedById?: number | null
    uploadedAt?: Date | string
    ipcId?: number | null
    contractId?: number | null
  }

  export type DocumentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalCreateInput = {
    entityType: string
    entityId: number
    sequence: number
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    actedAt?: Date | string | null
    approver: UserCreateNestedOneWithoutApprovalsInput
  }

  export type ApprovalUncheckedCreateInput = {
    id?: number
    entityType: string
    entityId: number
    approverId: number
    sequence: number
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    actedAt?: Date | string | null
  }

  export type ApprovalUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    approverId?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalCreateManyInput = {
    id?: number
    entityType: string
    entityId: number
    approverId: number
    sequence: number
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    actedAt?: Date | string | null
  }

  export type ApprovalUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    approverId?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    action: string
    entity?: string | null
    entityId?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId?: number | null
    action: string
    entity?: string | null
    entityId?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId?: number | null
    action: string
    entity?: string | null
    entityId?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    title: string
    body?: string | null
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    body?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    title: string
    body?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ApprovalListRelationFilter = {
    every?: ApprovalWhereInput
    some?: ApprovalWhereInput
    none?: ApprovalWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type IPCListRelationFilter = {
    every?: IPCWhereInput
    some?: IPCWhereInput
    none?: IPCWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type RFQListRelationFilter = {
    every?: RFQWhereInput
    some?: RFQWhereInput
    none?: RFQWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type VendorNullableScalarRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IPCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RFQOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    vendorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessCode?: SortOrder
    status?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    vendorId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    vendorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessCode?: SortOrder
    status?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    vendorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessCode?: SortOrder
    status?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    vendorId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type CSI_MaterialListRelationFilter = {
    every?: CSI_MaterialWhereInput
    some?: CSI_MaterialWhereInput
    none?: CSI_MaterialWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type PriceEntryListRelationFilter = {
    every?: PriceEntryWhereInput
    some?: PriceEntryWhereInput
    none?: PriceEntryWhereInput
  }

  export type RFQSubmissionListRelationFilter = {
    every?: RFQSubmissionWhereInput
    some?: RFQSubmissionWhereInput
    none?: RFQSubmissionWhereInput
  }

  export type VendorDocumentListRelationFilter = {
    every?: VendorDocumentWhereInput
    some?: VendorDocumentWhereInput
    none?: VendorDocumentWhereInput
  }

  export type VendorCategoryListRelationFilter = {
    every?: VendorCategoryWhereInput
    some?: VendorCategoryWhereInput
    none?: VendorCategoryWhereInput
  }

  export type CSI_MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RFQSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    status?: SortOrder
    address?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    status?: SortOrder
    address?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    status?: SortOrder
    address?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VendorCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type VendorDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    docType?: SortOrder
    url?: SortOrder
    fileName?: SortOrder
    expiryDate?: SortOrder
    uploadedAt?: SortOrder
  }

  export type VendorDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type VendorDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    docType?: SortOrder
    url?: SortOrder
    fileName?: SortOrder
    expiryDate?: SortOrder
    uploadedAt?: SortOrder
  }

  export type VendorDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    docType?: SortOrder
    url?: SortOrder
    fileName?: SortOrder
    expiryDate?: SortOrder
    uploadedAt?: SortOrder
  }

  export type VendorDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CSI_MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    csiCode?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    defaultVendorId?: SortOrder
  }

  export type CSI_MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    defaultVendorId?: SortOrder
  }

  export type CSI_MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    csiCode?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    defaultVendorId?: SortOrder
  }

  export type CSI_MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    csiCode?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    defaultVendorId?: SortOrder
  }

  export type CSI_MaterialSumOrderByAggregateInput = {
    id?: SortOrder
    defaultVendorId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CSI_MaterialScalarRelationFilter = {
    is?: CSI_MaterialWhereInput
    isNot?: CSI_MaterialWhereInput
  }

  export type PriceEntryCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    vendorId?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    effectiveDate?: SortOrder
    expiryDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    vendorId?: SortOrder
    unitPrice?: SortOrder
  }

  export type PriceEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    vendorId?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    effectiveDate?: SortOrder
    expiryDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceEntryMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    vendorId?: SortOrder
    unitPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    effectiveDate?: SortOrder
    expiryDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceEntrySumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    vendorId?: SortOrder
    unitPrice?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumRFQStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RFQStatus | EnumRFQStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRFQStatusFilter<$PrismaModel> | $Enums.RFQStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RFQCountOrderByAggregateInput = {
    id?: SortOrder
    rfqNumber?: SortOrder
    projectName?: SortOrder
    packageScope?: SortOrder
    itemDesc?: SortOrder
    csiCode?: SortOrder
    estimatedUnitPrice?: SortOrder
    requiredDate?: SortOrder
    targetSubmissionDate?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFQAvgOrderByAggregateInput = {
    id?: SortOrder
    estimatedUnitPrice?: SortOrder
    createdById?: SortOrder
  }

  export type RFQMaxOrderByAggregateInput = {
    id?: SortOrder
    rfqNumber?: SortOrder
    projectName?: SortOrder
    packageScope?: SortOrder
    itemDesc?: SortOrder
    csiCode?: SortOrder
    estimatedUnitPrice?: SortOrder
    requiredDate?: SortOrder
    targetSubmissionDate?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFQMinOrderByAggregateInput = {
    id?: SortOrder
    rfqNumber?: SortOrder
    projectName?: SortOrder
    packageScope?: SortOrder
    itemDesc?: SortOrder
    csiCode?: SortOrder
    estimatedUnitPrice?: SortOrder
    requiredDate?: SortOrder
    targetSubmissionDate?: SortOrder
    currency?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type RFQSumOrderByAggregateInput = {
    id?: SortOrder
    estimatedUnitPrice?: SortOrder
    createdById?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumRFQStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RFQStatus | EnumRFQStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRFQStatusWithAggregatesFilter<$PrismaModel> | $Enums.RFQStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRFQStatusFilter<$PrismaModel>
    _max?: NestedEnumRFQStatusFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RFQScalarRelationFilter = {
    is?: RFQWhereInput
    isNot?: RFQWhereInput
  }

  export type RFQSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    submittedAt?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    docUrl?: SortOrder
    items?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
  }

  export type RFQSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    totalValue?: SortOrder
    totalAmount?: SortOrder
  }

  export type RFQSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    submittedAt?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
  }

  export type RFQSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    submittedAt?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    docUrl?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
  }

  export type RFQSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    totalValue?: SortOrder
    totalAmount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type RFQSubmissionScalarRelationFilter = {
    is?: RFQSubmissionWhereInput
    isNot?: RFQSubmissionWhereInput
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    evaluatorId?: SortOrder
    technicalScore?: SortOrder
    financialScore?: SortOrder
    experienceScore?: SortOrder
    responsiveness?: SortOrder
    otherScore?: SortOrder
    totalScore?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationAvgOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    evaluatorId?: SortOrder
    technicalScore?: SortOrder
    financialScore?: SortOrder
    experienceScore?: SortOrder
    responsiveness?: SortOrder
    otherScore?: SortOrder
    totalScore?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    evaluatorId?: SortOrder
    technicalScore?: SortOrder
    financialScore?: SortOrder
    experienceScore?: SortOrder
    responsiveness?: SortOrder
    otherScore?: SortOrder
    totalScore?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    evaluatorId?: SortOrder
    technicalScore?: SortOrder
    financialScore?: SortOrder
    experienceScore?: SortOrder
    responsiveness?: SortOrder
    otherScore?: SortOrder
    totalScore?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationSumOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    evaluatorId?: SortOrder
    technicalScore?: SortOrder
    financialScore?: SortOrder
    experienceScore?: SortOrder
    responsiveness?: SortOrder
    otherScore?: SortOrder
    totalScore?: SortOrder
  }

  export type RFQNullableScalarRelationFilter = {
    is?: RFQWhereInput | null
    isNot?: RFQWhereInput | null
  }

  export type VariationOrderListRelationFilter = {
    every?: VariationOrderWhereInput
    some?: VariationOrderWhereInput
    none?: VariationOrderWhereInput
  }

  export type VariationOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    contractValue?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    contractValue?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    contractValue?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    contractValue?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    rfqId?: SortOrder
    vendorId?: SortOrder
    contractValue?: SortOrder
  }

  export type ContractScalarRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type VariationOrderCountOrderByAggregateInput = {
    id?: SortOrder
    voRef?: SortOrder
    contractId?: SortOrder
    description?: SortOrder
    costImpact?: SortOrder
    timeImpact?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    costImpact?: SortOrder
    timeImpact?: SortOrder
  }

  export type VariationOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    voRef?: SortOrder
    contractId?: SortOrder
    description?: SortOrder
    costImpact?: SortOrder
    timeImpact?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationOrderMinOrderByAggregateInput = {
    id?: SortOrder
    voRef?: SortOrder
    contractId?: SortOrder
    description?: SortOrder
    costImpact?: SortOrder
    timeImpact?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationOrderSumOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    costImpact?: SortOrder
    timeImpact?: SortOrder
  }

  export type EnumIPCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IPCStatus | EnumIPCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIPCStatusFilter<$PrismaModel> | $Enums.IPCStatus
  }

  export type IPCCountOrderByAggregateInput = {
    id?: SortOrder
    ipcNumber?: SortOrder
    projectName?: SortOrder
    contractId?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    currentValue?: SortOrder
    cumulativeValue?: SortOrder
    deductions?: SortOrder
    netPayable?: SortOrder
    status?: SortOrder
    submittedById?: SortOrder
    createdAt?: SortOrder
  }

  export type IPCAvgOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    currentValue?: SortOrder
    cumulativeValue?: SortOrder
    deductions?: SortOrder
    netPayable?: SortOrder
    submittedById?: SortOrder
  }

  export type IPCMaxOrderByAggregateInput = {
    id?: SortOrder
    ipcNumber?: SortOrder
    projectName?: SortOrder
    contractId?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    currentValue?: SortOrder
    cumulativeValue?: SortOrder
    deductions?: SortOrder
    netPayable?: SortOrder
    status?: SortOrder
    submittedById?: SortOrder
    createdAt?: SortOrder
  }

  export type IPCMinOrderByAggregateInput = {
    id?: SortOrder
    ipcNumber?: SortOrder
    projectName?: SortOrder
    contractId?: SortOrder
    periodFrom?: SortOrder
    periodTo?: SortOrder
    currentValue?: SortOrder
    cumulativeValue?: SortOrder
    deductions?: SortOrder
    netPayable?: SortOrder
    status?: SortOrder
    submittedById?: SortOrder
    createdAt?: SortOrder
  }

  export type IPCSumOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    currentValue?: SortOrder
    cumulativeValue?: SortOrder
    deductions?: SortOrder
    netPayable?: SortOrder
    submittedById?: SortOrder
  }

  export type EnumIPCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IPCStatus | EnumIPCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIPCStatusWithAggregatesFilter<$PrismaModel> | $Enums.IPCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIPCStatusFilter<$PrismaModel>
    _max?: NestedEnumIPCStatusFilter<$PrismaModel>
  }

  export type ContractNullableScalarRelationFilter = {
    is?: ContractWhereInput | null
    isNot?: ContractWhereInput | null
  }

  export type IPCNullableScalarRelationFilter = {
    is?: IPCWhereInput | null
    isNot?: IPCWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
    ipcId?: SortOrder
    contractId?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    uploadedById?: SortOrder
    ipcId?: SortOrder
    contractId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
    ipcId?: SortOrder
    contractId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    uploadedById?: SortOrder
    uploadedAt?: SortOrder
    ipcId?: SortOrder
    contractId?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    uploadedById?: SortOrder
    ipcId?: SortOrder
    contractId?: SortOrder
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type ApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    approverId?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    actedAt?: SortOrder
  }

  export type ApprovalAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    approverId?: SortOrder
    sequence?: SortOrder
  }

  export type ApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    approverId?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    actedAt?: SortOrder
  }

  export type ApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    approverId?: SortOrder
    sequence?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    actedAt?: SortOrder
  }

  export type ApprovalSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    approverId?: SortOrder
    sequence?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type IPCCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<IPCCreateWithoutSubmittedByInput, IPCUncheckedCreateWithoutSubmittedByInput> | IPCCreateWithoutSubmittedByInput[] | IPCUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutSubmittedByInput | IPCCreateOrConnectWithoutSubmittedByInput[]
    createMany?: IPCCreateManySubmittedByInputEnvelope
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RFQCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutUsersInput = {
    create?: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUsersInput
    connect?: VendorWhereUniqueInput
  }

  export type ApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type IPCUncheckedCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<IPCCreateWithoutSubmittedByInput, IPCUncheckedCreateWithoutSubmittedByInput> | IPCCreateWithoutSubmittedByInput[] | IPCUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutSubmittedByInput | IPCCreateOrConnectWithoutSubmittedByInput[]
    createMany?: IPCCreateManySubmittedByInputEnvelope
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RFQUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutApproverInput | ApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutApproverInput | ApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutApproverInput | ApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEvaluatorInput | EvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type IPCUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<IPCCreateWithoutSubmittedByInput, IPCUncheckedCreateWithoutSubmittedByInput> | IPCCreateWithoutSubmittedByInput[] | IPCUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutSubmittedByInput | IPCCreateOrConnectWithoutSubmittedByInput[]
    upsert?: IPCUpsertWithWhereUniqueWithoutSubmittedByInput | IPCUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: IPCCreateManySubmittedByInputEnvelope
    set?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    disconnect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    delete?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    update?: IPCUpdateWithWhereUniqueWithoutSubmittedByInput | IPCUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: IPCUpdateManyWithWhereWithoutSubmittedByInput | IPCUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: IPCScalarWhereInput | IPCScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RFQUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutCreatedByInput | RFQUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutCreatedByInput | RFQUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutCreatedByInput | RFQUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type VendorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUsersInput
    upsert?: VendorUpsertWithoutUsersInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutUsersInput, VendorUpdateWithoutUsersInput>, VendorUncheckedUpdateWithoutUsersInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutApproverInput | ApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutApproverInput | ApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutApproverInput | ApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEvaluatorInput | EvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type IPCUncheckedUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<IPCCreateWithoutSubmittedByInput, IPCUncheckedCreateWithoutSubmittedByInput> | IPCCreateWithoutSubmittedByInput[] | IPCUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutSubmittedByInput | IPCCreateOrConnectWithoutSubmittedByInput[]
    upsert?: IPCUpsertWithWhereUniqueWithoutSubmittedByInput | IPCUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: IPCCreateManySubmittedByInputEnvelope
    set?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    disconnect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    delete?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    update?: IPCUpdateWithWhereUniqueWithoutSubmittedByInput | IPCUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: IPCUpdateManyWithWhereWithoutSubmittedByInput | IPCUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: IPCScalarWhereInput | IPCScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RFQUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput> | RFQCreateWithoutCreatedByInput[] | RFQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutCreatedByInput | RFQCreateOrConnectWithoutCreatedByInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutCreatedByInput | RFQUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RFQCreateManyCreatedByInputEnvelope
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutCreatedByInput | RFQUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutCreatedByInput | RFQUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CSI_MaterialCreateNestedManyWithoutDefaultVendorInput = {
    create?: XOR<CSI_MaterialCreateWithoutDefaultVendorInput, CSI_MaterialUncheckedCreateWithoutDefaultVendorInput> | CSI_MaterialCreateWithoutDefaultVendorInput[] | CSI_MaterialUncheckedCreateWithoutDefaultVendorInput[]
    connectOrCreate?: CSI_MaterialCreateOrConnectWithoutDefaultVendorInput | CSI_MaterialCreateOrConnectWithoutDefaultVendorInput[]
    createMany?: CSI_MaterialCreateManyDefaultVendorInputEnvelope
    connect?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutVendorInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type PriceEntryCreateNestedManyWithoutVendorInput = {
    create?: XOR<PriceEntryCreateWithoutVendorInput, PriceEntryUncheckedCreateWithoutVendorInput> | PriceEntryCreateWithoutVendorInput[] | PriceEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutVendorInput | PriceEntryCreateOrConnectWithoutVendorInput[]
    createMany?: PriceEntryCreateManyVendorInputEnvelope
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
  }

  export type RFQSubmissionCreateNestedManyWithoutVendorInput = {
    create?: XOR<RFQSubmissionCreateWithoutVendorInput, RFQSubmissionUncheckedCreateWithoutVendorInput> | RFQSubmissionCreateWithoutVendorInput[] | RFQSubmissionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutVendorInput | RFQSubmissionCreateOrConnectWithoutVendorInput[]
    createMany?: RFQSubmissionCreateManyVendorInputEnvelope
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VendorDocumentCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorDocumentCreateWithoutVendorInput, VendorDocumentUncheckedCreateWithoutVendorInput> | VendorDocumentCreateWithoutVendorInput[] | VendorDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDocumentCreateOrConnectWithoutVendorInput | VendorDocumentCreateOrConnectWithoutVendorInput[]
    createMany?: VendorDocumentCreateManyVendorInputEnvelope
    connect?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
  }

  export type VendorCategoryCreateNestedManyWithoutVendorsInput = {
    create?: XOR<VendorCategoryCreateWithoutVendorsInput, VendorCategoryUncheckedCreateWithoutVendorsInput> | VendorCategoryCreateWithoutVendorsInput[] | VendorCategoryUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: VendorCategoryCreateOrConnectWithoutVendorsInput | VendorCategoryCreateOrConnectWithoutVendorsInput[]
    connect?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
  }

  export type CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput = {
    create?: XOR<CSI_MaterialCreateWithoutDefaultVendorInput, CSI_MaterialUncheckedCreateWithoutDefaultVendorInput> | CSI_MaterialCreateWithoutDefaultVendorInput[] | CSI_MaterialUncheckedCreateWithoutDefaultVendorInput[]
    connectOrCreate?: CSI_MaterialCreateOrConnectWithoutDefaultVendorInput | CSI_MaterialCreateOrConnectWithoutDefaultVendorInput[]
    createMany?: CSI_MaterialCreateManyDefaultVendorInputEnvelope
    connect?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type PriceEntryUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PriceEntryCreateWithoutVendorInput, PriceEntryUncheckedCreateWithoutVendorInput> | PriceEntryCreateWithoutVendorInput[] | PriceEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutVendorInput | PriceEntryCreateOrConnectWithoutVendorInput[]
    createMany?: PriceEntryCreateManyVendorInputEnvelope
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
  }

  export type RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<RFQSubmissionCreateWithoutVendorInput, RFQSubmissionUncheckedCreateWithoutVendorInput> | RFQSubmissionCreateWithoutVendorInput[] | RFQSubmissionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutVendorInput | RFQSubmissionCreateOrConnectWithoutVendorInput[]
    createMany?: RFQSubmissionCreateManyVendorInputEnvelope
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VendorDocumentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorDocumentCreateWithoutVendorInput, VendorDocumentUncheckedCreateWithoutVendorInput> | VendorDocumentCreateWithoutVendorInput[] | VendorDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDocumentCreateOrConnectWithoutVendorInput | VendorDocumentCreateOrConnectWithoutVendorInput[]
    createMany?: VendorDocumentCreateManyVendorInputEnvelope
    connect?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
  }

  export type VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<VendorCategoryCreateWithoutVendorsInput, VendorCategoryUncheckedCreateWithoutVendorsInput> | VendorCategoryCreateWithoutVendorsInput[] | VendorCategoryUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: VendorCategoryCreateOrConnectWithoutVendorsInput | VendorCategoryCreateOrConnectWithoutVendorsInput[]
    connect?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
  }

  export type EnumVendorStatusFieldUpdateOperationsInput = {
    set?: $Enums.VendorStatus
  }

  export type CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput = {
    create?: XOR<CSI_MaterialCreateWithoutDefaultVendorInput, CSI_MaterialUncheckedCreateWithoutDefaultVendorInput> | CSI_MaterialCreateWithoutDefaultVendorInput[] | CSI_MaterialUncheckedCreateWithoutDefaultVendorInput[]
    connectOrCreate?: CSI_MaterialCreateOrConnectWithoutDefaultVendorInput | CSI_MaterialCreateOrConnectWithoutDefaultVendorInput[]
    upsert?: CSI_MaterialUpsertWithWhereUniqueWithoutDefaultVendorInput | CSI_MaterialUpsertWithWhereUniqueWithoutDefaultVendorInput[]
    createMany?: CSI_MaterialCreateManyDefaultVendorInputEnvelope
    set?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    disconnect?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    delete?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    connect?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    update?: CSI_MaterialUpdateWithWhereUniqueWithoutDefaultVendorInput | CSI_MaterialUpdateWithWhereUniqueWithoutDefaultVendorInput[]
    updateMany?: CSI_MaterialUpdateManyWithWhereWithoutDefaultVendorInput | CSI_MaterialUpdateManyWithWhereWithoutDefaultVendorInput[]
    deleteMany?: CSI_MaterialScalarWhereInput | CSI_MaterialScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutVendorInput | ContractUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutVendorInput | ContractUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutVendorInput | ContractUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type PriceEntryUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PriceEntryCreateWithoutVendorInput, PriceEntryUncheckedCreateWithoutVendorInput> | PriceEntryCreateWithoutVendorInput[] | PriceEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutVendorInput | PriceEntryCreateOrConnectWithoutVendorInput[]
    upsert?: PriceEntryUpsertWithWhereUniqueWithoutVendorInput | PriceEntryUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PriceEntryCreateManyVendorInputEnvelope
    set?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    disconnect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    delete?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    update?: PriceEntryUpdateWithWhereUniqueWithoutVendorInput | PriceEntryUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PriceEntryUpdateManyWithWhereWithoutVendorInput | PriceEntryUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PriceEntryScalarWhereInput | PriceEntryScalarWhereInput[]
  }

  export type RFQSubmissionUpdateManyWithoutVendorNestedInput = {
    create?: XOR<RFQSubmissionCreateWithoutVendorInput, RFQSubmissionUncheckedCreateWithoutVendorInput> | RFQSubmissionCreateWithoutVendorInput[] | RFQSubmissionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutVendorInput | RFQSubmissionCreateOrConnectWithoutVendorInput[]
    upsert?: RFQSubmissionUpsertWithWhereUniqueWithoutVendorInput | RFQSubmissionUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: RFQSubmissionCreateManyVendorInputEnvelope
    set?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    disconnect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    delete?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    update?: RFQSubmissionUpdateWithWhereUniqueWithoutVendorInput | RFQSubmissionUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: RFQSubmissionUpdateManyWithWhereWithoutVendorInput | RFQSubmissionUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: RFQSubmissionScalarWhereInput | RFQSubmissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutVendorInput | UserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutVendorInput | UserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutVendorInput | UserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorDocumentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorDocumentCreateWithoutVendorInput, VendorDocumentUncheckedCreateWithoutVendorInput> | VendorDocumentCreateWithoutVendorInput[] | VendorDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDocumentCreateOrConnectWithoutVendorInput | VendorDocumentCreateOrConnectWithoutVendorInput[]
    upsert?: VendorDocumentUpsertWithWhereUniqueWithoutVendorInput | VendorDocumentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorDocumentCreateManyVendorInputEnvelope
    set?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    disconnect?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    delete?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    connect?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    update?: VendorDocumentUpdateWithWhereUniqueWithoutVendorInput | VendorDocumentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorDocumentUpdateManyWithWhereWithoutVendorInput | VendorDocumentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorDocumentScalarWhereInput | VendorDocumentScalarWhereInput[]
  }

  export type VendorCategoryUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<VendorCategoryCreateWithoutVendorsInput, VendorCategoryUncheckedCreateWithoutVendorsInput> | VendorCategoryCreateWithoutVendorsInput[] | VendorCategoryUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: VendorCategoryCreateOrConnectWithoutVendorsInput | VendorCategoryCreateOrConnectWithoutVendorsInput[]
    upsert?: VendorCategoryUpsertWithWhereUniqueWithoutVendorsInput | VendorCategoryUpsertWithWhereUniqueWithoutVendorsInput[]
    set?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    disconnect?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    delete?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    connect?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    update?: VendorCategoryUpdateWithWhereUniqueWithoutVendorsInput | VendorCategoryUpdateWithWhereUniqueWithoutVendorsInput[]
    updateMany?: VendorCategoryUpdateManyWithWhereWithoutVendorsInput | VendorCategoryUpdateManyWithWhereWithoutVendorsInput[]
    deleteMany?: VendorCategoryScalarWhereInput | VendorCategoryScalarWhereInput[]
  }

  export type CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput = {
    create?: XOR<CSI_MaterialCreateWithoutDefaultVendorInput, CSI_MaterialUncheckedCreateWithoutDefaultVendorInput> | CSI_MaterialCreateWithoutDefaultVendorInput[] | CSI_MaterialUncheckedCreateWithoutDefaultVendorInput[]
    connectOrCreate?: CSI_MaterialCreateOrConnectWithoutDefaultVendorInput | CSI_MaterialCreateOrConnectWithoutDefaultVendorInput[]
    upsert?: CSI_MaterialUpsertWithWhereUniqueWithoutDefaultVendorInput | CSI_MaterialUpsertWithWhereUniqueWithoutDefaultVendorInput[]
    createMany?: CSI_MaterialCreateManyDefaultVendorInputEnvelope
    set?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    disconnect?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    delete?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    connect?: CSI_MaterialWhereUniqueInput | CSI_MaterialWhereUniqueInput[]
    update?: CSI_MaterialUpdateWithWhereUniqueWithoutDefaultVendorInput | CSI_MaterialUpdateWithWhereUniqueWithoutDefaultVendorInput[]
    updateMany?: CSI_MaterialUpdateManyWithWhereWithoutDefaultVendorInput | CSI_MaterialUpdateManyWithWhereWithoutDefaultVendorInput[]
    deleteMany?: CSI_MaterialScalarWhereInput | CSI_MaterialScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutVendorInput | ContractUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutVendorInput | ContractUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutVendorInput | ContractUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type PriceEntryUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PriceEntryCreateWithoutVendorInput, PriceEntryUncheckedCreateWithoutVendorInput> | PriceEntryCreateWithoutVendorInput[] | PriceEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutVendorInput | PriceEntryCreateOrConnectWithoutVendorInput[]
    upsert?: PriceEntryUpsertWithWhereUniqueWithoutVendorInput | PriceEntryUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PriceEntryCreateManyVendorInputEnvelope
    set?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    disconnect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    delete?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    update?: PriceEntryUpdateWithWhereUniqueWithoutVendorInput | PriceEntryUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PriceEntryUpdateManyWithWhereWithoutVendorInput | PriceEntryUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PriceEntryScalarWhereInput | PriceEntryScalarWhereInput[]
  }

  export type RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<RFQSubmissionCreateWithoutVendorInput, RFQSubmissionUncheckedCreateWithoutVendorInput> | RFQSubmissionCreateWithoutVendorInput[] | RFQSubmissionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutVendorInput | RFQSubmissionCreateOrConnectWithoutVendorInput[]
    upsert?: RFQSubmissionUpsertWithWhereUniqueWithoutVendorInput | RFQSubmissionUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: RFQSubmissionCreateManyVendorInputEnvelope
    set?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    disconnect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    delete?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    update?: RFQSubmissionUpdateWithWhereUniqueWithoutVendorInput | RFQSubmissionUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: RFQSubmissionUpdateManyWithWhereWithoutVendorInput | RFQSubmissionUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: RFQSubmissionScalarWhereInput | RFQSubmissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutVendorInput | UserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutVendorInput | UserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutVendorInput | UserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorDocumentCreateWithoutVendorInput, VendorDocumentUncheckedCreateWithoutVendorInput> | VendorDocumentCreateWithoutVendorInput[] | VendorDocumentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorDocumentCreateOrConnectWithoutVendorInput | VendorDocumentCreateOrConnectWithoutVendorInput[]
    upsert?: VendorDocumentUpsertWithWhereUniqueWithoutVendorInput | VendorDocumentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorDocumentCreateManyVendorInputEnvelope
    set?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    disconnect?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    delete?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    connect?: VendorDocumentWhereUniqueInput | VendorDocumentWhereUniqueInput[]
    update?: VendorDocumentUpdateWithWhereUniqueWithoutVendorInput | VendorDocumentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorDocumentUpdateManyWithWhereWithoutVendorInput | VendorDocumentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorDocumentScalarWhereInput | VendorDocumentScalarWhereInput[]
  }

  export type VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<VendorCategoryCreateWithoutVendorsInput, VendorCategoryUncheckedCreateWithoutVendorsInput> | VendorCategoryCreateWithoutVendorsInput[] | VendorCategoryUncheckedCreateWithoutVendorsInput[]
    connectOrCreate?: VendorCategoryCreateOrConnectWithoutVendorsInput | VendorCategoryCreateOrConnectWithoutVendorsInput[]
    upsert?: VendorCategoryUpsertWithWhereUniqueWithoutVendorsInput | VendorCategoryUpsertWithWhereUniqueWithoutVendorsInput[]
    set?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    disconnect?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    delete?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    connect?: VendorCategoryWhereUniqueInput | VendorCategoryWhereUniqueInput[]
    update?: VendorCategoryUpdateWithWhereUniqueWithoutVendorsInput | VendorCategoryUpdateWithWhereUniqueWithoutVendorsInput[]
    updateMany?: VendorCategoryUpdateManyWithWhereWithoutVendorsInput | VendorCategoryUpdateManyWithWhereWithoutVendorsInput[]
    deleteMany?: VendorCategoryScalarWhereInput | VendorCategoryScalarWhereInput[]
  }

  export type VendorCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<VendorCreateWithoutCategoriesInput, VendorUncheckedCreateWithoutCategoriesInput> | VendorCreateWithoutCategoriesInput[] | VendorUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCategoriesInput | VendorCreateOrConnectWithoutCategoriesInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<VendorCreateWithoutCategoriesInput, VendorUncheckedCreateWithoutCategoriesInput> | VendorCreateWithoutCategoriesInput[] | VendorUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCategoriesInput | VendorCreateOrConnectWithoutCategoriesInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type VendorUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<VendorCreateWithoutCategoriesInput, VendorUncheckedCreateWithoutCategoriesInput> | VendorCreateWithoutCategoriesInput[] | VendorUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCategoriesInput | VendorCreateOrConnectWithoutCategoriesInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCategoriesInput | VendorUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCategoriesInput | VendorUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCategoriesInput | VendorUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<VendorCreateWithoutCategoriesInput, VendorUncheckedCreateWithoutCategoriesInput> | VendorCreateWithoutCategoriesInput[] | VendorUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCategoriesInput | VendorCreateOrConnectWithoutCategoriesInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCategoriesInput | VendorUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCategoriesInput | VendorUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCategoriesInput | VendorUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<VendorCreateWithoutDocumentsInput, VendorUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDocumentsInput
    connect?: VendorWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type VendorUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<VendorCreateWithoutDocumentsInput, VendorUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDocumentsInput
    upsert?: VendorUpsertWithoutDocumentsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutDocumentsInput, VendorUpdateWithoutDocumentsInput>, VendorUncheckedUpdateWithoutDocumentsInput>
  }

  export type VendorCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutMaterialsInput
    connect?: VendorWhereUniqueInput
  }

  export type PriceEntryCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PriceEntryCreateWithoutMaterialInput, PriceEntryUncheckedCreateWithoutMaterialInput> | PriceEntryCreateWithoutMaterialInput[] | PriceEntryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutMaterialInput | PriceEntryCreateOrConnectWithoutMaterialInput[]
    createMany?: PriceEntryCreateManyMaterialInputEnvelope
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
  }

  export type PriceEntryUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PriceEntryCreateWithoutMaterialInput, PriceEntryUncheckedCreateWithoutMaterialInput> | PriceEntryCreateWithoutMaterialInput[] | PriceEntryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutMaterialInput | PriceEntryCreateOrConnectWithoutMaterialInput[]
    createMany?: PriceEntryCreateManyMaterialInputEnvelope
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
  }

  export type VendorUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutMaterialsInput
    upsert?: VendorUpsertWithoutMaterialsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutMaterialsInput, VendorUpdateWithoutMaterialsInput>, VendorUncheckedUpdateWithoutMaterialsInput>
  }

  export type PriceEntryUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PriceEntryCreateWithoutMaterialInput, PriceEntryUncheckedCreateWithoutMaterialInput> | PriceEntryCreateWithoutMaterialInput[] | PriceEntryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutMaterialInput | PriceEntryCreateOrConnectWithoutMaterialInput[]
    upsert?: PriceEntryUpsertWithWhereUniqueWithoutMaterialInput | PriceEntryUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PriceEntryCreateManyMaterialInputEnvelope
    set?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    disconnect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    delete?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    update?: PriceEntryUpdateWithWhereUniqueWithoutMaterialInput | PriceEntryUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PriceEntryUpdateManyWithWhereWithoutMaterialInput | PriceEntryUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PriceEntryScalarWhereInput | PriceEntryScalarWhereInput[]
  }

  export type PriceEntryUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PriceEntryCreateWithoutMaterialInput, PriceEntryUncheckedCreateWithoutMaterialInput> | PriceEntryCreateWithoutMaterialInput[] | PriceEntryUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PriceEntryCreateOrConnectWithoutMaterialInput | PriceEntryCreateOrConnectWithoutMaterialInput[]
    upsert?: PriceEntryUpsertWithWhereUniqueWithoutMaterialInput | PriceEntryUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PriceEntryCreateManyMaterialInputEnvelope
    set?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    disconnect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    delete?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    connect?: PriceEntryWhereUniqueInput | PriceEntryWhereUniqueInput[]
    update?: PriceEntryUpdateWithWhereUniqueWithoutMaterialInput | PriceEntryUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PriceEntryUpdateManyWithWhereWithoutMaterialInput | PriceEntryUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PriceEntryScalarWhereInput | PriceEntryScalarWhereInput[]
  }

  export type CSI_MaterialCreateNestedOneWithoutPriceEntriesInput = {
    create?: XOR<CSI_MaterialCreateWithoutPriceEntriesInput, CSI_MaterialUncheckedCreateWithoutPriceEntriesInput>
    connectOrCreate?: CSI_MaterialCreateOrConnectWithoutPriceEntriesInput
    connect?: CSI_MaterialWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPriceEntriesInput = {
    create?: XOR<VendorCreateWithoutPriceEntriesInput, VendorUncheckedCreateWithoutPriceEntriesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPriceEntriesInput
    connect?: VendorWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CSI_MaterialUpdateOneRequiredWithoutPriceEntriesNestedInput = {
    create?: XOR<CSI_MaterialCreateWithoutPriceEntriesInput, CSI_MaterialUncheckedCreateWithoutPriceEntriesInput>
    connectOrCreate?: CSI_MaterialCreateOrConnectWithoutPriceEntriesInput
    upsert?: CSI_MaterialUpsertWithoutPriceEntriesInput
    connect?: CSI_MaterialWhereUniqueInput
    update?: XOR<XOR<CSI_MaterialUpdateToOneWithWhereWithoutPriceEntriesInput, CSI_MaterialUpdateWithoutPriceEntriesInput>, CSI_MaterialUncheckedUpdateWithoutPriceEntriesInput>
  }

  export type VendorUpdateOneRequiredWithoutPriceEntriesNestedInput = {
    create?: XOR<VendorCreateWithoutPriceEntriesInput, VendorUncheckedCreateWithoutPriceEntriesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPriceEntriesInput
    upsert?: VendorUpsertWithoutPriceEntriesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPriceEntriesInput, VendorUpdateWithoutPriceEntriesInput>, VendorUncheckedUpdateWithoutPriceEntriesInput>
  }

  export type ContractCreateNestedManyWithoutRfqInput = {
    create?: XOR<ContractCreateWithoutRfqInput, ContractUncheckedCreateWithoutRfqInput> | ContractCreateWithoutRfqInput[] | ContractUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutRfqInput | ContractCreateOrConnectWithoutRfqInput[]
    createMany?: ContractCreateManyRfqInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutRfqsInput = {
    create?: XOR<UserCreateWithoutRfqsInput, UserUncheckedCreateWithoutRfqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRfqsInput
    connect?: UserWhereUniqueInput
  }

  export type RFQSubmissionCreateNestedManyWithoutRfqInput = {
    create?: XOR<RFQSubmissionCreateWithoutRfqInput, RFQSubmissionUncheckedCreateWithoutRfqInput> | RFQSubmissionCreateWithoutRfqInput[] | RFQSubmissionUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutRfqInput | RFQSubmissionCreateOrConnectWithoutRfqInput[]
    createMany?: RFQSubmissionCreateManyRfqInputEnvelope
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutRfqAttachmentsInput = {
    create?: XOR<DocumentCreateWithoutRfqAttachmentsInput, DocumentUncheckedCreateWithoutRfqAttachmentsInput> | DocumentCreateWithoutRfqAttachmentsInput[] | DocumentUncheckedCreateWithoutRfqAttachmentsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRfqAttachmentsInput | DocumentCreateOrConnectWithoutRfqAttachmentsInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutRfqInput = {
    create?: XOR<ContractCreateWithoutRfqInput, ContractUncheckedCreateWithoutRfqInput> | ContractCreateWithoutRfqInput[] | ContractUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutRfqInput | ContractCreateOrConnectWithoutRfqInput[]
    createMany?: ContractCreateManyRfqInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type RFQSubmissionUncheckedCreateNestedManyWithoutRfqInput = {
    create?: XOR<RFQSubmissionCreateWithoutRfqInput, RFQSubmissionUncheckedCreateWithoutRfqInput> | RFQSubmissionCreateWithoutRfqInput[] | RFQSubmissionUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutRfqInput | RFQSubmissionCreateOrConnectWithoutRfqInput[]
    createMany?: RFQSubmissionCreateManyRfqInputEnvelope
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutRfqAttachmentsInput = {
    create?: XOR<DocumentCreateWithoutRfqAttachmentsInput, DocumentUncheckedCreateWithoutRfqAttachmentsInput> | DocumentCreateWithoutRfqAttachmentsInput[] | DocumentUncheckedCreateWithoutRfqAttachmentsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRfqAttachmentsInput | DocumentCreateOrConnectWithoutRfqAttachmentsInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRFQStatusFieldUpdateOperationsInput = {
    set?: $Enums.RFQStatus
  }

  export type ContractUpdateManyWithoutRfqNestedInput = {
    create?: XOR<ContractCreateWithoutRfqInput, ContractUncheckedCreateWithoutRfqInput> | ContractCreateWithoutRfqInput[] | ContractUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutRfqInput | ContractCreateOrConnectWithoutRfqInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutRfqInput | ContractUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: ContractCreateManyRfqInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutRfqInput | ContractUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutRfqInput | ContractUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutRfqsNestedInput = {
    create?: XOR<UserCreateWithoutRfqsInput, UserUncheckedCreateWithoutRfqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRfqsInput
    upsert?: UserUpsertWithoutRfqsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRfqsInput, UserUpdateWithoutRfqsInput>, UserUncheckedUpdateWithoutRfqsInput>
  }

  export type RFQSubmissionUpdateManyWithoutRfqNestedInput = {
    create?: XOR<RFQSubmissionCreateWithoutRfqInput, RFQSubmissionUncheckedCreateWithoutRfqInput> | RFQSubmissionCreateWithoutRfqInput[] | RFQSubmissionUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutRfqInput | RFQSubmissionCreateOrConnectWithoutRfqInput[]
    upsert?: RFQSubmissionUpsertWithWhereUniqueWithoutRfqInput | RFQSubmissionUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: RFQSubmissionCreateManyRfqInputEnvelope
    set?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    disconnect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    delete?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    update?: RFQSubmissionUpdateWithWhereUniqueWithoutRfqInput | RFQSubmissionUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: RFQSubmissionUpdateManyWithWhereWithoutRfqInput | RFQSubmissionUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: RFQSubmissionScalarWhereInput | RFQSubmissionScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutRfqAttachmentsNestedInput = {
    create?: XOR<DocumentCreateWithoutRfqAttachmentsInput, DocumentUncheckedCreateWithoutRfqAttachmentsInput> | DocumentCreateWithoutRfqAttachmentsInput[] | DocumentUncheckedCreateWithoutRfqAttachmentsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRfqAttachmentsInput | DocumentCreateOrConnectWithoutRfqAttachmentsInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRfqAttachmentsInput | DocumentUpsertWithWhereUniqueWithoutRfqAttachmentsInput[]
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRfqAttachmentsInput | DocumentUpdateWithWhereUniqueWithoutRfqAttachmentsInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRfqAttachmentsInput | DocumentUpdateManyWithWhereWithoutRfqAttachmentsInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutRfqNestedInput = {
    create?: XOR<ContractCreateWithoutRfqInput, ContractUncheckedCreateWithoutRfqInput> | ContractCreateWithoutRfqInput[] | ContractUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutRfqInput | ContractCreateOrConnectWithoutRfqInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutRfqInput | ContractUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: ContractCreateManyRfqInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutRfqInput | ContractUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutRfqInput | ContractUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type RFQSubmissionUncheckedUpdateManyWithoutRfqNestedInput = {
    create?: XOR<RFQSubmissionCreateWithoutRfqInput, RFQSubmissionUncheckedCreateWithoutRfqInput> | RFQSubmissionCreateWithoutRfqInput[] | RFQSubmissionUncheckedCreateWithoutRfqInput[]
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutRfqInput | RFQSubmissionCreateOrConnectWithoutRfqInput[]
    upsert?: RFQSubmissionUpsertWithWhereUniqueWithoutRfqInput | RFQSubmissionUpsertWithWhereUniqueWithoutRfqInput[]
    createMany?: RFQSubmissionCreateManyRfqInputEnvelope
    set?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    disconnect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    delete?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    connect?: RFQSubmissionWhereUniqueInput | RFQSubmissionWhereUniqueInput[]
    update?: RFQSubmissionUpdateWithWhereUniqueWithoutRfqInput | RFQSubmissionUpdateWithWhereUniqueWithoutRfqInput[]
    updateMany?: RFQSubmissionUpdateManyWithWhereWithoutRfqInput | RFQSubmissionUpdateManyWithWhereWithoutRfqInput[]
    deleteMany?: RFQSubmissionScalarWhereInput | RFQSubmissionScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutRfqAttachmentsNestedInput = {
    create?: XOR<DocumentCreateWithoutRfqAttachmentsInput, DocumentUncheckedCreateWithoutRfqAttachmentsInput> | DocumentCreateWithoutRfqAttachmentsInput[] | DocumentUncheckedCreateWithoutRfqAttachmentsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutRfqAttachmentsInput | DocumentCreateOrConnectWithoutRfqAttachmentsInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutRfqAttachmentsInput | DocumentUpsertWithWhereUniqueWithoutRfqAttachmentsInput[]
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutRfqAttachmentsInput | DocumentUpdateWithWhereUniqueWithoutRfqAttachmentsInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutRfqAttachmentsInput | DocumentUpdateManyWithWhereWithoutRfqAttachmentsInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<EvaluationCreateWithoutSubmissionInput, EvaluationUncheckedCreateWithoutSubmissionInput> | EvaluationCreateWithoutSubmissionInput[] | EvaluationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSubmissionInput | EvaluationCreateOrConnectWithoutSubmissionInput[]
    createMany?: EvaluationCreateManySubmissionInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type RFQCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<RFQCreateWithoutSubmissionsInput, RFQUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutSubmissionsInput
    connect?: RFQWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<VendorCreateWithoutSubmissionsInput, VendorUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSubmissionsInput
    connect?: VendorWhereUniqueInput
  }

  export type EvaluationUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<EvaluationCreateWithoutSubmissionInput, EvaluationUncheckedCreateWithoutSubmissionInput> | EvaluationCreateWithoutSubmissionInput[] | EvaluationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSubmissionInput | EvaluationCreateOrConnectWithoutSubmissionInput[]
    createMany?: EvaluationCreateManySubmissionInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<EvaluationCreateWithoutSubmissionInput, EvaluationUncheckedCreateWithoutSubmissionInput> | EvaluationCreateWithoutSubmissionInput[] | EvaluationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSubmissionInput | EvaluationCreateOrConnectWithoutSubmissionInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutSubmissionInput | EvaluationUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: EvaluationCreateManySubmissionInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutSubmissionInput | EvaluationUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutSubmissionInput | EvaluationUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type RFQUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<RFQCreateWithoutSubmissionsInput, RFQUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutSubmissionsInput
    upsert?: RFQUpsertWithoutSubmissionsInput
    connect?: RFQWhereUniqueInput
    update?: XOR<XOR<RFQUpdateToOneWithWhereWithoutSubmissionsInput, RFQUpdateWithoutSubmissionsInput>, RFQUncheckedUpdateWithoutSubmissionsInput>
  }

  export type VendorUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<VendorCreateWithoutSubmissionsInput, VendorUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutSubmissionsInput
    upsert?: VendorUpsertWithoutSubmissionsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutSubmissionsInput, VendorUpdateWithoutSubmissionsInput>, VendorUncheckedUpdateWithoutSubmissionsInput>
  }

  export type EvaluationUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<EvaluationCreateWithoutSubmissionInput, EvaluationUncheckedCreateWithoutSubmissionInput> | EvaluationCreateWithoutSubmissionInput[] | EvaluationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSubmissionInput | EvaluationCreateOrConnectWithoutSubmissionInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutSubmissionInput | EvaluationUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: EvaluationCreateManySubmissionInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutSubmissionInput | EvaluationUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutSubmissionInput | EvaluationUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsInput
    connect?: UserWhereUniqueInput
  }

  export type RFQSubmissionCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<RFQSubmissionCreateWithoutEvaluationsInput, RFQSubmissionUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutEvaluationsInput
    connect?: RFQSubmissionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsInput
    upsert?: UserUpsertWithoutEvaluationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvaluationsInput, UserUpdateWithoutEvaluationsInput>, UserUncheckedUpdateWithoutEvaluationsInput>
  }

  export type RFQSubmissionUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<RFQSubmissionCreateWithoutEvaluationsInput, RFQSubmissionUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: RFQSubmissionCreateOrConnectWithoutEvaluationsInput
    upsert?: RFQSubmissionUpsertWithoutEvaluationsInput
    connect?: RFQSubmissionWhereUniqueInput
    update?: XOR<XOR<RFQSubmissionUpdateToOneWithWhereWithoutEvaluationsInput, RFQSubmissionUpdateWithoutEvaluationsInput>, RFQSubmissionUncheckedUpdateWithoutEvaluationsInput>
  }

  export type RFQCreateNestedOneWithoutContractsInput = {
    create?: XOR<RFQCreateWithoutContractsInput, RFQUncheckedCreateWithoutContractsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutContractsInput
    connect?: RFQWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutContractsInput = {
    create?: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContractsInput
    connect?: VendorWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutContractInput = {
    create?: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput> | DocumentCreateWithoutContractInput[] | DocumentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutContractInput | DocumentCreateOrConnectWithoutContractInput[]
    createMany?: DocumentCreateManyContractInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type IPCCreateNestedManyWithoutContractInput = {
    create?: XOR<IPCCreateWithoutContractInput, IPCUncheckedCreateWithoutContractInput> | IPCCreateWithoutContractInput[] | IPCUncheckedCreateWithoutContractInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutContractInput | IPCCreateOrConnectWithoutContractInput[]
    createMany?: IPCCreateManyContractInputEnvelope
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
  }

  export type VariationOrderCreateNestedManyWithoutContractInput = {
    create?: XOR<VariationOrderCreateWithoutContractInput, VariationOrderUncheckedCreateWithoutContractInput> | VariationOrderCreateWithoutContractInput[] | VariationOrderUncheckedCreateWithoutContractInput[]
    connectOrCreate?: VariationOrderCreateOrConnectWithoutContractInput | VariationOrderCreateOrConnectWithoutContractInput[]
    createMany?: VariationOrderCreateManyContractInputEnvelope
    connect?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput> | DocumentCreateWithoutContractInput[] | DocumentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutContractInput | DocumentCreateOrConnectWithoutContractInput[]
    createMany?: DocumentCreateManyContractInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type IPCUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<IPCCreateWithoutContractInput, IPCUncheckedCreateWithoutContractInput> | IPCCreateWithoutContractInput[] | IPCUncheckedCreateWithoutContractInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutContractInput | IPCCreateOrConnectWithoutContractInput[]
    createMany?: IPCCreateManyContractInputEnvelope
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
  }

  export type VariationOrderUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<VariationOrderCreateWithoutContractInput, VariationOrderUncheckedCreateWithoutContractInput> | VariationOrderCreateWithoutContractInput[] | VariationOrderUncheckedCreateWithoutContractInput[]
    connectOrCreate?: VariationOrderCreateOrConnectWithoutContractInput | VariationOrderCreateOrConnectWithoutContractInput[]
    createMany?: VariationOrderCreateManyContractInputEnvelope
    connect?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
  }

  export type RFQUpdateOneWithoutContractsNestedInput = {
    create?: XOR<RFQCreateWithoutContractsInput, RFQUncheckedCreateWithoutContractsInput>
    connectOrCreate?: RFQCreateOrConnectWithoutContractsInput
    upsert?: RFQUpsertWithoutContractsInput
    disconnect?: RFQWhereInput | boolean
    delete?: RFQWhereInput | boolean
    connect?: RFQWhereUniqueInput
    update?: XOR<XOR<RFQUpdateToOneWithWhereWithoutContractsInput, RFQUpdateWithoutContractsInput>, RFQUncheckedUpdateWithoutContractsInput>
  }

  export type VendorUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContractsInput
    upsert?: VendorUpsertWithoutContractsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutContractsInput, VendorUpdateWithoutContractsInput>, VendorUncheckedUpdateWithoutContractsInput>
  }

  export type DocumentUpdateManyWithoutContractNestedInput = {
    create?: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput> | DocumentCreateWithoutContractInput[] | DocumentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutContractInput | DocumentCreateOrConnectWithoutContractInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutContractInput | DocumentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: DocumentCreateManyContractInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutContractInput | DocumentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutContractInput | DocumentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type IPCUpdateManyWithoutContractNestedInput = {
    create?: XOR<IPCCreateWithoutContractInput, IPCUncheckedCreateWithoutContractInput> | IPCCreateWithoutContractInput[] | IPCUncheckedCreateWithoutContractInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutContractInput | IPCCreateOrConnectWithoutContractInput[]
    upsert?: IPCUpsertWithWhereUniqueWithoutContractInput | IPCUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: IPCCreateManyContractInputEnvelope
    set?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    disconnect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    delete?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    update?: IPCUpdateWithWhereUniqueWithoutContractInput | IPCUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: IPCUpdateManyWithWhereWithoutContractInput | IPCUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: IPCScalarWhereInput | IPCScalarWhereInput[]
  }

  export type VariationOrderUpdateManyWithoutContractNestedInput = {
    create?: XOR<VariationOrderCreateWithoutContractInput, VariationOrderUncheckedCreateWithoutContractInput> | VariationOrderCreateWithoutContractInput[] | VariationOrderUncheckedCreateWithoutContractInput[]
    connectOrCreate?: VariationOrderCreateOrConnectWithoutContractInput | VariationOrderCreateOrConnectWithoutContractInput[]
    upsert?: VariationOrderUpsertWithWhereUniqueWithoutContractInput | VariationOrderUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: VariationOrderCreateManyContractInputEnvelope
    set?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    disconnect?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    delete?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    connect?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    update?: VariationOrderUpdateWithWhereUniqueWithoutContractInput | VariationOrderUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: VariationOrderUpdateManyWithWhereWithoutContractInput | VariationOrderUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: VariationOrderScalarWhereInput | VariationOrderScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput> | DocumentCreateWithoutContractInput[] | DocumentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutContractInput | DocumentCreateOrConnectWithoutContractInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutContractInput | DocumentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: DocumentCreateManyContractInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutContractInput | DocumentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutContractInput | DocumentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type IPCUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<IPCCreateWithoutContractInput, IPCUncheckedCreateWithoutContractInput> | IPCCreateWithoutContractInput[] | IPCUncheckedCreateWithoutContractInput[]
    connectOrCreate?: IPCCreateOrConnectWithoutContractInput | IPCCreateOrConnectWithoutContractInput[]
    upsert?: IPCUpsertWithWhereUniqueWithoutContractInput | IPCUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: IPCCreateManyContractInputEnvelope
    set?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    disconnect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    delete?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    connect?: IPCWhereUniqueInput | IPCWhereUniqueInput[]
    update?: IPCUpdateWithWhereUniqueWithoutContractInput | IPCUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: IPCUpdateManyWithWhereWithoutContractInput | IPCUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: IPCScalarWhereInput | IPCScalarWhereInput[]
  }

  export type VariationOrderUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<VariationOrderCreateWithoutContractInput, VariationOrderUncheckedCreateWithoutContractInput> | VariationOrderCreateWithoutContractInput[] | VariationOrderUncheckedCreateWithoutContractInput[]
    connectOrCreate?: VariationOrderCreateOrConnectWithoutContractInput | VariationOrderCreateOrConnectWithoutContractInput[]
    upsert?: VariationOrderUpsertWithWhereUniqueWithoutContractInput | VariationOrderUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: VariationOrderCreateManyContractInputEnvelope
    set?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    disconnect?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    delete?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    connect?: VariationOrderWhereUniqueInput | VariationOrderWhereUniqueInput[]
    update?: VariationOrderUpdateWithWhereUniqueWithoutContractInput | VariationOrderUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: VariationOrderUpdateManyWithWhereWithoutContractInput | VariationOrderUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: VariationOrderScalarWhereInput | VariationOrderScalarWhereInput[]
  }

  export type ContractCreateNestedOneWithoutVariationOrdersInput = {
    create?: XOR<ContractCreateWithoutVariationOrdersInput, ContractUncheckedCreateWithoutVariationOrdersInput>
    connectOrCreate?: ContractCreateOrConnectWithoutVariationOrdersInput
    connect?: ContractWhereUniqueInput
  }

  export type ContractUpdateOneRequiredWithoutVariationOrdersNestedInput = {
    create?: XOR<ContractCreateWithoutVariationOrdersInput, ContractUncheckedCreateWithoutVariationOrdersInput>
    connectOrCreate?: ContractCreateOrConnectWithoutVariationOrdersInput
    upsert?: ContractUpsertWithoutVariationOrdersInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutVariationOrdersInput, ContractUpdateWithoutVariationOrdersInput>, ContractUncheckedUpdateWithoutVariationOrdersInput>
  }

  export type DocumentCreateNestedManyWithoutIpcInput = {
    create?: XOR<DocumentCreateWithoutIpcInput, DocumentUncheckedCreateWithoutIpcInput> | DocumentCreateWithoutIpcInput[] | DocumentUncheckedCreateWithoutIpcInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutIpcInput | DocumentCreateOrConnectWithoutIpcInput[]
    createMany?: DocumentCreateManyIpcInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ContractCreateNestedOneWithoutIpcsInput = {
    create?: XOR<ContractCreateWithoutIpcsInput, ContractUncheckedCreateWithoutIpcsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutIpcsInput
    connect?: ContractWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIpcsInput = {
    create?: XOR<UserCreateWithoutIpcsInput, UserUncheckedCreateWithoutIpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIpcsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutIpcInput = {
    create?: XOR<DocumentCreateWithoutIpcInput, DocumentUncheckedCreateWithoutIpcInput> | DocumentCreateWithoutIpcInput[] | DocumentUncheckedCreateWithoutIpcInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutIpcInput | DocumentCreateOrConnectWithoutIpcInput[]
    createMany?: DocumentCreateManyIpcInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnumIPCStatusFieldUpdateOperationsInput = {
    set?: $Enums.IPCStatus
  }

  export type DocumentUpdateManyWithoutIpcNestedInput = {
    create?: XOR<DocumentCreateWithoutIpcInput, DocumentUncheckedCreateWithoutIpcInput> | DocumentCreateWithoutIpcInput[] | DocumentUncheckedCreateWithoutIpcInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutIpcInput | DocumentCreateOrConnectWithoutIpcInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutIpcInput | DocumentUpsertWithWhereUniqueWithoutIpcInput[]
    createMany?: DocumentCreateManyIpcInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutIpcInput | DocumentUpdateWithWhereUniqueWithoutIpcInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutIpcInput | DocumentUpdateManyWithWhereWithoutIpcInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ContractUpdateOneRequiredWithoutIpcsNestedInput = {
    create?: XOR<ContractCreateWithoutIpcsInput, ContractUncheckedCreateWithoutIpcsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutIpcsInput
    upsert?: ContractUpsertWithoutIpcsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutIpcsInput, ContractUpdateWithoutIpcsInput>, ContractUncheckedUpdateWithoutIpcsInput>
  }

  export type UserUpdateOneRequiredWithoutIpcsNestedInput = {
    create?: XOR<UserCreateWithoutIpcsInput, UserUncheckedCreateWithoutIpcsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIpcsInput
    upsert?: UserUpsertWithoutIpcsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIpcsInput, UserUpdateWithoutIpcsInput>, UserUncheckedUpdateWithoutIpcsInput>
  }

  export type DocumentUncheckedUpdateManyWithoutIpcNestedInput = {
    create?: XOR<DocumentCreateWithoutIpcInput, DocumentUncheckedCreateWithoutIpcInput> | DocumentCreateWithoutIpcInput[] | DocumentUncheckedCreateWithoutIpcInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutIpcInput | DocumentCreateOrConnectWithoutIpcInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutIpcInput | DocumentUpsertWithWhereUniqueWithoutIpcInput[]
    createMany?: DocumentCreateManyIpcInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutIpcInput | DocumentUpdateWithWhereUniqueWithoutIpcInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutIpcInput | DocumentUpdateManyWithWhereWithoutIpcInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ContractCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutDocumentsInput
    connect?: ContractWhereUniqueInput
  }

  export type IPCCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<IPCCreateWithoutAttachmentsInput, IPCUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: IPCCreateOrConnectWithoutAttachmentsInput
    connect?: IPCWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type RFQCreateNestedManyWithoutAttachmentsInput = {
    create?: XOR<RFQCreateWithoutAttachmentsInput, RFQUncheckedCreateWithoutAttachmentsInput> | RFQCreateWithoutAttachmentsInput[] | RFQUncheckedCreateWithoutAttachmentsInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutAttachmentsInput | RFQCreateOrConnectWithoutAttachmentsInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type RFQUncheckedCreateNestedManyWithoutAttachmentsInput = {
    create?: XOR<RFQCreateWithoutAttachmentsInput, RFQUncheckedCreateWithoutAttachmentsInput> | RFQCreateWithoutAttachmentsInput[] | RFQUncheckedCreateWithoutAttachmentsInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutAttachmentsInput | RFQCreateOrConnectWithoutAttachmentsInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
  }

  export type ContractUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutDocumentsInput
    upsert?: ContractUpsertWithoutDocumentsInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutDocumentsInput, ContractUpdateWithoutDocumentsInput>, ContractUncheckedUpdateWithoutDocumentsInput>
  }

  export type IPCUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<IPCCreateWithoutAttachmentsInput, IPCUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: IPCCreateOrConnectWithoutAttachmentsInput
    upsert?: IPCUpsertWithoutAttachmentsInput
    disconnect?: IPCWhereInput | boolean
    delete?: IPCWhereInput | boolean
    connect?: IPCWhereUniqueInput
    update?: XOR<XOR<IPCUpdateToOneWithWhereWithoutAttachmentsInput, IPCUpdateWithoutAttachmentsInput>, IPCUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type RFQUpdateManyWithoutAttachmentsNestedInput = {
    create?: XOR<RFQCreateWithoutAttachmentsInput, RFQUncheckedCreateWithoutAttachmentsInput> | RFQCreateWithoutAttachmentsInput[] | RFQUncheckedCreateWithoutAttachmentsInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutAttachmentsInput | RFQCreateOrConnectWithoutAttachmentsInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutAttachmentsInput | RFQUpsertWithWhereUniqueWithoutAttachmentsInput[]
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutAttachmentsInput | RFQUpdateWithWhereUniqueWithoutAttachmentsInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutAttachmentsInput | RFQUpdateManyWithWhereWithoutAttachmentsInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type RFQUncheckedUpdateManyWithoutAttachmentsNestedInput = {
    create?: XOR<RFQCreateWithoutAttachmentsInput, RFQUncheckedCreateWithoutAttachmentsInput> | RFQCreateWithoutAttachmentsInput[] | RFQUncheckedCreateWithoutAttachmentsInput[]
    connectOrCreate?: RFQCreateOrConnectWithoutAttachmentsInput | RFQCreateOrConnectWithoutAttachmentsInput[]
    upsert?: RFQUpsertWithWhereUniqueWithoutAttachmentsInput | RFQUpsertWithWhereUniqueWithoutAttachmentsInput[]
    set?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    disconnect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    delete?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    connect?: RFQWhereUniqueInput | RFQWhereUniqueInput[]
    update?: RFQUpdateWithWhereUniqueWithoutAttachmentsInput | RFQUpdateWithWhereUniqueWithoutAttachmentsInput[]
    updateMany?: RFQUpdateManyWithWhereWithoutAttachmentsInput | RFQUpdateManyWithWhereWithoutAttachmentsInput[]
    deleteMany?: RFQScalarWhereInput | RFQScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type UserUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    upsert?: UserUpsertWithoutApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalsInput, UserUpdateWithoutApprovalsInput>, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVendorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusFilter<$PrismaModel> | $Enums.VendorStatus
  }

  export type NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VendorStatus | EnumVendorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VendorStatus[] | ListEnumVendorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVendorStatusWithAggregatesFilter<$PrismaModel> | $Enums.VendorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVendorStatusFilter<$PrismaModel>
    _max?: NestedEnumVendorStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRFQStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RFQStatus | EnumRFQStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRFQStatusFilter<$PrismaModel> | $Enums.RFQStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRFQStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RFQStatus | EnumRFQStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RFQStatus[] | ListEnumRFQStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRFQStatusWithAggregatesFilter<$PrismaModel> | $Enums.RFQStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRFQStatusFilter<$PrismaModel>
    _max?: NestedEnumRFQStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumIPCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IPCStatus | EnumIPCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIPCStatusFilter<$PrismaModel> | $Enums.IPCStatus
  }

  export type NestedEnumIPCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IPCStatus | EnumIPCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IPCStatus[] | ListEnumIPCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIPCStatusWithAggregatesFilter<$PrismaModel> | $Enums.IPCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIPCStatusFilter<$PrismaModel>
    _max?: NestedEnumIPCStatusFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type ApprovalCreateWithoutApproverInput = {
    entityType: string
    entityId: number
    sequence: number
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    actedAt?: Date | string | null
  }

  export type ApprovalUncheckedCreateWithoutApproverInput = {
    id?: number
    entityType: string
    entityId: number
    sequence: number
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    actedAt?: Date | string | null
  }

  export type ApprovalCreateOrConnectWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalCreateManyApproverInputEnvelope = {
    data: ApprovalCreateManyApproverInput | ApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    action: string
    entity?: string | null
    entityId?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    entity?: string | null
    entityId?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUploadedByInput = {
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedAt?: Date | string
    contract?: ContractCreateNestedOneWithoutDocumentsInput
    ipc?: IPCCreateNestedOneWithoutAttachmentsInput
    rfqAttachments?: RFQCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentUncheckedCreateWithoutUploadedByInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedAt?: Date | string
    ipcId?: number | null
    contractId?: number | null
    rfqAttachments?: RFQUncheckedCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentCreateOrConnectWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentCreateManyUploadedByInputEnvelope = {
    data: DocumentCreateManyUploadedByInput | DocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutEvaluatorInput = {
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
    submission: RFQSubmissionCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutEvaluatorInput = {
    id?: number
    submissionId: number
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
  }

  export type EvaluationCreateOrConnectWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type EvaluationCreateManyEvaluatorInputEnvelope = {
    data: EvaluationCreateManyEvaluatorInput | EvaluationCreateManyEvaluatorInput[]
    skipDuplicates?: boolean
  }

  export type IPCCreateWithoutSubmittedByInput = {
    ipcNumber: string
    projectName?: string | null
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    createdAt?: Date | string
    attachments?: DocumentCreateNestedManyWithoutIpcInput
    contract: ContractCreateNestedOneWithoutIpcsInput
  }

  export type IPCUncheckedCreateWithoutSubmittedByInput = {
    id?: number
    ipcNumber: string
    projectName?: string | null
    contractId: number
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    createdAt?: Date | string
    attachments?: DocumentUncheckedCreateNestedManyWithoutIpcInput
  }

  export type IPCCreateOrConnectWithoutSubmittedByInput = {
    where: IPCWhereUniqueInput
    create: XOR<IPCCreateWithoutSubmittedByInput, IPCUncheckedCreateWithoutSubmittedByInput>
  }

  export type IPCCreateManySubmittedByInputEnvelope = {
    data: IPCCreateManySubmittedByInput | IPCCreateManySubmittedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    body?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    body?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RFQCreateWithoutCreatedByInput = {
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutRfqInput
    submissions?: RFQSubmissionCreateNestedManyWithoutRfqInput
    attachments?: DocumentCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQUncheckedCreateWithoutCreatedByInput = {
    id?: number
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutRfqInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutRfqInput
    attachments?: DocumentUncheckedCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQCreateOrConnectWithoutCreatedByInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput>
  }

  export type RFQCreateManyCreatedByInputEnvelope = {
    data: RFQCreateManyCreatedByInput | RFQCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUsersInput = {
    desc?: string | null
    name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    desc?: string | null
    name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type VendorCreateWithoutUsersInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryCreateNestedManyWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutUsersInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentUncheckedCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorCreateOrConnectWithoutUsersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
  }

  export type ApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutApproverInput, ApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutApproverInput, ApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type ApprovalScalarWhereInput = {
    AND?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    OR?: ApprovalScalarWhereInput[]
    NOT?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    id?: IntFilter<"Approval"> | number
    entityType?: StringFilter<"Approval"> | string
    entityId?: IntFilter<"Approval"> | number
    approverId?: IntFilter<"Approval"> | number
    sequence?: IntFilter<"Approval"> | number
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    actedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    data?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: IntFilter<"Document"> | number
    fileName?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    mimeType?: StringNullableFilter<"Document"> | string | null
    size?: IntNullableFilter<"Document"> | number | null
    uploadedById?: IntNullableFilter<"Document"> | number | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    ipcId?: IntNullableFilter<"Document"> | number | null
    contractId?: IntNullableFilter<"Document"> | number | null
  }

  export type EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutEvaluatorInput, EvaluationUncheckedUpdateWithoutEvaluatorInput>
    create: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutEvaluatorInput, EvaluationUncheckedUpdateWithoutEvaluatorInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutEvaluatorInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutEvaluatorInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    id?: IntFilter<"Evaluation"> | number
    submissionId?: IntFilter<"Evaluation"> | number
    evaluatorId?: IntFilter<"Evaluation"> | number
    technicalScore?: FloatNullableFilter<"Evaluation"> | number | null
    financialScore?: FloatNullableFilter<"Evaluation"> | number | null
    experienceScore?: FloatNullableFilter<"Evaluation"> | number | null
    responsiveness?: FloatNullableFilter<"Evaluation"> | number | null
    otherScore?: FloatNullableFilter<"Evaluation"> | number | null
    totalScore?: FloatNullableFilter<"Evaluation"> | number | null
    comments?: StringNullableFilter<"Evaluation"> | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
  }

  export type IPCUpsertWithWhereUniqueWithoutSubmittedByInput = {
    where: IPCWhereUniqueInput
    update: XOR<IPCUpdateWithoutSubmittedByInput, IPCUncheckedUpdateWithoutSubmittedByInput>
    create: XOR<IPCCreateWithoutSubmittedByInput, IPCUncheckedCreateWithoutSubmittedByInput>
  }

  export type IPCUpdateWithWhereUniqueWithoutSubmittedByInput = {
    where: IPCWhereUniqueInput
    data: XOR<IPCUpdateWithoutSubmittedByInput, IPCUncheckedUpdateWithoutSubmittedByInput>
  }

  export type IPCUpdateManyWithWhereWithoutSubmittedByInput = {
    where: IPCScalarWhereInput
    data: XOR<IPCUpdateManyMutationInput, IPCUncheckedUpdateManyWithoutSubmittedByInput>
  }

  export type IPCScalarWhereInput = {
    AND?: IPCScalarWhereInput | IPCScalarWhereInput[]
    OR?: IPCScalarWhereInput[]
    NOT?: IPCScalarWhereInput | IPCScalarWhereInput[]
    id?: IntFilter<"IPC"> | number
    ipcNumber?: StringFilter<"IPC"> | string
    projectName?: StringNullableFilter<"IPC"> | string | null
    contractId?: IntFilter<"IPC"> | number
    periodFrom?: DateTimeNullableFilter<"IPC"> | Date | string | null
    periodTo?: DateTimeNullableFilter<"IPC"> | Date | string | null
    currentValue?: FloatFilter<"IPC"> | number
    cumulativeValue?: FloatNullableFilter<"IPC"> | number | null
    deductions?: FloatNullableFilter<"IPC"> | number | null
    netPayable?: FloatNullableFilter<"IPC"> | number | null
    status?: EnumIPCStatusFilter<"IPC"> | $Enums.IPCStatus
    submittedById?: IntFilter<"IPC"> | number
    createdAt?: DateTimeFilter<"IPC"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type RFQUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RFQWhereUniqueInput
    update: XOR<RFQUpdateWithoutCreatedByInput, RFQUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RFQCreateWithoutCreatedByInput, RFQUncheckedCreateWithoutCreatedByInput>
  }

  export type RFQUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RFQWhereUniqueInput
    data: XOR<RFQUpdateWithoutCreatedByInput, RFQUncheckedUpdateWithoutCreatedByInput>
  }

  export type RFQUpdateManyWithWhereWithoutCreatedByInput = {
    where: RFQScalarWhereInput
    data: XOR<RFQUpdateManyMutationInput, RFQUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RFQScalarWhereInput = {
    AND?: RFQScalarWhereInput | RFQScalarWhereInput[]
    OR?: RFQScalarWhereInput[]
    NOT?: RFQScalarWhereInput | RFQScalarWhereInput[]
    id?: IntFilter<"RFQ"> | number
    rfqNumber?: StringFilter<"RFQ"> | string
    projectName?: StringFilter<"RFQ"> | string
    packageScope?: StringNullableFilter<"RFQ"> | string | null
    itemDesc?: StringNullableFilter<"RFQ"> | string | null
    csiCode?: StringNullableFilter<"RFQ"> | string | null
    estimatedUnitPrice?: FloatNullableFilter<"RFQ"> | number | null
    requiredDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    targetSubmissionDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    currency?: StringFilter<"RFQ"> | string
    createdById?: IntFilter<"RFQ"> | number
    status?: EnumRFQStatusFilter<"RFQ"> | $Enums.RFQStatus
    createdAt?: DateTimeFilter<"RFQ"> | Date | string
    description?: StringNullableFilter<"RFQ"> | string | null
    dueDate?: DateTimeNullableFilter<"RFQ"> | Date | string | null
    title?: StringFilter<"RFQ"> | string
    updatedAt?: DateTimeFilter<"RFQ"> | Date | string
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VendorUpsertWithoutUsersInput = {
    update: XOR<VendorUpdateWithoutUsersInput, VendorUncheckedUpdateWithoutUsersInput>
    create: XOR<VendorCreateWithoutUsersInput, VendorUncheckedCreateWithoutUsersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutUsersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutUsersInput, VendorUncheckedUpdateWithoutUsersInput>
  }

  export type VendorUpdateWithoutUsersInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUpdateManyWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type UserCreateWithoutRoleInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    uuid?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    vendorId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accessCode?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
  }

  export type CSI_MaterialCreateWithoutDefaultVendorInput = {
    csiCode?: string | null
    name: string
    unit?: string | null
    priceEntries?: PriceEntryCreateNestedManyWithoutMaterialInput
  }

  export type CSI_MaterialUncheckedCreateWithoutDefaultVendorInput = {
    id?: number
    csiCode?: string | null
    name: string
    unit?: string | null
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type CSI_MaterialCreateOrConnectWithoutDefaultVendorInput = {
    where: CSI_MaterialWhereUniqueInput
    create: XOR<CSI_MaterialCreateWithoutDefaultVendorInput, CSI_MaterialUncheckedCreateWithoutDefaultVendorInput>
  }

  export type CSI_MaterialCreateManyDefaultVendorInputEnvelope = {
    data: CSI_MaterialCreateManyDefaultVendorInput | CSI_MaterialCreateManyDefaultVendorInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutVendorInput = {
    contractNumber: string
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    rfq?: RFQCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    ipcs?: IPCCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutVendorInput = {
    id?: number
    contractNumber: string
    rfqId?: number | null
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutVendorInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput>
  }

  export type ContractCreateManyVendorInputEnvelope = {
    data: ContractCreateManyVendorInput | ContractCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PriceEntryCreateWithoutVendorInput = {
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
    material: CSI_MaterialCreateNestedOneWithoutPriceEntriesInput
  }

  export type PriceEntryUncheckedCreateWithoutVendorInput = {
    id?: number
    materialId: number
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
  }

  export type PriceEntryCreateOrConnectWithoutVendorInput = {
    where: PriceEntryWhereUniqueInput
    create: XOR<PriceEntryCreateWithoutVendorInput, PriceEntryUncheckedCreateWithoutVendorInput>
  }

  export type PriceEntryCreateManyVendorInputEnvelope = {
    data: PriceEntryCreateManyVendorInput | PriceEntryCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type RFQSubmissionCreateWithoutVendorInput = {
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
    evaluations?: EvaluationCreateNestedManyWithoutSubmissionInput
    rfq: RFQCreateNestedOneWithoutSubmissionsInput
  }

  export type RFQSubmissionUncheckedCreateWithoutVendorInput = {
    id?: number
    rfqId: number
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type RFQSubmissionCreateOrConnectWithoutVendorInput = {
    where: RFQSubmissionWhereUniqueInput
    create: XOR<RFQSubmissionCreateWithoutVendorInput, RFQSubmissionUncheckedCreateWithoutVendorInput>
  }

  export type RFQSubmissionCreateManyVendorInputEnvelope = {
    data: RFQSubmissionCreateManyVendorInput | RFQSubmissionCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutVendorInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutVendorInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutVendorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type UserCreateManyVendorInputEnvelope = {
    data: UserCreateManyVendorInput | UserCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorDocumentCreateWithoutVendorInput = {
    docType: string
    url: string
    fileName: string
    expiryDate?: Date | string | null
    uploadedAt?: Date | string
  }

  export type VendorDocumentUncheckedCreateWithoutVendorInput = {
    id?: number
    docType: string
    url: string
    fileName: string
    expiryDate?: Date | string | null
    uploadedAt?: Date | string
  }

  export type VendorDocumentCreateOrConnectWithoutVendorInput = {
    where: VendorDocumentWhereUniqueInput
    create: XOR<VendorDocumentCreateWithoutVendorInput, VendorDocumentUncheckedCreateWithoutVendorInput>
  }

  export type VendorDocumentCreateManyVendorInputEnvelope = {
    data: VendorDocumentCreateManyVendorInput | VendorDocumentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorCategoryCreateWithoutVendorsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCategoryUncheckedCreateWithoutVendorsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCategoryCreateOrConnectWithoutVendorsInput = {
    where: VendorCategoryWhereUniqueInput
    create: XOR<VendorCategoryCreateWithoutVendorsInput, VendorCategoryUncheckedCreateWithoutVendorsInput>
  }

  export type CSI_MaterialUpsertWithWhereUniqueWithoutDefaultVendorInput = {
    where: CSI_MaterialWhereUniqueInput
    update: XOR<CSI_MaterialUpdateWithoutDefaultVendorInput, CSI_MaterialUncheckedUpdateWithoutDefaultVendorInput>
    create: XOR<CSI_MaterialCreateWithoutDefaultVendorInput, CSI_MaterialUncheckedCreateWithoutDefaultVendorInput>
  }

  export type CSI_MaterialUpdateWithWhereUniqueWithoutDefaultVendorInput = {
    where: CSI_MaterialWhereUniqueInput
    data: XOR<CSI_MaterialUpdateWithoutDefaultVendorInput, CSI_MaterialUncheckedUpdateWithoutDefaultVendorInput>
  }

  export type CSI_MaterialUpdateManyWithWhereWithoutDefaultVendorInput = {
    where: CSI_MaterialScalarWhereInput
    data: XOR<CSI_MaterialUpdateManyMutationInput, CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorInput>
  }

  export type CSI_MaterialScalarWhereInput = {
    AND?: CSI_MaterialScalarWhereInput | CSI_MaterialScalarWhereInput[]
    OR?: CSI_MaterialScalarWhereInput[]
    NOT?: CSI_MaterialScalarWhereInput | CSI_MaterialScalarWhereInput[]
    id?: IntFilter<"CSI_Material"> | number
    csiCode?: StringNullableFilter<"CSI_Material"> | string | null
    name?: StringFilter<"CSI_Material"> | string
    unit?: StringNullableFilter<"CSI_Material"> | string | null
    defaultVendorId?: IntNullableFilter<"CSI_Material"> | number | null
  }

  export type ContractUpsertWithWhereUniqueWithoutVendorInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutVendorInput, ContractUncheckedUpdateWithoutVendorInput>
    create: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutVendorInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutVendorInput, ContractUncheckedUpdateWithoutVendorInput>
  }

  export type ContractUpdateManyWithWhereWithoutVendorInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutVendorInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: IntFilter<"Contract"> | number
    contractNumber?: StringFilter<"Contract"> | string
    rfqId?: IntNullableFilter<"Contract"> | number | null
    vendorId?: IntFilter<"Contract"> | number
    contractValue?: FloatFilter<"Contract"> | number
    currency?: StringFilter<"Contract"> | string
    startDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: StringNullableFilter<"Contract"> | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
  }

  export type PriceEntryUpsertWithWhereUniqueWithoutVendorInput = {
    where: PriceEntryWhereUniqueInput
    update: XOR<PriceEntryUpdateWithoutVendorInput, PriceEntryUncheckedUpdateWithoutVendorInput>
    create: XOR<PriceEntryCreateWithoutVendorInput, PriceEntryUncheckedCreateWithoutVendorInput>
  }

  export type PriceEntryUpdateWithWhereUniqueWithoutVendorInput = {
    where: PriceEntryWhereUniqueInput
    data: XOR<PriceEntryUpdateWithoutVendorInput, PriceEntryUncheckedUpdateWithoutVendorInput>
  }

  export type PriceEntryUpdateManyWithWhereWithoutVendorInput = {
    where: PriceEntryScalarWhereInput
    data: XOR<PriceEntryUpdateManyMutationInput, PriceEntryUncheckedUpdateManyWithoutVendorInput>
  }

  export type PriceEntryScalarWhereInput = {
    AND?: PriceEntryScalarWhereInput | PriceEntryScalarWhereInput[]
    OR?: PriceEntryScalarWhereInput[]
    NOT?: PriceEntryScalarWhereInput | PriceEntryScalarWhereInput[]
    id?: IntFilter<"PriceEntry"> | number
    materialId?: IntFilter<"PriceEntry"> | number
    vendorId?: IntFilter<"PriceEntry"> | number
    unitPrice?: FloatFilter<"PriceEntry"> | number
    currency?: StringFilter<"PriceEntry"> | string
    createdAt?: DateTimeFilter<"PriceEntry"> | Date | string
    effectiveDate?: DateTimeFilter<"PriceEntry"> | Date | string
    expiryDate?: DateTimeNullableFilter<"PriceEntry"> | Date | string | null
    updatedAt?: DateTimeFilter<"PriceEntry"> | Date | string
  }

  export type RFQSubmissionUpsertWithWhereUniqueWithoutVendorInput = {
    where: RFQSubmissionWhereUniqueInput
    update: XOR<RFQSubmissionUpdateWithoutVendorInput, RFQSubmissionUncheckedUpdateWithoutVendorInput>
    create: XOR<RFQSubmissionCreateWithoutVendorInput, RFQSubmissionUncheckedCreateWithoutVendorInput>
  }

  export type RFQSubmissionUpdateWithWhereUniqueWithoutVendorInput = {
    where: RFQSubmissionWhereUniqueInput
    data: XOR<RFQSubmissionUpdateWithoutVendorInput, RFQSubmissionUncheckedUpdateWithoutVendorInput>
  }

  export type RFQSubmissionUpdateManyWithWhereWithoutVendorInput = {
    where: RFQSubmissionScalarWhereInput
    data: XOR<RFQSubmissionUpdateManyMutationInput, RFQSubmissionUncheckedUpdateManyWithoutVendorInput>
  }

  export type RFQSubmissionScalarWhereInput = {
    AND?: RFQSubmissionScalarWhereInput | RFQSubmissionScalarWhereInput[]
    OR?: RFQSubmissionScalarWhereInput[]
    NOT?: RFQSubmissionScalarWhereInput | RFQSubmissionScalarWhereInput[]
    id?: IntFilter<"RFQSubmission"> | number
    rfqId?: IntFilter<"RFQSubmission"> | number
    vendorId?: IntFilter<"RFQSubmission"> | number
    submittedAt?: DateTimeNullableFilter<"RFQSubmission"> | Date | string | null
    totalValue?: FloatNullableFilter<"RFQSubmission"> | number | null
    currency?: StringFilter<"RFQSubmission"> | string
    docUrl?: StringNullableFilter<"RFQSubmission"> | string | null
    items?: JsonNullableFilter<"RFQSubmission">
    status?: StringNullableFilter<"RFQSubmission"> | string | null
    totalAmount?: FloatNullableFilter<"RFQSubmission"> | number | null
  }

  export type UserUpsertWithWhereUniqueWithoutVendorInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type UserUpdateWithWhereUniqueWithoutVendorInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
  }

  export type UserUpdateManyWithWhereWithoutVendorInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorDocumentUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorDocumentWhereUniqueInput
    update: XOR<VendorDocumentUpdateWithoutVendorInput, VendorDocumentUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorDocumentCreateWithoutVendorInput, VendorDocumentUncheckedCreateWithoutVendorInput>
  }

  export type VendorDocumentUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorDocumentWhereUniqueInput
    data: XOR<VendorDocumentUpdateWithoutVendorInput, VendorDocumentUncheckedUpdateWithoutVendorInput>
  }

  export type VendorDocumentUpdateManyWithWhereWithoutVendorInput = {
    where: VendorDocumentScalarWhereInput
    data: XOR<VendorDocumentUpdateManyMutationInput, VendorDocumentUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorDocumentScalarWhereInput = {
    AND?: VendorDocumentScalarWhereInput | VendorDocumentScalarWhereInput[]
    OR?: VendorDocumentScalarWhereInput[]
    NOT?: VendorDocumentScalarWhereInput | VendorDocumentScalarWhereInput[]
    id?: IntFilter<"VendorDocument"> | number
    vendorId?: IntFilter<"VendorDocument"> | number
    docType?: StringFilter<"VendorDocument"> | string
    url?: StringFilter<"VendorDocument"> | string
    fileName?: StringFilter<"VendorDocument"> | string
    expiryDate?: DateTimeNullableFilter<"VendorDocument"> | Date | string | null
    uploadedAt?: DateTimeFilter<"VendorDocument"> | Date | string
  }

  export type VendorCategoryUpsertWithWhereUniqueWithoutVendorsInput = {
    where: VendorCategoryWhereUniqueInput
    update: XOR<VendorCategoryUpdateWithoutVendorsInput, VendorCategoryUncheckedUpdateWithoutVendorsInput>
    create: XOR<VendorCategoryCreateWithoutVendorsInput, VendorCategoryUncheckedCreateWithoutVendorsInput>
  }

  export type VendorCategoryUpdateWithWhereUniqueWithoutVendorsInput = {
    where: VendorCategoryWhereUniqueInput
    data: XOR<VendorCategoryUpdateWithoutVendorsInput, VendorCategoryUncheckedUpdateWithoutVendorsInput>
  }

  export type VendorCategoryUpdateManyWithWhereWithoutVendorsInput = {
    where: VendorCategoryScalarWhereInput
    data: XOR<VendorCategoryUpdateManyMutationInput, VendorCategoryUncheckedUpdateManyWithoutVendorsInput>
  }

  export type VendorCategoryScalarWhereInput = {
    AND?: VendorCategoryScalarWhereInput | VendorCategoryScalarWhereInput[]
    OR?: VendorCategoryScalarWhereInput[]
    NOT?: VendorCategoryScalarWhereInput | VendorCategoryScalarWhereInput[]
    id?: IntFilter<"VendorCategory"> | number
    name?: StringFilter<"VendorCategory"> | string
    createdAt?: DateTimeFilter<"VendorCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VendorCategory"> | Date | string
  }

  export type VendorCreateWithoutCategoriesInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionCreateNestedManyWithoutVendorInput
    users?: UserCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutCategoriesInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutCategoriesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutCategoriesInput, VendorUncheckedCreateWithoutCategoriesInput>
  }

  export type VendorUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutCategoriesInput, VendorUncheckedUpdateWithoutCategoriesInput>
    create: XOR<VendorCreateWithoutCategoriesInput, VendorUncheckedCreateWithoutCategoriesInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutCategoriesInput, VendorUncheckedUpdateWithoutCategoriesInput>
  }

  export type VendorUpdateManyWithWhereWithoutCategoriesInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: IntFilter<"Vendor"> | number
    code?: StringNullableFilter<"Vendor"> | string | null
    name?: StringFilter<"Vendor"> | string
    contactName?: StringNullableFilter<"Vendor"> | string | null
    contactEmail?: StringNullableFilter<"Vendor"> | string | null
    contactPhone?: StringNullableFilter<"Vendor"> | string | null
    status?: EnumVendorStatusFilter<"Vendor"> | $Enums.VendorStatus
    address?: StringNullableFilter<"Vendor"> | string | null
    country?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type VendorCreateWithoutDocumentsInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionCreateNestedManyWithoutVendorInput
    users?: UserCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryCreateNestedManyWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutDocumentsInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorCreateOrConnectWithoutDocumentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutDocumentsInput, VendorUncheckedCreateWithoutDocumentsInput>
  }

  export type VendorUpsertWithoutDocumentsInput = {
    update: XOR<VendorUpdateWithoutDocumentsInput, VendorUncheckedUpdateWithoutDocumentsInput>
    create: XOR<VendorCreateWithoutDocumentsInput, VendorUncheckedCreateWithoutDocumentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutDocumentsInput, VendorUncheckedUpdateWithoutDocumentsInput>
  }

  export type VendorUpdateWithoutDocumentsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutVendorNestedInput
    users?: UserUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUpdateManyWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type VendorCreateWithoutMaterialsInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionCreateNestedManyWithoutVendorInput
    users?: UserCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryCreateNestedManyWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutMaterialsInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentUncheckedCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorCreateOrConnectWithoutMaterialsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
  }

  export type PriceEntryCreateWithoutMaterialInput = {
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPriceEntriesInput
  }

  export type PriceEntryUncheckedCreateWithoutMaterialInput = {
    id?: number
    vendorId: number
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
  }

  export type PriceEntryCreateOrConnectWithoutMaterialInput = {
    where: PriceEntryWhereUniqueInput
    create: XOR<PriceEntryCreateWithoutMaterialInput, PriceEntryUncheckedCreateWithoutMaterialInput>
  }

  export type PriceEntryCreateManyMaterialInputEnvelope = {
    data: PriceEntryCreateManyMaterialInput | PriceEntryCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutMaterialsInput = {
    update: XOR<VendorUpdateWithoutMaterialsInput, VendorUncheckedUpdateWithoutMaterialsInput>
    create: XOR<VendorCreateWithoutMaterialsInput, VendorUncheckedCreateWithoutMaterialsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutMaterialsInput, VendorUncheckedUpdateWithoutMaterialsInput>
  }

  export type VendorUpdateWithoutMaterialsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutVendorNestedInput
    users?: UserUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUpdateManyWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type PriceEntryUpsertWithWhereUniqueWithoutMaterialInput = {
    where: PriceEntryWhereUniqueInput
    update: XOR<PriceEntryUpdateWithoutMaterialInput, PriceEntryUncheckedUpdateWithoutMaterialInput>
    create: XOR<PriceEntryCreateWithoutMaterialInput, PriceEntryUncheckedCreateWithoutMaterialInput>
  }

  export type PriceEntryUpdateWithWhereUniqueWithoutMaterialInput = {
    where: PriceEntryWhereUniqueInput
    data: XOR<PriceEntryUpdateWithoutMaterialInput, PriceEntryUncheckedUpdateWithoutMaterialInput>
  }

  export type PriceEntryUpdateManyWithWhereWithoutMaterialInput = {
    where: PriceEntryScalarWhereInput
    data: XOR<PriceEntryUpdateManyMutationInput, PriceEntryUncheckedUpdateManyWithoutMaterialInput>
  }

  export type CSI_MaterialCreateWithoutPriceEntriesInput = {
    csiCode?: string | null
    name: string
    unit?: string | null
    defaultVendor?: VendorCreateNestedOneWithoutMaterialsInput
  }

  export type CSI_MaterialUncheckedCreateWithoutPriceEntriesInput = {
    id?: number
    csiCode?: string | null
    name: string
    unit?: string | null
    defaultVendorId?: number | null
  }

  export type CSI_MaterialCreateOrConnectWithoutPriceEntriesInput = {
    where: CSI_MaterialWhereUniqueInput
    create: XOR<CSI_MaterialCreateWithoutPriceEntriesInput, CSI_MaterialUncheckedCreateWithoutPriceEntriesInput>
  }

  export type VendorCreateWithoutPriceEntriesInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionCreateNestedManyWithoutVendorInput
    users?: UserCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryCreateNestedManyWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutPriceEntriesInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentUncheckedCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorCreateOrConnectWithoutPriceEntriesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPriceEntriesInput, VendorUncheckedCreateWithoutPriceEntriesInput>
  }

  export type CSI_MaterialUpsertWithoutPriceEntriesInput = {
    update: XOR<CSI_MaterialUpdateWithoutPriceEntriesInput, CSI_MaterialUncheckedUpdateWithoutPriceEntriesInput>
    create: XOR<CSI_MaterialCreateWithoutPriceEntriesInput, CSI_MaterialUncheckedCreateWithoutPriceEntriesInput>
    where?: CSI_MaterialWhereInput
  }

  export type CSI_MaterialUpdateToOneWithWhereWithoutPriceEntriesInput = {
    where?: CSI_MaterialWhereInput
    data: XOR<CSI_MaterialUpdateWithoutPriceEntriesInput, CSI_MaterialUncheckedUpdateWithoutPriceEntriesInput>
  }

  export type CSI_MaterialUpdateWithoutPriceEntriesInput = {
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVendor?: VendorUpdateOneWithoutMaterialsNestedInput
  }

  export type CSI_MaterialUncheckedUpdateWithoutPriceEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VendorUpsertWithoutPriceEntriesInput = {
    update: XOR<VendorUpdateWithoutPriceEntriesInput, VendorUncheckedUpdateWithoutPriceEntriesInput>
    create: XOR<VendorCreateWithoutPriceEntriesInput, VendorUncheckedCreateWithoutPriceEntriesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPriceEntriesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPriceEntriesInput, VendorUncheckedUpdateWithoutPriceEntriesInput>
  }

  export type VendorUpdateWithoutPriceEntriesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutVendorNestedInput
    users?: UserUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUpdateManyWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutPriceEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type ContractCreateWithoutRfqInput = {
    contractNumber: string
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    ipcs?: IPCCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutRfqInput = {
    id?: number
    contractNumber: string
    vendorId: number
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutRfqInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutRfqInput, ContractUncheckedCreateWithoutRfqInput>
  }

  export type ContractCreateManyRfqInputEnvelope = {
    data: ContractCreateManyRfqInput | ContractCreateManyRfqInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRfqsInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRfqsInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRfqsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRfqsInput, UserUncheckedCreateWithoutRfqsInput>
  }

  export type RFQSubmissionCreateWithoutRfqInput = {
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
    evaluations?: EvaluationCreateNestedManyWithoutSubmissionInput
    vendor: VendorCreateNestedOneWithoutSubmissionsInput
  }

  export type RFQSubmissionUncheckedCreateWithoutRfqInput = {
    id?: number
    vendorId: number
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type RFQSubmissionCreateOrConnectWithoutRfqInput = {
    where: RFQSubmissionWhereUniqueInput
    create: XOR<RFQSubmissionCreateWithoutRfqInput, RFQSubmissionUncheckedCreateWithoutRfqInput>
  }

  export type RFQSubmissionCreateManyRfqInputEnvelope = {
    data: RFQSubmissionCreateManyRfqInput | RFQSubmissionCreateManyRfqInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutRfqAttachmentsInput = {
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedAt?: Date | string
    contract?: ContractCreateNestedOneWithoutDocumentsInput
    ipc?: IPCCreateNestedOneWithoutAttachmentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutRfqAttachmentsInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedById?: number | null
    uploadedAt?: Date | string
    ipcId?: number | null
    contractId?: number | null
  }

  export type DocumentCreateOrConnectWithoutRfqAttachmentsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutRfqAttachmentsInput, DocumentUncheckedCreateWithoutRfqAttachmentsInput>
  }

  export type ContractUpsertWithWhereUniqueWithoutRfqInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutRfqInput, ContractUncheckedUpdateWithoutRfqInput>
    create: XOR<ContractCreateWithoutRfqInput, ContractUncheckedCreateWithoutRfqInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutRfqInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutRfqInput, ContractUncheckedUpdateWithoutRfqInput>
  }

  export type ContractUpdateManyWithWhereWithoutRfqInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutRfqInput>
  }

  export type UserUpsertWithoutRfqsInput = {
    update: XOR<UserUpdateWithoutRfqsInput, UserUncheckedUpdateWithoutRfqsInput>
    create: XOR<UserCreateWithoutRfqsInput, UserUncheckedCreateWithoutRfqsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRfqsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRfqsInput, UserUncheckedUpdateWithoutRfqsInput>
  }

  export type UserUpdateWithoutRfqsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRfqsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RFQSubmissionUpsertWithWhereUniqueWithoutRfqInput = {
    where: RFQSubmissionWhereUniqueInput
    update: XOR<RFQSubmissionUpdateWithoutRfqInput, RFQSubmissionUncheckedUpdateWithoutRfqInput>
    create: XOR<RFQSubmissionCreateWithoutRfqInput, RFQSubmissionUncheckedCreateWithoutRfqInput>
  }

  export type RFQSubmissionUpdateWithWhereUniqueWithoutRfqInput = {
    where: RFQSubmissionWhereUniqueInput
    data: XOR<RFQSubmissionUpdateWithoutRfqInput, RFQSubmissionUncheckedUpdateWithoutRfqInput>
  }

  export type RFQSubmissionUpdateManyWithWhereWithoutRfqInput = {
    where: RFQSubmissionScalarWhereInput
    data: XOR<RFQSubmissionUpdateManyMutationInput, RFQSubmissionUncheckedUpdateManyWithoutRfqInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutRfqAttachmentsInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutRfqAttachmentsInput, DocumentUncheckedUpdateWithoutRfqAttachmentsInput>
    create: XOR<DocumentCreateWithoutRfqAttachmentsInput, DocumentUncheckedCreateWithoutRfqAttachmentsInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutRfqAttachmentsInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutRfqAttachmentsInput, DocumentUncheckedUpdateWithoutRfqAttachmentsInput>
  }

  export type DocumentUpdateManyWithWhereWithoutRfqAttachmentsInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutRfqAttachmentsInput>
  }

  export type EvaluationCreateWithoutSubmissionInput = {
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutSubmissionInput = {
    id?: number
    evaluatorId: number
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
  }

  export type EvaluationCreateOrConnectWithoutSubmissionInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutSubmissionInput, EvaluationUncheckedCreateWithoutSubmissionInput>
  }

  export type EvaluationCreateManySubmissionInputEnvelope = {
    data: EvaluationCreateManySubmissionInput | EvaluationCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type RFQCreateWithoutSubmissionsInput = {
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutRfqInput
    createdBy: UserCreateNestedOneWithoutRfqsInput
    attachments?: DocumentCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQUncheckedCreateWithoutSubmissionsInput = {
    id?: number
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    createdById: number
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutRfqInput
    attachments?: DocumentUncheckedCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQCreateOrConnectWithoutSubmissionsInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutSubmissionsInput, RFQUncheckedCreateWithoutSubmissionsInput>
  }

  export type VendorCreateWithoutSubmissionsInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryCreateNestedManyWithoutVendorInput
    users?: UserCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryCreateNestedManyWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutSubmissionsInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput
    contracts?: ContractUncheckedCreateNestedManyWithoutVendorInput
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutVendorInput
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentUncheckedCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorCreateOrConnectWithoutSubmissionsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutSubmissionsInput, VendorUncheckedCreateWithoutSubmissionsInput>
  }

  export type EvaluationUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutSubmissionInput, EvaluationUncheckedUpdateWithoutSubmissionInput>
    create: XOR<EvaluationCreateWithoutSubmissionInput, EvaluationUncheckedCreateWithoutSubmissionInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutSubmissionInput, EvaluationUncheckedUpdateWithoutSubmissionInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutSubmissionInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type RFQUpsertWithoutSubmissionsInput = {
    update: XOR<RFQUpdateWithoutSubmissionsInput, RFQUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<RFQCreateWithoutSubmissionsInput, RFQUncheckedCreateWithoutSubmissionsInput>
    where?: RFQWhereInput
  }

  export type RFQUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: RFQWhereInput
    data: XOR<RFQUpdateWithoutSubmissionsInput, RFQUncheckedUpdateWithoutSubmissionsInput>
  }

  export type RFQUpdateWithoutSubmissionsInput = {
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutRfqNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRfqsNestedInput
    attachments?: DocumentUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type RFQUncheckedUpdateWithoutSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutRfqNestedInput
    attachments?: DocumentUncheckedUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type VendorUpsertWithoutSubmissionsInput = {
    update: XOR<VendorUpdateWithoutSubmissionsInput, VendorUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<VendorCreateWithoutSubmissionsInput, VendorUncheckedCreateWithoutSubmissionsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutSubmissionsInput, VendorUncheckedUpdateWithoutSubmissionsInput>
  }

  export type VendorUpdateWithoutSubmissionsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutVendorNestedInput
    users?: UserUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUpdateManyWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutVendorNestedInput
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type UserCreateWithoutEvaluationsInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEvaluationsInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutEvaluationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
  }

  export type RFQSubmissionCreateWithoutEvaluationsInput = {
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
    rfq: RFQCreateNestedOneWithoutSubmissionsInput
    vendor: VendorCreateNestedOneWithoutSubmissionsInput
  }

  export type RFQSubmissionUncheckedCreateWithoutEvaluationsInput = {
    id?: number
    rfqId: number
    vendorId: number
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
  }

  export type RFQSubmissionCreateOrConnectWithoutEvaluationsInput = {
    where: RFQSubmissionWhereUniqueInput
    create: XOR<RFQSubmissionCreateWithoutEvaluationsInput, RFQSubmissionUncheckedCreateWithoutEvaluationsInput>
  }

  export type UserUpsertWithoutEvaluationsInput = {
    update: XOR<UserUpdateWithoutEvaluationsInput, UserUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<UserCreateWithoutEvaluationsInput, UserUncheckedCreateWithoutEvaluationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvaluationsInput, UserUncheckedUpdateWithoutEvaluationsInput>
  }

  export type UserUpdateWithoutEvaluationsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type RFQSubmissionUpsertWithoutEvaluationsInput = {
    update: XOR<RFQSubmissionUpdateWithoutEvaluationsInput, RFQSubmissionUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<RFQSubmissionCreateWithoutEvaluationsInput, RFQSubmissionUncheckedCreateWithoutEvaluationsInput>
    where?: RFQSubmissionWhereInput
  }

  export type RFQSubmissionUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: RFQSubmissionWhereInput
    data: XOR<RFQSubmissionUpdateWithoutEvaluationsInput, RFQSubmissionUncheckedUpdateWithoutEvaluationsInput>
  }

  export type RFQSubmissionUpdateWithoutEvaluationsInput = {
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rfq?: RFQUpdateOneRequiredWithoutSubmissionsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type RFQSubmissionUncheckedUpdateWithoutEvaluationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RFQCreateWithoutContractsInput = {
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutRfqsInput
    submissions?: RFQSubmissionCreateNestedManyWithoutRfqInput
    attachments?: DocumentCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQUncheckedCreateWithoutContractsInput = {
    id?: number
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    createdById: number
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutRfqInput
    attachments?: DocumentUncheckedCreateNestedManyWithoutRfqAttachmentsInput
  }

  export type RFQCreateOrConnectWithoutContractsInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutContractsInput, RFQUncheckedCreateWithoutContractsInput>
  }

  export type VendorCreateWithoutContractsInput = {
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialCreateNestedManyWithoutDefaultVendorInput
    priceEntries?: PriceEntryCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionCreateNestedManyWithoutVendorInput
    users?: UserCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryCreateNestedManyWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutContractsInput = {
    id?: number
    code?: string | null
    name: string
    contactName?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    status?: $Enums.VendorStatus
    address?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: CSI_MaterialUncheckedCreateNestedManyWithoutDefaultVendorInput
    priceEntries?: PriceEntryUncheckedCreateNestedManyWithoutVendorInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutVendorInput
    users?: UserUncheckedCreateNestedManyWithoutVendorInput
    documents?: VendorDocumentUncheckedCreateNestedManyWithoutVendorInput
    categories?: VendorCategoryUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorCreateOrConnectWithoutContractsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
  }

  export type DocumentCreateWithoutContractInput = {
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedAt?: Date | string
    ipc?: IPCCreateNestedOneWithoutAttachmentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
    rfqAttachments?: RFQCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentUncheckedCreateWithoutContractInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedById?: number | null
    uploadedAt?: Date | string
    ipcId?: number | null
    rfqAttachments?: RFQUncheckedCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentCreateOrConnectWithoutContractInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput>
  }

  export type DocumentCreateManyContractInputEnvelope = {
    data: DocumentCreateManyContractInput | DocumentCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type IPCCreateWithoutContractInput = {
    ipcNumber: string
    projectName?: string | null
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    createdAt?: Date | string
    attachments?: DocumentCreateNestedManyWithoutIpcInput
    submittedBy: UserCreateNestedOneWithoutIpcsInput
  }

  export type IPCUncheckedCreateWithoutContractInput = {
    id?: number
    ipcNumber: string
    projectName?: string | null
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    submittedById: number
    createdAt?: Date | string
    attachments?: DocumentUncheckedCreateNestedManyWithoutIpcInput
  }

  export type IPCCreateOrConnectWithoutContractInput = {
    where: IPCWhereUniqueInput
    create: XOR<IPCCreateWithoutContractInput, IPCUncheckedCreateWithoutContractInput>
  }

  export type IPCCreateManyContractInputEnvelope = {
    data: IPCCreateManyContractInput | IPCCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type VariationOrderCreateWithoutContractInput = {
    voRef: string
    description?: string | null
    costImpact?: number | null
    timeImpact?: number | null
    status?: string | null
    createdAt?: Date | string
  }

  export type VariationOrderUncheckedCreateWithoutContractInput = {
    id?: number
    voRef: string
    description?: string | null
    costImpact?: number | null
    timeImpact?: number | null
    status?: string | null
    createdAt?: Date | string
  }

  export type VariationOrderCreateOrConnectWithoutContractInput = {
    where: VariationOrderWhereUniqueInput
    create: XOR<VariationOrderCreateWithoutContractInput, VariationOrderUncheckedCreateWithoutContractInput>
  }

  export type VariationOrderCreateManyContractInputEnvelope = {
    data: VariationOrderCreateManyContractInput | VariationOrderCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type RFQUpsertWithoutContractsInput = {
    update: XOR<RFQUpdateWithoutContractsInput, RFQUncheckedUpdateWithoutContractsInput>
    create: XOR<RFQCreateWithoutContractsInput, RFQUncheckedCreateWithoutContractsInput>
    where?: RFQWhereInput
  }

  export type RFQUpdateToOneWithWhereWithoutContractsInput = {
    where?: RFQWhereInput
    data: XOR<RFQUpdateWithoutContractsInput, RFQUncheckedUpdateWithoutContractsInput>
  }

  export type RFQUpdateWithoutContractsInput = {
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutRfqsNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutRfqNestedInput
    attachments?: DocumentUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type RFQUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutRfqNestedInput
    attachments?: DocumentUncheckedUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type VendorUpsertWithoutContractsInput = {
    update: XOR<VendorUpdateWithoutContractsInput, VendorUncheckedUpdateWithoutContractsInput>
    create: XOR<VendorCreateWithoutContractsInput, VendorUncheckedCreateWithoutContractsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutContractsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutContractsInput, VendorUncheckedUpdateWithoutContractsInput>
  }

  export type VendorUpdateWithoutContractsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutVendorNestedInput
    users?: UserUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUpdateManyWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput
    categories?: VendorCategoryUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutContractInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutContractInput, DocumentUncheckedUpdateWithoutContractInput>
    create: XOR<DocumentCreateWithoutContractInput, DocumentUncheckedCreateWithoutContractInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutContractInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutContractInput, DocumentUncheckedUpdateWithoutContractInput>
  }

  export type DocumentUpdateManyWithWhereWithoutContractInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutContractInput>
  }

  export type IPCUpsertWithWhereUniqueWithoutContractInput = {
    where: IPCWhereUniqueInput
    update: XOR<IPCUpdateWithoutContractInput, IPCUncheckedUpdateWithoutContractInput>
    create: XOR<IPCCreateWithoutContractInput, IPCUncheckedCreateWithoutContractInput>
  }

  export type IPCUpdateWithWhereUniqueWithoutContractInput = {
    where: IPCWhereUniqueInput
    data: XOR<IPCUpdateWithoutContractInput, IPCUncheckedUpdateWithoutContractInput>
  }

  export type IPCUpdateManyWithWhereWithoutContractInput = {
    where: IPCScalarWhereInput
    data: XOR<IPCUpdateManyMutationInput, IPCUncheckedUpdateManyWithoutContractInput>
  }

  export type VariationOrderUpsertWithWhereUniqueWithoutContractInput = {
    where: VariationOrderWhereUniqueInput
    update: XOR<VariationOrderUpdateWithoutContractInput, VariationOrderUncheckedUpdateWithoutContractInput>
    create: XOR<VariationOrderCreateWithoutContractInput, VariationOrderUncheckedCreateWithoutContractInput>
  }

  export type VariationOrderUpdateWithWhereUniqueWithoutContractInput = {
    where: VariationOrderWhereUniqueInput
    data: XOR<VariationOrderUpdateWithoutContractInput, VariationOrderUncheckedUpdateWithoutContractInput>
  }

  export type VariationOrderUpdateManyWithWhereWithoutContractInput = {
    where: VariationOrderScalarWhereInput
    data: XOR<VariationOrderUpdateManyMutationInput, VariationOrderUncheckedUpdateManyWithoutContractInput>
  }

  export type VariationOrderScalarWhereInput = {
    AND?: VariationOrderScalarWhereInput | VariationOrderScalarWhereInput[]
    OR?: VariationOrderScalarWhereInput[]
    NOT?: VariationOrderScalarWhereInput | VariationOrderScalarWhereInput[]
    id?: IntFilter<"VariationOrder"> | number
    voRef?: StringFilter<"VariationOrder"> | string
    contractId?: IntFilter<"VariationOrder"> | number
    description?: StringNullableFilter<"VariationOrder"> | string | null
    costImpact?: FloatNullableFilter<"VariationOrder"> | number | null
    timeImpact?: IntNullableFilter<"VariationOrder"> | number | null
    status?: StringNullableFilter<"VariationOrder"> | string | null
    createdAt?: DateTimeFilter<"VariationOrder"> | Date | string
  }

  export type ContractCreateWithoutVariationOrdersInput = {
    contractNumber: string
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    rfq?: RFQCreateNestedOneWithoutContractsInput
    vendor: VendorCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    ipcs?: IPCCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutVariationOrdersInput = {
    id?: number
    contractNumber: string
    rfqId?: number | null
    vendorId: number
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutVariationOrdersInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutVariationOrdersInput, ContractUncheckedCreateWithoutVariationOrdersInput>
  }

  export type ContractUpsertWithoutVariationOrdersInput = {
    update: XOR<ContractUpdateWithoutVariationOrdersInput, ContractUncheckedUpdateWithoutVariationOrdersInput>
    create: XOR<ContractCreateWithoutVariationOrdersInput, ContractUncheckedCreateWithoutVariationOrdersInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutVariationOrdersInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutVariationOrdersInput, ContractUncheckedUpdateWithoutVariationOrdersInput>
  }

  export type ContractUpdateWithoutVariationOrdersInput = {
    contractNumber?: StringFieldUpdateOperationsInput | string
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfq?: RFQUpdateOneWithoutContractsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    documents?: DocumentUpdateManyWithoutContractNestedInput
    ipcs?: IPCUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutVariationOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    rfqId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: IntFieldUpdateOperationsInput | number
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutContractNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutContractNestedInput
  }

  export type DocumentCreateWithoutIpcInput = {
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedAt?: Date | string
    contract?: ContractCreateNestedOneWithoutDocumentsInput
    uploadedBy?: UserCreateNestedOneWithoutDocumentsInput
    rfqAttachments?: RFQCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentUncheckedCreateWithoutIpcInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedById?: number | null
    uploadedAt?: Date | string
    contractId?: number | null
    rfqAttachments?: RFQUncheckedCreateNestedManyWithoutAttachmentsInput
  }

  export type DocumentCreateOrConnectWithoutIpcInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutIpcInput, DocumentUncheckedCreateWithoutIpcInput>
  }

  export type DocumentCreateManyIpcInputEnvelope = {
    data: DocumentCreateManyIpcInput | DocumentCreateManyIpcInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutIpcsInput = {
    contractNumber: string
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    rfq?: RFQCreateNestedOneWithoutContractsInput
    vendor: VendorCreateNestedOneWithoutContractsInput
    documents?: DocumentCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutIpcsInput = {
    id?: number
    contractNumber: string
    rfqId?: number | null
    vendorId: number
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutIpcsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutIpcsInput, ContractUncheckedCreateWithoutIpcsInput>
  }

  export type UserCreateWithoutIpcsInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutIpcsInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutIpcsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIpcsInput, UserUncheckedCreateWithoutIpcsInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutIpcInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutIpcInput, DocumentUncheckedUpdateWithoutIpcInput>
    create: XOR<DocumentCreateWithoutIpcInput, DocumentUncheckedCreateWithoutIpcInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutIpcInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutIpcInput, DocumentUncheckedUpdateWithoutIpcInput>
  }

  export type DocumentUpdateManyWithWhereWithoutIpcInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutIpcInput>
  }

  export type ContractUpsertWithoutIpcsInput = {
    update: XOR<ContractUpdateWithoutIpcsInput, ContractUncheckedUpdateWithoutIpcsInput>
    create: XOR<ContractCreateWithoutIpcsInput, ContractUncheckedCreateWithoutIpcsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutIpcsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutIpcsInput, ContractUncheckedUpdateWithoutIpcsInput>
  }

  export type ContractUpdateWithoutIpcsInput = {
    contractNumber?: StringFieldUpdateOperationsInput | string
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfq?: RFQUpdateOneWithoutContractsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    documents?: DocumentUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutIpcsInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    rfqId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: IntFieldUpdateOperationsInput | number
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUncheckedUpdateManyWithoutContractNestedInput
  }

  export type UserUpsertWithoutIpcsInput = {
    update: XOR<UserUpdateWithoutIpcsInput, UserUncheckedUpdateWithoutIpcsInput>
    create: XOR<UserCreateWithoutIpcsInput, UserUncheckedCreateWithoutIpcsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIpcsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIpcsInput, UserUncheckedUpdateWithoutIpcsInput>
  }

  export type UserUpdateWithoutIpcsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutIpcsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ContractCreateWithoutDocumentsInput = {
    contractNumber: string
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    rfq?: RFQCreateNestedOneWithoutContractsInput
    vendor: VendorCreateNestedOneWithoutContractsInput
    ipcs?: IPCCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutDocumentsInput = {
    id?: number
    contractNumber: string
    rfqId?: number | null
    vendorId: number
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
    ipcs?: IPCUncheckedCreateNestedManyWithoutContractInput
    variationOrders?: VariationOrderUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutDocumentsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
  }

  export type IPCCreateWithoutAttachmentsInput = {
    ipcNumber: string
    projectName?: string | null
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    createdAt?: Date | string
    contract: ContractCreateNestedOneWithoutIpcsInput
    submittedBy: UserCreateNestedOneWithoutIpcsInput
  }

  export type IPCUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    ipcNumber: string
    projectName?: string | null
    contractId: number
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    submittedById: number
    createdAt?: Date | string
  }

  export type IPCCreateOrConnectWithoutAttachmentsInput = {
    where: IPCWhereUniqueInput
    create: XOR<IPCCreateWithoutAttachmentsInput, IPCUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutDocumentsInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type RFQCreateWithoutAttachmentsInput = {
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutRfqInput
    createdBy: UserCreateNestedOneWithoutRfqsInput
    submissions?: RFQSubmissionCreateNestedManyWithoutRfqInput
  }

  export type RFQUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    createdById: number
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutRfqInput
    submissions?: RFQSubmissionUncheckedCreateNestedManyWithoutRfqInput
  }

  export type RFQCreateOrConnectWithoutAttachmentsInput = {
    where: RFQWhereUniqueInput
    create: XOR<RFQCreateWithoutAttachmentsInput, RFQUncheckedCreateWithoutAttachmentsInput>
  }

  export type ContractUpsertWithoutDocumentsInput = {
    update: XOR<ContractUpdateWithoutDocumentsInput, ContractUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ContractCreateWithoutDocumentsInput, ContractUncheckedCreateWithoutDocumentsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutDocumentsInput, ContractUncheckedUpdateWithoutDocumentsInput>
  }

  export type ContractUpdateWithoutDocumentsInput = {
    contractNumber?: StringFieldUpdateOperationsInput | string
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfq?: RFQUpdateOneWithoutContractsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    ipcs?: IPCUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    rfqId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: IntFieldUpdateOperationsInput | number
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcs?: IPCUncheckedUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUncheckedUpdateManyWithoutContractNestedInput
  }

  export type IPCUpsertWithoutAttachmentsInput = {
    update: XOR<IPCUpdateWithoutAttachmentsInput, IPCUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<IPCCreateWithoutAttachmentsInput, IPCUncheckedCreateWithoutAttachmentsInput>
    where?: IPCWhereInput
  }

  export type IPCUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: IPCWhereInput
    data: XOR<IPCUpdateWithoutAttachmentsInput, IPCUncheckedUpdateWithoutAttachmentsInput>
  }

  export type IPCUpdateWithoutAttachmentsInput = {
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutIpcsNestedInput
    submittedBy?: UserUpdateOneRequiredWithoutIpcsNestedInput
  }

  export type IPCUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: IntFieldUpdateOperationsInput | number
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    submittedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type RFQUpsertWithWhereUniqueWithoutAttachmentsInput = {
    where: RFQWhereUniqueInput
    update: XOR<RFQUpdateWithoutAttachmentsInput, RFQUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<RFQCreateWithoutAttachmentsInput, RFQUncheckedCreateWithoutAttachmentsInput>
  }

  export type RFQUpdateWithWhereUniqueWithoutAttachmentsInput = {
    where: RFQWhereUniqueInput
    data: XOR<RFQUpdateWithoutAttachmentsInput, RFQUncheckedUpdateWithoutAttachmentsInput>
  }

  export type RFQUpdateManyWithWhereWithoutAttachmentsInput = {
    where: RFQScalarWhereInput
    data: XOR<RFQUpdateManyMutationInput, RFQUncheckedUpdateManyWithoutAttachmentsInput>
  }

  export type UserCreateWithoutApprovalsInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutApprovalsInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
  }

  export type UserUpsertWithoutApprovalsInput = {
    update: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateWithoutApprovalsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    uuid?: string
    name?: string | null
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCCreateNestedManyWithoutSubmittedByInput
    rfqs?: RFQCreateNestedManyWithoutCreatedByInput
    role: RoleCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    ipcs?: IPCUncheckedCreateNestedManyWithoutSubmittedByInput
    rfqs?: RFQUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ApprovalCreateManyApproverInput = {
    id?: number
    entityType: string
    entityId: number
    sequence: number
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    actedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    action: string
    entity?: string | null
    entityId?: number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentCreateManyUploadedByInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedAt?: Date | string
    ipcId?: number | null
    contractId?: number | null
  }

  export type EvaluationCreateManyEvaluatorInput = {
    id?: number
    submissionId: number
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
  }

  export type IPCCreateManySubmittedByInput = {
    id?: number
    ipcNumber: string
    projectName?: string | null
    contractId: number
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    body?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type RFQCreateManyCreatedByInput = {
    id?: number
    rfqNumber: string
    projectName: string
    packageScope?: string | null
    itemDesc?: string | null
    csiCode?: string | null
    estimatedUnitPrice?: number | null
    requiredDate?: Date | string | null
    targetSubmissionDate?: Date | string | null
    currency?: string
    status?: $Enums.RFQStatus
    createdAt?: Date | string
    description?: string | null
    dueDate?: Date | string | null
    title: string
    updatedAt?: Date | string
  }

  export type ApprovalUpdateWithoutApproverInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUploadedByInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutDocumentsNestedInput
    ipc?: IPCUpdateOneWithoutAttachmentsNestedInput
    rfqAttachments?: RFQUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
    rfqAttachments?: RFQUncheckedUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EvaluationUpdateWithoutEvaluatorInput = {
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submission?: RFQSubmissionUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutEvaluatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    submissionId?: IntFieldUpdateOperationsInput | number
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyWithoutEvaluatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    submissionId?: IntFieldUpdateOperationsInput | number
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IPCUpdateWithoutSubmittedByInput = {
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: DocumentUpdateManyWithoutIpcNestedInput
    contract?: ContractUpdateOneRequiredWithoutIpcsNestedInput
  }

  export type IPCUncheckedUpdateWithoutSubmittedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: IntFieldUpdateOperationsInput | number
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: DocumentUncheckedUpdateManyWithoutIpcNestedInput
  }

  export type IPCUncheckedUpdateManyWithoutSubmittedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: IntFieldUpdateOperationsInput | number
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQUpdateWithoutCreatedByInput = {
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutRfqNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutRfqNestedInput
    attachments?: DocumentUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type RFQUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutRfqNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutRfqNestedInput
    attachments?: DocumentUncheckedUpdateManyWithoutRfqAttachmentsNestedInput
  }

  export type RFQUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    vendorId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
  }

  export type UserUpdateWithoutRoleInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    vendor?: VendorUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CSI_MaterialCreateManyDefaultVendorInput = {
    id?: number
    csiCode?: string | null
    name: string
    unit?: string | null
  }

  export type ContractCreateManyVendorInput = {
    id?: number
    contractNumber: string
    rfqId?: number | null
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type PriceEntryCreateManyVendorInput = {
    id?: number
    materialId: number
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
  }

  export type RFQSubmissionCreateManyVendorInput = {
    id?: number
    rfqId: number
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
  }

  export type UserCreateManyVendorInput = {
    id?: number
    uuid?: string
    name?: string | null
    email: string
    password: string
    roleId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessCode?: string | null
    status?: string
  }

  export type VendorDocumentCreateManyVendorInput = {
    id?: number
    docType: string
    url: string
    fileName: string
    expiryDate?: Date | string | null
    uploadedAt?: Date | string
  }

  export type CSI_MaterialUpdateWithoutDefaultVendorInput = {
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priceEntries?: PriceEntryUpdateManyWithoutMaterialNestedInput
  }

  export type CSI_MaterialUncheckedUpdateWithoutDefaultVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUpdateWithoutVendorInput = {
    contractNumber?: StringFieldUpdateOperationsInput | string
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rfq?: RFQUpdateOneWithoutContractsNestedInput
    documents?: DocumentUpdateManyWithoutContractNestedInput
    ipcs?: IPCUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    rfqId?: NullableIntFieldUpdateOperationsInput | number | null
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutContractNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    rfqId?: NullableIntFieldUpdateOperationsInput | number | null
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceEntryUpdateWithoutVendorInput = {
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: CSI_MaterialUpdateOneRequiredWithoutPriceEntriesNestedInput
  }

  export type PriceEntryUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceEntryUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQSubmissionUpdateWithoutVendorInput = {
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUpdateManyWithoutSubmissionNestedInput
    rfq?: RFQUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type RFQSubmissionUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type RFQSubmissionUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqId?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutVendorInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    rfqs?: RFQUpdateManyWithoutCreatedByNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutSubmittedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    rfqs?: RFQUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VendorDocumentUpdateWithoutVendorInput = {
    docType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDocumentUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorDocumentUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCategoryUpdateWithoutVendorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCategoryUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCategoryUncheckedUpdateManyWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpdateWithoutCategoriesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutVendorNestedInput
    users?: UserUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: CSI_MaterialUncheckedUpdateManyWithoutDefaultVendorNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutVendorNestedInput
    priceEntries?: PriceEntryUncheckedUpdateManyWithoutVendorNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutVendorNestedInput
    users?: UserUncheckedUpdateManyWithoutVendorNestedInput
    documents?: VendorDocumentUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVendorStatusFieldUpdateOperationsInput | $Enums.VendorStatus
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceEntryCreateManyMaterialInput = {
    id?: number
    vendorId: number
    unitPrice: number
    currency?: string
    createdAt?: Date | string
    effectiveDate?: Date | string
    expiryDate?: Date | string | null
    updatedAt?: Date | string
  }

  export type PriceEntryUpdateWithoutMaterialInput = {
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPriceEntriesNestedInput
  }

  export type PriceEntryUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceEntryUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateManyRfqInput = {
    id?: number
    contractNumber: string
    vendorId: number
    contractValue: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type RFQSubmissionCreateManyRfqInput = {
    id?: number
    vendorId: number
    submittedAt?: Date | string | null
    totalValue?: number | null
    currency?: string
    docUrl?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    totalAmount?: number | null
  }

  export type ContractUpdateWithoutRfqInput = {
    contractNumber?: StringFieldUpdateOperationsInput | string
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutContractsNestedInput
    documents?: DocumentUpdateManyWithoutContractNestedInput
    ipcs?: IPCUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutContractNestedInput
    ipcs?: IPCUncheckedUpdateManyWithoutContractNestedInput
    variationOrders?: VariationOrderUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    contractValue?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RFQSubmissionUpdateWithoutRfqInput = {
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUpdateManyWithoutSubmissionNestedInput
    vendor?: VendorUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type RFQSubmissionUncheckedUpdateWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type RFQSubmissionUncheckedUpdateManyWithoutRfqInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DocumentUpdateWithoutRfqAttachmentsInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutDocumentsNestedInput
    ipc?: IPCUpdateOneWithoutAttachmentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutRfqAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DocumentUncheckedUpdateManyWithoutRfqAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EvaluationCreateManySubmissionInput = {
    id?: number
    evaluatorId: number
    technicalScore?: number | null
    financialScore?: number | null
    experienceScore?: number | null
    responsiveness?: number | null
    otherScore?: number | null
    totalScore?: number | null
    comments?: string | null
    createdAt?: Date | string
  }

  export type EvaluationUpdateWithoutSubmissionInput = {
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluatorId?: IntFieldUpdateOperationsInput | number
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyWithoutSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluatorId?: IntFieldUpdateOperationsInput | number
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    financialScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    responsiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    otherScore?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyContractInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedById?: number | null
    uploadedAt?: Date | string
    ipcId?: number | null
  }

  export type IPCCreateManyContractInput = {
    id?: number
    ipcNumber: string
    projectName?: string | null
    periodFrom?: Date | string | null
    periodTo?: Date | string | null
    currentValue: number
    cumulativeValue?: number | null
    deductions?: number | null
    netPayable?: number | null
    status?: $Enums.IPCStatus
    submittedById: number
    createdAt?: Date | string
  }

  export type VariationOrderCreateManyContractInput = {
    id?: number
    voRef: string
    description?: string | null
    costImpact?: number | null
    timeImpact?: number | null
    status?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutContractInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipc?: IPCUpdateOneWithoutAttachmentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
    rfqAttachments?: RFQUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
    rfqAttachments?: RFQUncheckedUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipcId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IPCUpdateWithoutContractInput = {
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: DocumentUpdateManyWithoutIpcNestedInput
    submittedBy?: UserUpdateOneRequiredWithoutIpcsNestedInput
  }

  export type IPCUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    submittedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: DocumentUncheckedUpdateManyWithoutIpcNestedInput
  }

  export type IPCUncheckedUpdateManyWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipcNumber?: StringFieldUpdateOperationsInput | string
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    periodFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    cumulativeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    deductions?: NullableFloatFieldUpdateOperationsInput | number | null
    netPayable?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumIPCStatusFieldUpdateOperationsInput | $Enums.IPCStatus
    submittedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationOrderUpdateWithoutContractInput = {
    voRef?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timeImpact?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationOrderUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    voRef?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timeImpact?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationOrderUncheckedUpdateManyWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    voRef?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timeImpact?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyIpcInput = {
    id?: number
    fileName: string
    fileUrl: string
    url: string
    mimeType?: string | null
    size?: number | null
    uploadedById?: number | null
    uploadedAt?: Date | string
    contractId?: number | null
  }

  export type DocumentUpdateWithoutIpcInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneWithoutDocumentsNestedInput
    rfqAttachments?: RFQUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutIpcInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
    rfqAttachments?: RFQUncheckedUpdateManyWithoutAttachmentsNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutIpcInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RFQUpdateWithoutAttachmentsInput = {
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutRfqNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRfqsNestedInput
    submissions?: RFQSubmissionUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutRfqNestedInput
    submissions?: RFQSubmissionUncheckedUpdateManyWithoutRfqNestedInput
  }

  export type RFQUncheckedUpdateManyWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfqNumber?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    packageScope?: NullableStringFieldUpdateOperationsInput | string | null
    itemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    csiCode?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetSubmissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    status?: EnumRFQStatusFieldUpdateOperationsInput | $Enums.RFQStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}